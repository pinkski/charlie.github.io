
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="yolynn">
    <title>Archives: 2016 - yolynn</title>
    <meta name="author" content="yolynn">
    
    
        <link rel="icon" href="http://yolynn.com/assets/images/head.png">
    
    
    <meta name="description" content="云在青天水在瓶 - 幽灵鸟">
<meta property="og:type" content="blog">
<meta property="og:title" content="yolynn">
<meta property="og:url" content="http://yolynn.com/archives/2016/index.html">
<meta property="og:site_name" content="yolynn">
<meta property="og:description" content="云在青天水在瓶 - 幽灵鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yolynn">
<meta name="twitter:description" content="云在青天水在瓶 - 幽灵鸟">
    
    
        
    
    
        <meta property="og:image" content="http://yolynn.com/assets/images/head.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">yolynn</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="/#about">
        
        
            <i class="fa fa-lg fa-head.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.png"/>
            </a>
            <span class="sidebar-profile-name">yolynn</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/yolynn-bird" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://weibo.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-weibo"></i>
                    <span class="sidebar-button-desc">global.weibo</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://stackoverflow.com/users/2662962/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-stack-overflow"></i>
                    <span class="sidebar-button-desc">Stack Overflow</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.instagram.com/yolynn.zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-instagram"></i>
                    <span class="sidebar-button-desc">global.instagram</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://dribbble.com/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-dribbble"></i>
                    <span class="sidebar-button-desc">global.dribbble</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="http://yolynn.com/2010/04/22/weixin/"
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-weixin"></i>
                    <span class="sidebar-button-desc">global.weixin</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.zhihu.com/people/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-flickr"></i>
                    <span class="sidebar-button-desc">global.zhihu</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto://zxl20zxl@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/11/RN&Weex/">
                            如何一网打尽React、Redux、ReactNative、Vue、Weex、微信小程序？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-11T18:15:02+08:00">
	
		    Nov 11, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>最近两年，是移动互联翻天覆地的两年，也是前端javascript大放异彩的两年，这跟刚出生那会儿取名还需要借着java的名声已经有着天壤之别，nodejs一出山便带着一统前后端的野心，Reactjs被FB推出后在前端掀起组件化热潮、并且把前端的性能提升一个档次，ReactNative则基于React的基础被赋予了另外一层使命，那就是占领移动端的山头，可以说现在javascript能做的事情不可谓不多，FB推出这两款重量级产品足以在程序界掀起轩然大波，作为github活跃度最高的语言，作为github领头羊级别的产品，当然少不了以其为核心的周边产品或衍生品，比如React Redux 、Weex 以及微信小程序，你得承认它们的确是站在了巨人肩膀上做出来的更好的产品。</p>
</blockquote>
<h2 id="React">React</h2><p>初识Reactjs会很容易有一些误解，比如有人拿它和Angular、ember做比较,其实这完全是不对的，这里是要特别指出易误解和建议：</p>
<ol>
<li>Reactjs只是一个单纯的视图库，并非MVC框架，好吧，它事实上框架也不是，仅仅只是一个渲染视图的库</li>
<li>组件要尽可能的小，较小的类，较小的模块更易于维护</li>
<li><p>写函数式组件，定义React组件的方式有多种方式，推荐第三种方式</p>
<ul>
<li><p>使用React.creatClass()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myComponent = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">&#123;this.props.className&#125;</span>/&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ES6 extends语法糖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycomponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">&#123;this.props.className&#125;</span>/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>React 0.14引入的语法，使用属性作为参数的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myComponent = props =&gt; (</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">&#123;props.className&#125;</span>/&gt;</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li>写无状态组件，很多项目由于状态多变得混乱而难于管理</li>
<li>使用Redux.js，React每个组件都可以拥有自己的状态管理，但是上面说了无状态的组件更容易维护，那么这时候最好是借助第三方状态管理库Redux.js，尤其是在全局状态管理中redux的优势会让你的项目整个流程非常清晰</li>
<li>使用JSX、ES6、Babel、Webpack、npm</li>
</ol>
<h6 id="小结">小结</h6><p>正是由于React的Vitual DOM、轻Component、组件状态state等独特性造就了它在渲染页面时的高性能，从根本上分析，当用户在浏览器输入URL地址后会发生这些事情：</p>
<ol>
<li>webview执行loadURL</li>
<li>通过DNS获取对应的IP</li>
<li>从webserver获取处理过的文件html+css+js+img等</li>
<li>浏览器分析这些文件后要建立DOM树</li>
<li>渲染页面</li>
</ol>
<p>DOM树的每一次建立和刷新都是在内存中完成，React通过创建与DOM一致的Vitual DOM结合state的变化比对出DOM树真正需要修改的地方，再通过Component render()不同的地方而不需要每次都在内存中刷新整个DOM树，大大提升了渲染性能。</p>
<h2 id="Redux">Redux</h2><p>既然在上文介绍React时提到了Redux，Redux到底是什么、做什么用的？为啥要用？</p>
<ol>
<li><p>Redux是什么、做什么用的？</p>
<p> redux是应用状态管理的库，帮你编写易于测试和管理的代码</p>
</li>
<li><p>为什么要用Redux？</p>
<p> 随着单页面变得越来越复杂，前端代码需要管理各种各样的状态，比如可能是服务器的响应，可能是前端界面的状态，当这个状态变得任意可变，那么你可能在某个时间点失去对整个应用状态的控制。Redux为整个应用创建并管理一颗状态树，并通过限制更新发生的时间和方式，使整个应用的状态变得可以预测。</p>
</li>
</ol>
<h6 id="小结-1">小结</h6><p>Redux遵循了三大原则：</p>
<ol>
<li>全局单一数据源</li>
<li>state不可变</li>
<li>reducer纯函数</li>
</ol>
<p>形成以action reducer store components组成的回路、state则从components传导至action，再通过reducer和旧的state通过计算生成新的state并保存至新的state，redux通过connect函数绑定state和UI，那么UI则会根据state的变化而发生更新</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234637-4c60ce39ecad2a42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>虽然Redux和React并没有必然关系，但是Redux用于管理state，确特别适合那些 state=&gt;UI 的库，当然了你也可以在ReactNative中引入Redux，具体操作可以参见：<a href="http://www.jianshu.com/p/2c43860b0532?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="external">点这里</a></p>
<h2 id="React_Native">React Native</h2><p>ReactNative无论在前端界还是客户端可谓是无人不知、无人不晓，你可以诟病它的各种痛点，但是你却不能忽视它的成长，我估计大家多多少少都有动手用过用过RN了，那么RN到底是怎么一步一步从JSX转换为原生的视图呢？它究竟还存在哪些痛点呢？为何还不能大面积覆盖使用到APP项目中呢？</p>
<ol>
<li><p>原理</p>
<p> RN的整个工作流下来大概是这样：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React(JSX) =&gt; bundle.js =&gt; JavaScriptCore(iOS) =&gt; Visual DOM =&gt; ReactSDK =&gt; Native控件</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>痛点</p>
<ul>
<li>RN虽然各方表现都很优秀，但是目前RN依旧还没有一个稳定的版本，基本保持在两周就要更新一个新版本，对于版本升级需要趟坑在所难免，讲不好一个新版发出来一言不合某个API就不能用了。</li>
<li>RN的listView性能问题，官方至今也没有完美的解决方案，RN的自带listView并没有回收机制，这样在加载较多数据时，APP内存会非常吃紧，不过github上也有大牛开发了RN的tableview可以试试：<a href="https://github.com/aksonov/react-native-tableview" target="_blank" rel="external">点这里</a></li>
<li>业务高速发展，view层级过多会导致内存消耗，页面卡顿，这种情况需要尽可能的减少层级嵌套，尽可能的抽取能够复用的组件</li>
<li>逻辑越来越复杂，导致state设置过多，维护困难，这种情况我想你也知道怎么解决了吧？引入Redux</li>
<li>单个页面代码超过千行，重复造轮子</li>
<li>就开发来说：依赖工具太多、真机调试繁琐、文档过于臃肿、JSX学习成本等</li>
</ul>
</li>
<li><p>为何开发了却不上线？</p>
<p> 据我所知的现状是：XX会 X蜂都多少为自己的APP开发RN模块并完成测试，却一直没有上线，虽然它们在代码中使用了webview降级方案以规避风险，个人认为几点的原因，欢迎补充</p>
<ul>
<li>广告档期使用了listview，并且有大量的数据需要展示，这里会有性能问题上面提过</li>
<li>广告档期页面属于长时间存在于APP的模块且业务逻辑复杂属于经常变动类型导致开发的代码大量堆积，考虑维护成本</li>
<li>开发的页面属于用户量非常大，运营不够有信心对新技术冒险</li>
<li>RN开发人员缺乏</li>
</ul>
</li>
</ol>
<h6 id="小结-2">小结</h6><p>RN基于jsbrige和ocbrige实现js和OC的互调: OC能通过JSContext知道js的上下文因此很简单的就能调用js，而反过来调用js需要知道OC的上下文，其实RN实现的方式是在两端分别提供了一份配置表，这样jsbrige发送消息给ocbrige时会在配置表中验证一次，保证OC runtime执行函数存在。</p>
<p>思考下这与传统的js和OC互调有什么原理上的区别？（比如Cordova、UrlProtocal、UIWebView、WKWebview等）    </p>
<h2 id="Vue">Vue</h2><p>前端的两大杀器FB的React和google的Angular，既然他们不是作为正面对手而出现，那么有没有一款吸收了两者精华的产品出现呢？答案是肯定的，其实最擅长取其精华，去其糟粕的事情非中国人莫属，Vue框架就是中国人开发的并且在前端界有着要三分天下的雄心，目前Vue已经出到2.0：</p>
<blockquote>
<p>Vue.js的目标是通过尽可能简单的API实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-22ac84c532a7be20.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Vue通过标签template、script、style标签区分html js css脚本，所有的内容归并到.vue文件，这样一个功能或者模块就是一个.vue组件，对于后期的组件重用和维护也变得非常敏捷</p>
<p>可能你会担心浏览器是如何解析.vue文件，事实上当你开发了.vue的组建后还需要通过webpack打包工具在打包时拆分为浏览器需要的脚本即可，当然也很简单，对于webpack还不够了解的同学可以:<a href="http://www.jianshu.com/p/4cc1d29309b6" target="_blank" rel="external">点这里</a></p>
<h6 id="小结-3">小结</h6><p>Vue作者称其性能是好过React的，而且又与React如此的相似，同样在数据绑定上吸收了Angular的特点，并且解决了很多Angular的痛点，还提供了如此简单的API，你应该没有理由拒绝它。</p>
<h2 id="Weex">Weex</h2><p>听到不少用ReactNative开发的各种抱怨：“环境搭了一整天，真机调试又花去了大半天，一个错误定位了两个钟” 等等，可能真的在你尝试了两天RN开发后选择了放弃或者硬着头皮解决各种和代码无关的痛点，Weex推出来后，我想你会对RN这种模式的开发更有兴趣，它确实很好的解决了这些痛点，同样无愧于一款站在巨人肩膀上的好产品</p>
<ol>
<li><p>工作流<br> <img src="http://gtms02.alicdn.com/tps/i2/TB1ootBMpXXXXXrXXXXwi60UVXX-596-397.png" alt=""></p>
<p> 通过nodejs实现的transformer将组件.we文件转换为jsbunndle并发布到服务器上，客户端从服务器端获取jsbundle通过内置的js framework(iOS:javascriptcore android:v8)解析成Vitual DOM树，接着使用内嵌的week framework解析对应的DOM树为native控件并添加与css和js对应的样式排版和事件。</p>
</li>
<li><p>对比ReactNative</p>
<ul>
<li>核心理念并没有差异</li>
<li>.we基于Vue基础，使其拥有了Vue的所有优点，又摆脱了React JSX学习成本。</li>
<li>weex打的js bundle只有js代码，体积小很多，基础js库包含在weex sdk中</li>
<li>调试时weex支持在chrome中预览DOM结点</li>
<li>weex提供了weexplayground（可在appstore下载），方便预览调试</li>
<li>性能上weex listview稍好，对长view渲染有优化</li>
</ul>
</li>
<li><p>痛点</p>
<ul>
<li>weex文档，看过的人知道的痛，我都有要给它写文档的冲动</li>
<li>当然，社区还是比不上RN</li>
</ul>
</li>
</ol>
<h6 id="小结-4">小结</h6><p>Weex让我们对于类RN模式的开发更加容易接受，之前有人在Weex编程大赛中一天时间做了一个APP（<a href="https://github.com/dodola/WeexOne" target="_blank" rel="external">One一个</a>），这让我很惶恐，Winter is coming! 你备好你的粮草了吗？</p>
<h2 id="微信小程序">微信小程序</h2><p>与其它框架有所不同的是，因为微信小程序并非开源的，因此有些原理上或工作流上的描述有部分带猜测的成分，如果有错误望指正</p>
<ol>
<li><p>工作流<br> 微信小程序应该是主动绕过了浏览器而是直接调用浏览器内核，本质上是运行在浏览器模式中的，而微信作为它的承载，可以管理它的生命周期，对于多个小程序的生命周期应该是利用了栈来管理。</p>
</li>
<li><p>微信的开发生态圈</p>
<ul>
<li>框架：组件开发形式包括视图文件WXML和WXSS，以及基于javascript的逻辑层框架</li>
<li>响应的数据绑定：当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新</li>
<li>页面管理：框架 管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期</li>
<li>基础组件：框架 提供了一套基础的组件，这些组件自带微信风格的样式</li>
<li>丰富的 API：框架 提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等</li>
<li><p>eg:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is our View --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">view</span>&gt;</span> Hello &#123;&#123;name&#125;&#125;! <span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">bindtap</span>=<span class="value">"changeName"</span>&gt;</span> Click me! <span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">// This is our App Service.</span><br><span class="line">// This is our data.</span><br><span class="line">var helloData = &#123;</span><br><span class="line"> 	name: 'WeChat'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Register a Page.</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: helloData,</span><br><span class="line">  changeName: function(e) &#123;</span><br><span class="line">    // sent data change to view</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      name: 'MINA'</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h6 id="小结-5">小结</h6><p>相比于Native APP，微信小程序的开发成本有所降低，但也有限，当然微信小程序提供的功能也有限，通过小程序可能会帮你留住一些轻度用户，比如订机票酒店等这之类</p>
<h2 id="总结">总结</h2><p>前端界千变万化，要如何翻越这一座又一座的大山？打好基础，打持久战，分解小目标，比如javascript的基础我把它分为：原型和原型链，上下文环境和作用域，单线程和异步三个小山头，在征服这些小山头后，想要征服大山就很容易了。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/11/11/RN&Weex/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/02/runtime/">
                            Runtime基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-02T18:15:02+08:00">
	
		    Nov 02, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习runtime需要会什么？">学习runtime需要会什么？</h2><p>学习runtime的前提最好要有C语言的基础，通过阅读runtime中一些个重要以objc<em> class</em> object_开头的struct结构体，帮助理解runtime里的各个struct是如何关联的、strunct和method ivar是如何关联的，从而上升到Objective-C层，完全理解Object之间的关联关系，Selector的调用原理等。 </p>
<h2 id="runtime是什么?">runtime是什么?</h2><h4 id="原理">原理</h4><p><img src="https://www.processon.com/chart_image/5847cfcae4b0d594ec4aaefd.png" alt=""></p>
<p>从上图可以看出instance -&gt; class -&gt; superclass -&gt; rootclass之间的关系，首先抛开instance不谈，他们遵循了由下而上的继承关系，而class的实例对象instance则通过isa指针指向了objc_class，那么可想而知，instance在做属性获取或者消息转发时都会通过isa指针查找objc_class中的属性和方法</p>
<p>再来看一张图:<br><img src="https://www.processon.com/chart_image/5847d87ae4b005d48b553c53.png" alt=""></p>
<p>上图更加清晰的反映了各种instance和class、metaclass之间的关系，其实记住一条线性关系：所有的instance都是通过isa指向了objc_class结构,objc_class则会指向自己的meta_class，而meta_class会最终指向root meta_class, root meta_class会指向自己, root meta_class继承于root class, 而root class的isa指向nil。</p>
<p>额外要补充内存存储问题，在instance中声明的<em>-函数</em>和<em>普通成员</em>会存储在isa指向的objc_class中而<em>+函数</em>和<em>static成员</em>则会存储到object_class指向的meta_class中。</p>
<h4 id="消息转发机制">消息转发机制</h4><p>消息传递，objc_msgSend()是重点函数，我们回过去看第一张图的箭头，其实runtime的消息传递也是走的箭头路径，一层一层传递</p>
<p>消息转发，发送消息给一个不处理该消息的对象时会发生错误，而在宣布错误之前，runtime为接收消息的对象为消息处理提供了二次机会。当某个对象不能处理消息时，可以通过重写-forwardInvocation:方法提供一个默认的消息响应避免出错，看本文的第二张图，在对象无法找到消息对应的方法实现时，会按照图中的继承关系一层层往上找。</p>
<p><img src="https://www.processon.com/chart_image/5847db5ce4b0d594ec4c0e73.png" alt=""></p>
<p>上图是一个消息的处理工作流，在消息发给对象后，消息得不到对象处理，则会启动<strong>消息转发</strong>机制，大概有几个阶段：</p>
<ol>
<li>询问reciever能否动态的添加方法，以处理当前消息，也叫<em>动态方法解析</em>，runtime会通过resolveInstanceMethod:判断能否处理</li>
<li>询问之后，如果还是无法响应则询问reciever是否有其它reciever能够处理这条消息</li>
<li>若无备用reciever返回，runtime会把全部细节封装到NSInvocation中，再给reciever一次机会解决这条消息</li>
</ol>
<h2 id="为什么用runtime?">为什么用runtime?</h2><p>搞清楚了runtime的原理和消息转发机制，在为什么要用runtime的问题上，也可以通过围绕原理和消息转发分析：</p>
<blockquote>
<p>Objective-C的面向对象、消息派发、动态绑定和内存管理都与runtime息息相关</p>
</blockquote>
<h2 id="runtime的使用方式">runtime的使用方式</h2><p>Objective-C中有三种与runtime系统交互级别，由浅到深：</p>
<ol>
<li>通过OC的源代码，比如调用某个函数</li>
<li>通过Foundation库中定义的NSObject提供的方法，比如performSelector:</li>
<li>通过引进runtime头文件，直接使用runtime方法</li>
</ol>
<h2 id="runtime的实际应用">runtime的实际应用</h2><p>runtime的实际应用有很多：</p>
<ol>
<li>给category添加属性</li>
<li>Method Sizzling hook 系统函数，在系统函数之前做一些特殊处理</li>
<li>dic 转 model</li>
<li>生命周期log 埋点</li>
<li>jspatch aspect 等第三方框架</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/11/02/runtime/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/17/my_fullstack/">
                            我所理解的全栈工程师
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-17T18:15:02+08:00">
	
		    Oct 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="background">background</h6><blockquote>
<p>正是由于对工作中接受到的各种技术的好奇心，开始了我的一段全栈之旅路程，在成为或即将成为全栈的路上，有好几次在思索自己到底做了什么，为什么会选择想成为全栈？</p>
<p>为什么？每次自我检索总结得时候我总能得出结论，从小到大我就希望变得很全能，比如喜欢上了徒步后买好了各种装备说走就走、喜欢上了游泳后逼着自己学会了四种泳姿、喜欢上了篮球后挑了最全能的小前锋位置等等，可能一直到大都被自己觉得自己无所不能的无畏驱使，就像是对自己说：小伙子，年轻的你有什么是学不会的啊？有什么问题是解决不了的啊？</p>
<p>OK,让我言归正传，我所理解的全栈工程师</p>
</blockquote>
<h6 id="我认识全栈的短板">我认识全栈的短板</h6><pre><code>人们以为全栈工程师什么都会，这是一个明显的误区——然而要改变这个误区很难。最后，导致的结果是大家觉得全栈工程师的水平也就那样。换句来说，人们根本不知道什么是全栈工程师。在平时的工作里，你的队伍都知道你在不同领域有丰富的知识。而在那些不了解你的人的印象里，就是猜测你什么都会。

因此，这就会变成一个骂名，也是一个在目前看来很难改变的问题。在这方面只能尽可能地去了解一些通用的问题，并不能去了解所有的问题。在一次被面试全栈工程师的过程中，有一个面试官准备了几个不同语言（JavaScript、Java、Python、Ruby)的问题来问我，我只想说 Ciao —— 意大利语：你好！

除了这个问题——人们不了解什么是全栈工程师。还有一个问题，就是刚才我们说的成为专家的老大难问题。
</code></pre><h6 id="我选择全栈的理由">我选择全栈的理由</h6><ul>
<li>这个世界充满了未解的迷</li>
<li>没有探索，哪来的真爱</li>
</ul>
<h6 id="我成为全栈的基础">我成为全栈的基础</h6><ul>
<li><p>工具只是辅助 </p>
<p>  我们要的是把主要精力放在学习的东西上，而不是工具</p>
</li>
<li><p>语言也是一种工具</p>
<p>  越来越多的框架和语言出现、更新得越来越快。特别是这样一个高速发展的产业，每天都在涌现新的名词。如同我们选择语言一样，选择合适的有时候会比选得顺手的来得重要。然而，这个可以不断地被推翻。</p>
</li>
<li><p>环境搭建</p>
<p>Homebrew、Homebrew Cask、iTerm2、Zsh、Oh My Zsh、Sublime Text 2、MacDown、CheatSheet、SourceTree、Alfred、Vimium</p>
</li>
</ul>
<h6 id="我如何学好一门语言">我如何学好一门语言</h6><ul>
<li><p>输出是最好的输入</p>
<p>如果有人问你如何学一门新语言、技术，那么答案就是写一本书。</p>
</li>
<li><p>如何应用一门新的技术</p>
<p>学习一门新的技术的最好实践就是用这门技术对现有的系统行重写。</p>
</li>
</ul>
<h6 id="我的Web_编程基础">我的Web 编程基础</h6><ul>
<li><p>从浏览器到服务器</p>
<p>  我们会发现解析 DNS 的时候，我们需要先本地 DNS 服务器查询。如果没有的话，再向根域名服务器查询——这个域名由哪个服务器来解析。直至最后拿到真正的服务器IP才能获取页面。当我们拿到相应的 HTML、JS、CSS 后，我们就开始渲染这个页面了</p>
</li>
<li><p>HTML + CSS + JavaScript  <a href="http://yolynn.com/2016/05/17/my_html/">详细见这里</a></p>
</li>
</ul>
<h6 id="我的前端与后台">我的前端与后台</h6><ul>
<li><p>后台语言选择</p>
<blockquote>
<p>JavaScript:对于 JavaScript 来说，它可以做很多类型的应用。这些应用都是基于浏览器来运行的，有：</p>
<ol>
<li>Electron + Node.js + JavaScript 做桌面应用</li>
<li>Ionic + JavaScript 做移动应用</li>
<li>Node.js + JavaScript 网站前后台</li>
<li>JavaScript + Tessl 做硬件</li>
</ol>
<p>Python:Python 是一门简洁的语言，而且有大量的数学、科学工具，这意味着在不远的将来它会发挥更大的作用。我喜欢在我的各种小项目上用 Python，如果不是因为我对前端及数据可视化更感兴趣，那么Python 就是我的第一语言了。</p>
<p>Java:在学校的时候，一点儿也不喜欢 Java。后来才发现，我从 Java 上学到的东西比其他语言上学得还多。如果 Oracle 不毁坏 Java，那么他会继续存活很久。我可以用 JavaScript 造出各种我想要的东西，但是通常我无法保证他们是优雅的实现。过去人们在 Java 上花费了很多的时间，或在架构上，或在语言上，或在模式上。由于这些投入，都给了人们很多的启发。这些都可以用于新的语言，新的设计，毕竟没有什么技术是独立于旧的技术产生出来的。</p>
<p>PHP:这门语言由于上手简单，同时国内有大量的程序员已经掌握好了这门语言。不得不提及的是 WordPress 已经占领了 CMS 市场超过一半的份额，并且它也占领了全球网站的四分之一。还有 Facebook，这个世界上最大的 PHP 站点也在使用这门语言。</p>
<p>其它:个人感觉 Go、Swift 也不错，性能应该是相当可以的</p>
</blockquote>
</li>
<li><p>MVC</p>
<blockquote>
<p>Model:模型用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法</p>
<p>View:View 层在 Web 应用中，一般是使用模板引擎装载对应 HTML,View 层只是单纯的一个显示作用，这也是我们推荐的做法。业务逻辑应该尽可能的放置于业务层。</p>
<p>Controller:控制器层起到不同层面间的组织作用，用于控制应用程序的流程</p>
</blockquote>
</li>
<li><p>MVP</p>
<blockquote>
<p>MVP 是从经典的模式 MVC 演变而来，它们的基本思想有相通的地方：Controller/Presenter 负责逻辑的处理，Model 提供数据，View 负责显示</p>
</blockquote>
</li>
<li>MVVM<blockquote>
<p>MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化</p>
</blockquote>
</li>
<li><p>后台即服务</p>
<blockquote>
<p>BaaS（Backend as a Service）是一种新型的云服务，旨在为移动和 Web 应用提供后端云服务，包括云端数据/文件存储、账户管理、消息推送、社交媒体整合等</p>
<p>产生这种服务的主要原因之一是因为移动应用的流行。在移动应用中，我们实际上只需要一个 API 接口来连接数据库，并作一些相应的业务逻辑处理。对于不同的应用产商来说，他们打造 API 的方式可能稍有不同，然而他们都只是将后台作为一个服务。</p>
<p>在一些更特殊的例子里，即有网页版和移动应用端，他们也开始使用同一个 API。前端作为一个单页面的应用，或者有后台渲染的应用</p>
<p>后台即服务的网站架构:</p>
</blockquote>
<pre><code>1.数据持久化
    数据通常以文件的形式存储，毕竟文件是存储信息的基本单位。只是由于业务本身对于 <span class="operator"><span class="keyword">Create</span>、<span class="keyword">Update</span>、<span class="keyword">Query</span>、<span class="keyword">Index</span> 等有不同的组合需求就引发了不同的数据存储软件。
    数据库。由于 Node.js 在最近几年里发展迅猛，越来越多的开发者选择使用 Node.js 作为后台语言。这与传统的 <span class="keyword">Model</span> 层并无多大不同，要么直接操作数据库，要么间接操作数据库。即使在 NoSQL 数据库中也是如此。
    搜索引擎。对于以查询为主的领域来说，搜索引擎是一个更好的选择，而搜索引擎又不好直接向 <span class="keyword">View</span> 层暴露接口。这和招聘信息一样，都在暴露公司的技术栈。
    RESTful。RESTful 相当于是 CRUD 的衍生，只是传输介质变了。
    LocalStorage。LocalStorage 算是另外一种方式的 CRUD。
    说了这么多都是废话，他们都是可以用类 CRUD 的方式操作。

<span class="number">2.</span>文件存储
    通常来说，以这种方式存储最常见的方式是 <span class="keyword">log</span>(日志)，如 Nginx 的 <span class="keyword">access</span>.<span class="keyword">log</span>。像这样的文件就需要一些专业的软件，如 GoAccess、又或者是 Hadoop、Spark 来做对应的事。

<span class="number">3.</span>数据库
    数据库，简单来说可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。
    在操作库的时候，我们会使用到一名为 <span class="keyword">SQL</span>（英语：Structural <span class="keyword">Query</span> <span class="keyword">Language</span>，中文： 结构化查询语言）的领域特定语言来对数据进行操作。
    <span class="keyword">SQL</span> 是高级的非过程化编程语言，它允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解其具体的数据存放方式。
    数据库里存储着大量的数据，在我们对系统建模的时候，也在决定系统的基础模型。

<span class="number">4.</span>ORM
    在传统 <span class="keyword">SQL</span> 数据库中，我们可能会依赖于 ORM，也可能会自己写 <span class="keyword">SQL</span>。在使用 ORM 框架时，我们需要先定义 <span class="keyword">Model</span>,像 MongoDB 这类的数据库，也存在数据模型，但说的却是嵌入子文档。在业务量大的情况下，数据库在考验公司的技术能力，想想便觉得 Amazon RDS 挺好的

<span class="number">5.</span>搜索引擎
    搜索引擎应该分成三个部分来组成：
    * 索引服务
    * 搜索服务
    * 索引数据
    索引服务用于将数据存储到索引数据中，而搜索服务正是搜索引擎存在的意义。对于查询条件复杂的网站来说，采用搜索引擎就意味着减少了非常多的繁琐数据处理事务。在一些架构中，人们用数据库存储数据，并使用工具来将数据注入到搜索引擎中。
    从架构上来说，使用搜索引擎的优点是：分离存储、查询部分。从开发上来说，它可以让我们更关注于业务本身的价值，而不是去实现这样一个搜索逻辑。</span>
</code></pre></li>
</ul>
<h6 id="我的前端框架选择">我的前端框架选择</h6><blockquote>
<p>选择前端框架似乎是一件很难的事，然而这件事情并不是看上去那么难。只是有时候你只想追随潮流，或者因为你在技术选型受到一些影响。但是总的来说，选择一个框架并不是一件很难的事。同时也不是一件非常重要的事，因为框架本身是相通的。如果我们不尽量去解耦系统，那么选择什么框架也都是一样的。</p>
</blockquote>
<ul>
<li><p>Angular</p>
<p>  AngularJS 对于后端人员写前端代码来说，是一个非常不错的选择。Angular 框架采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。<br>  并且类似于 Ionic 这样的混合框架，也将 Ionic 带到了移动应用的领域。</p>
</li>
<li><p>React</p>
<p>  React 似乎很受市场欢迎，各种各样的新知识——虚拟 DOM、JSX、Component 等等。React 只是我们在上面章节里说到的 View 层，而这个 View 层需要辅以其他框架才能完成更多的工作。<br>  并且 React 还有一个不错的杀手锏——React Native，虽然这个框架还在有条不紊地挖坑中，但是这真的是太爽了。以后我们只需要一次开发就可以多处运行了，再也没有比这更爽的事情发生了。</p>
</li>
<li><p>Vue</p>
<p>  Vue.js 是一个轻量级的前端框架。它是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。</p>
</li>
<li><p>jQuery 系</p>
<p>  jQuery 还是一个不错的选择，不仅仅对于学习来说，而且对于工作来说也是如此。如果你们不是新起一个项目或者重构旧的项目，那么必然你是没有多少机会去超越 DOM。而如果这时候尝试去这样做会付出一定的代价，如我在前端演进史所说的那样——晚点做出选择，可能会好一点。<br>  因为谁说 jQuery 不会去解放 DOM，React 带来的一些新的思想可能就比不上它的缺点。除此，jQuery 耕织几年的生态系统也是不可忽略。</p>
</li>
<li><p>Backbone + Zepto + Mustache</p>
<p>  这是前几年（今年2016）的一个技术方向，今天似乎已经不太常见了。在这种模式下，人们使用 Backbone 来做一些路由、模型、视图、集合方面的工作，而由 jQuery 的兼容者 Zepto 来负责对 DOM 的处理，而 Mustache 在这里则充当模板系统的工作。</p>
</li>
</ul>
<h6 id="我的前台与后台交互">我的前台与后台交互</h6><pre><code>在我们把后台服务化后，前端跨平台化之前，我们还需要了解前台和后台之间怎么通讯。从现有的一些技术上来看，Ajax 和 WebSocket 是比较受欢迎的
</code></pre><ul>
<li><p>Ajax</p>
<p>  说起 Ajax，我们就需要用 JavaScript 向服务器发送一个 HTTP 请求。这个过程要从 XMLHttpRequest 开始说起，它是一个 JavaScript 对象。它最初由微软设计，随后被 Mozilla、Apple 和 Google 采纳。如今，该对象已经被 W3C 组织标准化</p>
<p>  我们只需要简单的创建一个请求对象实例，打开一个 URL，然后发送这个请求。当传输完毕后，结果的 HTTP 状态以及返回的响应内容也可以从请求对象中获取。</p>
<p>  而这个返回的内容可以是多种格式，如 XML 和 JSON，但是从近年的趋势来看，XML 基本上已经很少看到了。这里我们以 JSON 为主，来简单地介绍一下返回数据的解析。</p>
</li>
<li><p>JSON</p>
<p>  JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 ECMAScript 的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括 C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p>
</li>
<li><p>JSON WEB Tokens</p>
<p>  JSON Web Token (JWT) 是一种基于 token 的认证方案</p>
<p>  通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。当我们使用 JWT 来实现我们的注册、登陆功能时，我们在登陆的时候将向服务器发送用户名和密码，服务器验证后将生成对应的 Token。在下次我们进行页面操作的时候，如访问 /Dashboard 时，发出的 HTTP 请求的 Header 中会包含这个 Token。服务器在接收到请求后，将对这个 Token 进行验证并判断这个 Token 是否已经过期了。</p>
</li>
<li><p>WebSocket</p>
<p>  WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据</p>
</li>
</ul>
<h6 id="我的编码">我的编码</h6><pre><code>在我们真正开始去写代码之前，我们可能会去考虑一些事情：
<span class="number">1.</span> 如果一件事可以自动化，那么就尽量去自动化，毕竟你是一个程序员。
<span class="number">2.</span> 快捷键！快捷键！快捷键！
<span class="number">3.</span> 使用可以帮助你快速工作的工具——如启动器。

编码过程：
<span class="number">1.</span> Kick Off。在这个步骤中，我们要详细地了解我们所需要做的东西、我们的验收条件是什么、我们需要做哪些事情。
<span class="number">2.</span> Tasking。简单的规则一下，我们需要怎么做。一般来说，如果是结对编程的话，还会记录下来。
<span class="number">3.</span> 最新的代码。对于使用 Git 来管理项目的团队来说，在一个任务刚开始的时候应该保证本地的代码是最新的。
<span class="number">4.</span> Test First。测试优先是一个很不错的实践，可以保证我们写的代码的健壮，并且函数尽可能小，当然也会有测试。
<span class="number">5.</span> Code。就是实现功能，一般人都知道。
<span class="number">6.</span> 重构。在我们实现了上面两步之后，我们还需要重构代码，使我们的代码更容易阅读、更易懂等等。
<span class="number">7.</span> 提交代码。这里的提交代码只是本地的提交代码，因此都提倡在本地多次提交代码。
<span class="number">8.</span> 运行测试。当我们完成我们的任务后，我们就可以准备 PUSH 代码了。在这时，我们需要在本地运行测试——以保证我们不破坏别人的功能。
<span class="number">9.</span> PUSH 代码。
<span class="number">10.</span> 等 CI 测试通过。如果这时候 CI 是挂的话，那么我们就需要再修 CI。这时其他的人就没有理由 PUSH 代码，如果他们的代码也是有问题的，这只会使情况变得愈加复杂。
</code></pre><p>Web 应用的构建系统<br><a href="http://yolynn.com/2016/08/17/web_start/">详细见这里</a></p>
<h6 id="我的Git_与版本控制">我的Git 与版本控制</h6><blockquote>
<p><a href="http://yolynn.com/2016/07/17/my_git/">详细见这里</a></p>
</blockquote>
<h6 id="我的Tasking">我的Tasking</h6><blockquote>
<p><a href="http://yolynn.com/2016/06/17/my_tasking/">详细见这里</a></p>
</blockquote>
<h6 id="我的全栈之路感受">我的全栈之路感受</h6><ul>
<li><p>写代码只是在码字</p>
<p>  编程这件事情实际上一点儿也不难，当我们只是在使用一个工具创造一些东西的时候，比如我们拿着电烙铁、芯片、电线等去焊一个电路板的时候，我们学的是如何运用这些工具。虽然最后我们的电路板可以实现相同的功能，但是我们可以一眼看到差距所在。</p>
<p>  换个贴切一点的比喻，比如烧菜做饭，对于一个优秀的厨师和一个像我这样的门外汉而言，就算给我们相同的食材、厨具，一段时间后也许一份是诱人的美食，一份只能喂猪了——即使我模仿着厨师的步骤一步步地来，也许看上去会差不多，但是一吃便吃出差距了。</p>
<p>  我们还做不好饭，还焊不好电路，还写不好代码，很大程度上并不是因为我们比别人笨，而只是别人比我们做了更多。有时候一种机缘巧遇的学习或者 bug 的出现，对于不同的人的编程人生都会有不一样的影响(ps:说的好像是蝴蝶效应)。我们只是在使用工具，使用的好与坏，在某种程序上决定了我们写出来的质量。</p>
<p>  写字便是如此，给我们同样的纸和笔(ps:减少无关因素)，不同的人写出来的字的差距很大，写得好的相比于写得不好的 ，只是因为练习得更多。而编程难道不也是如此么，最后写代码这件事就和写字一样简单了。</p>
<p>  刚开始写字的时候，我们需要去了解一个字的笔划顺序、字体结构，而这些因素相当于语法及其结构。熟悉了之后，写代码也和写字一样是简简单单的事。</p>
</li>
<li><p>学习编程只是在学造句</p>
<p>  多么无聊的一个标题<br>  计算机语言同人类语言一样，有时候我们也许会感慨一些计算机语言是多么地背离我们的世界，但是他们才是真正的计算机语言。</p>
<p>  计算机语言是模仿人类的语言，从 if 到其他，而这些计算机语言又比人类语言简单。故而一开始学习语言的时候我们只是在学习造句，用一句话来概括一句代码的意思，或者可以称之为函数、方法(method)。</p>
<p>  于是我们开始组词造句，以便最后能拼凑出一整篇文章。</p>
</li>
<li><p>编程是在写作</p>
<p>   编程是在写作，这是一个怎样的玩笑?这是在讽刺那些写不好代码，又写不好文章的么<br>  代码如诗，又或者代码如散文。总的来说，这是相对于英语而言，对于中文而言可不是如此。如果用一种所谓的中文语言写出来的代码，不能像中文诗一样，那么它就算不上是一种真正的中文语言。</p>
<p>  那些所谓的写作逻辑对编程的影响</p>
<p>  早期的代码是以行数算的，文章是以字数算的</p>
<p>  代码是写给人看的，文章也是写给人看的</p>
<p>  编程同写作一样，都由想法开始</p>
<p>  代码同文章一样都可以堆砌出来(ps:如本文)</p>
<p>  写出好的文章不容易，需要反复琢磨，写出好的代码不也是如此么</p>
<p>  构造一个类，好比是构造一个人物的性格特点，多一点不行，少一点又不全<br>  代码生成，和生成诗一样，没有情感，过于机械化<br>  。。。</p>
<p>  然而好的作家和一般的写作者，区别总是很大，对同一个问题的思考程度也是不同的。从一个作者到一个作家的过程，是一个不断写作不断积累的过程。而从一个普通的程序员到一个优秀的程序员也是如此，需要一个不断编程的过程。</p>
<p>  当我们开始真正去编程的时候，我们还会纠结于“僧推月下门”还是“僧敲月下门”的时候，当我们越来越熟练就容易决定究竟用哪一个。而这样的“推敲”，无论在写作中还是在编程中都是相似的过程。</p>
<p>  写作的过程真的就是一次探索之旅，而且它会贯穿人的一生。<br>  因此：</p>
<p>  编程只是在码字，难道不是么？</p>
<p>  真正的想法都在脑子里，而不在纸上，或者 IDE 里。</p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/17/my_fullstack/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/14/cocos2d_year/">
                            那一年，和cocos2dx擦肩而过
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-14T18:15:02+08:00">
	
		    Oct 14, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="background">background</h2><blockquote>
<p>那年疯狂迷醉于cocos2dx时的情景跃于纸上，时而想起这段经历觉得何其美好，曾经何其努力，目标何其明确，一心扑在一件事情上的力量何其强大，是的，那年在好奇心的驱使下疯狂的学起了游戏开发，一开始迷惘在学unity3D还是cocos2dx好，于是开始了尝试下载了unity3D软件，但是没有找到很完善的unity3D教程，因此只是简单了解了下unity3D工具的用法，并没有完整的完成一个项目，倒是cocos2dx的教程较为齐全，随后还下载了粒子ParticleDesigner、瓦图tield、肤图TexturePacker工具都发现很有趣</p>
<p>到了今天，还是非常希望能拥有那时候的劲头，学习一门新技术，不管怎么说青春就一次，只是希望当你老了能够无怨无悔，年轻人不管做什么都要去试一试</p>
<p>无论如何，学过了就不能忘记，无论以后有没有机会施展，但是很有必要记录下自己的学习经验，以下从游戏的根本游戏引擎说起</p>
</blockquote>
<h6 id="游戏引擎">游戏引擎</h6><p>即游戏程序的核心组件，也叫主程序。玩家所体验到的游戏表现方式、关卡地图类型、美术效果、声音、操作性等内容都是由游戏的引擎直接控制的，它把游戏中的所有元素捆绑在一起，并在后台指挥它们同时、有序地工作。简单地说，引擎就是：用于控制所有游戏功能的主程序，包括程序运行主流程、地图驱动、图形驱动、声音驱动、物理引擎，交互和AI。</p>
<h6 id="游戏引擎框架">游戏引擎框架</h6><p>用于将游戏引擎中各部分的驱动协调起来，并体现在游戏主程序的运行流程中，同时在其内部处理了游戏程序必备的，但各游戏程序基本相同的操作（如初始化、资源释放等），减少了游戏程序人员做“体力”劳动的工作量，把精力放在游戏设计本身和对象行为驱动上，程序员只要设计游戏中具体对象的驱动和其之间的联系即可。</p>
<h6 id="设计思想">设计思想</h6><ol>
<li><p>游戏引擎提供的功能</p>
<p>目前主流的游戏引擎提供如下功能可以概括如下： 学习一个游戏引擎，一般也是从下面这几点出发.</p>
</li>
</ol>
<ul>
<li><p>地图编辑器： 一个好的游戏引擎需要搭配一个好的地图编辑器。unity3d和 cocos2d都把地图编辑器集成到了游戏引擎里面（虽然cocos2d并没有做得特别好，不过由于它的可扩展性，）.</p>
</li>
<li><p>渲染系统： 相对于开发人员，玩家更注重的游戏的画面，那么渲染系统重要性就体现出来了。渲染的流畅和出色的画面，一直是玩家衡量一个游戏引擎的标准。当然考虑到硬件设施和成本，PC和手机端目前还不是一个档次。为了抢夺游戏市场，一些牛B的游戏引擎厂商也纷纷把矛头都转向了手机游戏，例如Unreal.</p>
</li>
<li><p>资源管理和打包机制：在这个网络发达的年达，游戏的升级更新是必须的，所以打包策略和方案显得尤为重要。Unity资源打包有Assetbundle，cocos2d可以采用zpack,zip等，cocos2d本身并没有打包的策略，资源容易被获取到，不方便加密。</p>
</li>
<li><p>内存管理：自动申请和回收机制，模板式的代码能减少程序员编写代码的负担，减少开发过程中的BUG。同时也降低编码的难度。 那Cocos2d-x作为例子，Cocos2d-x中所有对象几乎都继承自Ref基类，Ref唯一的职责就是对对象进行引用计数管理：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CC_DLL Ref</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Ref* <span class="title">autorelease</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getReferenceCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    Ref();</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/// count of references</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _referenceCount;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> AutoreleasePool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当一个对象被使用new运算符分配内存时，其引用计数为1，调用retain()方法会增加其引用计数，调用release()则会减少其引用计数，release()方法会在其&gt;引用计数为0时自动调用delete运算符删除对象并释放内存。</p>
<p>例如cocos2dx里面的对象通用的创建代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CREATE_FUNC(__TYPE__)</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">TYPE__* <span class="title">create</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    __TYPE__ *pRet = <span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) __TYPE__();</span><br><span class="line"><span class="keyword">if</span> (pRet &amp;&amp; pRet-&gt;init())</span><br><span class="line">&#123;</span><br><span class="line">    pRet-&gt;autorelease();</span><br><span class="line">    <span class="keyword">return</span> pRet;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> pRet;</span><br><span class="line">    pRet = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户只需要调用 XX::create() 函数之后，就可以不用去管内存的回收了，很方便。 引擎的目的，就是为了方便开发。</p>
<ul>
<li><p>交互设计：将用户的输入操作进行处理和封装，开发人员 只需要使用相关接口就能够知道 物理引擎：unity3d内置了NVIDIA的Physx物理引擎而cocos2dx也基于box2d的物理引擎进行了封装。对于物理世界的定义和驱动，仿真就是来自这些系统。 开发人员只需要往你的场景和对象添加物理属性，就可以使用。</p>
</li>
<li><p>场景驱动：根据需求游戏引擎提供场景的创建，开发人员进行逻辑的驱动，是开发游戏常用的一种模式。</p>
</li>
<li><p>对象驱动：精灵是游戏开发里面一个基本概念，无论自己设计的引擎，或者例如cocos2dx 里面的Sprite，unity3d里面的GameObject。所有的事情都需要通过这个概念发生关系.</p>
</li>
</ul>
<ul>
<li><p>坐标系 ： 在图形图像和游戏应用开发中坐标系是非常重要的，我们在Android和iOS等平台应用开发的时候使用的二维坐标系它的原点是在左上角的。而在Cocos2d-x坐标系中它原点是在左下角的，而且Cocos2d-x坐标系又可以分为：世界坐标和模型坐标。unity3d坐标系包含了世界坐标，屏幕坐标，视口坐标，绘制GUI界面的坐标系。关键是弄清楚各种坐标系之间的关系和如何进行转换。</p>
</li>
<li><p>消息驱动：消息循环、消息预处理、消息处理，消息回调用于在游戏运行的整个过程中不断检测是否有因玩家的操作而触发的消息，并将消息分发到游戏框架的消息处理程序中，供程序设计人员编写消息处理驱动。</p>
</li>
<li><p>定时器驱动：是游戏正常运行时的主驱动，提供了游戏运行的各个阶段的各种可能的操作，是游戏运行的核心模块，也是开发人员核心编写逻辑驱动的地方。典型的，其中在游戏的正常处理状态中，需要按键处理驱动，用来处理用户的输入操作，如按下按键，这些操作将会产生什么影响，就需要各游戏的程序设计人员编写代码。然后处理对象驱动，包括用户控制的角色对象、电脑控制的角色对象，或其它随机的对象，主要驱动这些对象的位置、状态、行为等逻辑方面的内容。在处理对象的驱动过程中，对象有可能会相互碰撞，故需要碰撞检测模块参与碰撞检测，并将检测结果反馈给游戏程序，共游戏程序进一步处理。最后一步就是显示，包括显示游戏背景、显示各种游戏对象及游戏UI。</p>
</li>
<li><p>声音和视频驱动：初始化及关闭等功能，为游戏中播放游戏背景音乐、音效初始化和关闭声音设备。</p>
</li>
<li><p>动作 Aciton : 游戏过程中包含了各种各样的action。让对象做各种事情就靠它了。</p>
</li>
</ul>
<ol>
<li><p>工具的使用</p>
<p> 工欲善其事必先利其器，强大的游戏引擎,强大的的并不仅仅是引擎本身，而是各种各样的工具，使用好各种工具，会让你开发效率大大提高。例如你想学习好cocos2dx, 除了 本身的引擎，你更加需要的是cocos studio, TexturePacker，各种类型的地图编辑器等等，有能力的还可以自己开发工具。</p>
</li>
</ol>
<ul>
<li><p>脚本系统</p>
<p>  cocos2d 有lua脚本系统，unity3d 的脚本系统可称之为游戏运行核心，所有的设计本身都可以围绕脚本展开，包括AI设计。自定义脚本系统也可以，甚至可以使用txt文本或者excel这些比较常见的格式。</p>
</li>
</ul>
<ul>
<li><p>关于选择引擎</p>
<p>  “我现在有个项目应该用unity还是cocos2d”这个是一个长期需要考虑和讨论的问题，就好像你高考填志愿是选“清华”还是“蓝翔”，不是简单的一个“开发2D游戏用cocos2d,开发3D游戏用unity”的能够回答的问题。但是作为目前开发手游所采用最为普遍的两种技术方案，是具有可比性的。</p>
</li>
</ul>
<blockquote>
<p>总结 </p>
</blockquote>
<p>  无论是自己开发的游戏引擎进行开发，或者现在流行的cocos2d引擎和unity3d引擎,这些心得是整合引擎编写经验和后面学习的经验进行论述，欢迎提出批评和指正。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/14/cocos2d_year/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/10/five_year_OS/">
                            工作5年了，为什么还要看操作系统？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-10T18:15:02+08:00">
	
		    Oct 10, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="background">background</h2><blockquote>
<p>一眨眼，工作已经5个年头，5年说长不长，但多少为企业级系统繁荣搬了点砖，也见证了塞班的枯竭，同时被移动互联网浪潮推到风口浪尖，自我危机意识被拉到最高点，于是每天疯狂的学习新技术，一点也不敢懈怠，比如多编程语言的学习、多编译器的探究，还有每年看过的技术书籍，之前都有文章来总结。</p>
<p>学过来学过去，有一点总达不到自己的预期，学之前想的是学了就能用，可往往事与愿违，学过不就之后就能忘记，之后想要用的时候，又得掏出之前的笔记，我想这中间的学习是不是少了什么环节？</p>
<p>最近，突发奇想的我做了个试验来验证自己的想法，那就是从零开始，从最基础做起，于是我开始阅读一本《深入理解计算机系统》，虽然翻来覆去还是那些熟悉的字眼，但是接二连三的读，发现每一遍都有不一样的感受，而且当你真的能和自己常用的编程语言联系起来的时候，妙不可言。</p>
<p>那么，以下我来说说看它的意义好吗？</p>
</blockquote>
<ul>
<li><p>并发</p>
<p>编写并发代码并不容易，特别是使用线程共享内存和线程锁。然而，现在很多学习计算机科学的学生都会在他们以后的职业生涯的某些时候使用到（并发）。在OS课程以外的课程里学习并发问题已经成为了一种增长的趋势，但即便如此，操作系统是学生首次了解线程，竞争，死锁等等重要概念的传统课程。教材很难（实际上很简单的，但运用起来很难），在毕业前多看几次是很有帮助的。一个可靠的并发编程介绍对学习操作系统课程是有很大好处的。</p>
</li>
<li><p>资源管理</p>
<p>硬件层次上的资源通常是专用的。操作系统提供了这些资源的种类，它们可以是虚拟的（每个用户都有种错觉，自己拥有资源的一份备份）或者是仲裁的（一次只能有一个用户占有资源，但由操作系统来安排访问顺序）。允许多用户访问专用物理资源是一个很基本的策略并被运用到很多用户级别的程序中。通过详细地学习这些内容，学生学会了能够在许多其他场合重用的模式。</p>
</li>
<li><p>性能分析和冲突解决</p>
<p>正如“为什么#*$是我的机器分页?”。当资源被分享时，冲突通常也会随之而来。冲突问题可以使用多种方式来解决，比如使用队列，合理共享，或者使用优先级。在某些情况下，比如CPU调度，没有单一技术解决方案并且最后的解决方案是一些古怪的混合技术。有时，最令人感兴趣的是找出导致问题出现的主要原因是哪一类冲突。我花费了夏天的一大部分时间去找出所有Windows NT导致MP3跳过的原因。操作系统课是学习这些理论的完美课程，它的适用性比计算机科学更广泛。</p>
</li>
<li><p>隐藏复杂性的接口</p>
<p>一个具有良好设计的接口是一个美妙的东西。它更美妙的地方体现在把一个讨厌的低层次接口（调制解调器或者NE2000卡）转换为一个实用高效的高层次抽象接口（套接字流）。学生应该已经在教材里关于抽象数据类型那部分接触过这些想法了，给定的例子一般都是比较普通的，并且抽象化和隐藏复杂性的作用在那个层次里不够明显。我认为把像套接字（socket），文件系统和地址空间这些集合合到一个单一便利的包里可能是计算机科学10大贡献之一了。这是司空见惯的事，以至于很容易让人忽视它的迷人之处。</p>
</li>
<li><p>没什么神奇的</p>
<p>从用户模式（user mode）看，很容易发现OS是一个神奇的东西–它提供了流畅的多任务处理，高效擦储存管理等。–不好的–它会出现蓝屏，系统颠簸，安全问题和调度异常。对于一般用户来说，这个模式是好的。但在另一方面，如果你想去证明你是一个计算机科学家，你需要知道这些问题的幕后细节。你将会从那里发现什么？很多时候，这看起来都是一些令人忧愁的集合，比如单调的链表，狡猾的启发式资源和维护不当的设备驱动程序。好的OS课程应该教会学生这些：</p>
<p>在内核的代码很优秀，你只需要知道到哪里找到它们。当你第一次看到它们时，你不一定会理解它们。但你理解了它们，你就会学得更多。<br>通常，内核代码都是很普通的代码。任何人都可以编写它，对比于用户模式代码（user-mode code），内核代码（kernel code）仅需要多一点对细节的关心和注意，因为内核代码中的bug造成的结果更严重。<br>处理大型软件</p>
<p>这是毫无疑问的，陷入别人的几百万行代码库中去是一个噩梦。错误零散的文档，残旧和广泛的接口，糟糕的交互，和费解的错误信息。不过，欢迎回到现实世界，我们不能因为这些糟糕的问题就经常重新开始。作为一个学生，如果你能够开始制定一个系统的方法去学习你需要用代码修复的大软件的相关部分，那么你以后的生活就会轻松很多。你可以讨厌Linux内核但它比你以后的职业生涯会遇到的软件好多了。</p>
</li>
<li><p>计算机系统设计</p>
<p>设计任何的工程系统，包括软件系统，都是一个权衡的过程。是要侧重于可靠性？性能？消耗还是维护性?因为操作系统是很庞大的，性能至关重要的程序，它一般都要维护几十年，所以它们是学生学习这类权衡的很好的地方。拥有一双发现合适设计点的锐利眼睛的学生在工业上是很需要的。这些人更像一个艺术家而不是一个科学家，你需要看大量的代码，理解这些问题，和学会自己独立考虑这些问题。</p>
</li>
<li><p>总结</p>
<p>我已经尝试去说清楚，一门OS课程不仅仅是关于操作系统和给UNIX/Windows/MacOS的使用者提供知识。优秀的OS课程教会你对广泛使用的操作系统的思考技巧和方式，即使你从没接触过一行的内核代码。实际上，在我的大学里获取学位的CS学生不要求一定要上OS课程，但我觉得，所有真正的计算机科学家要么是已经学这么课，要么已经用其他方式学会了这方面的技巧和直接   </p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/10/five_year_OS/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/09/22/reactnative/">
                            ReactNative基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-09-22T18:15:02+08:00">
	
		    Sep 22, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习ReactNative需要会什么？">学习ReactNative需要会什么？</h2><p>从名字可知它就是以React和Native的结合，所以在学习ReactNative之前，最好学习React相关知识，可以参见<a href="http://yolynn.com/2016/09/02/react/">React基础到进阶</a>，这是关于React的，那么还有Native端的知识自然也是少不了需要了解的，比如iOS端的js引擎JavaScriptCore和Android端js引擎V8，当然你还需要了解iOS的开发的工作流及方式。</p>
<h2 id="ReactNative是什么？">ReactNative是什么？</h2><h4 id="工作流">工作流</h4><p><img src="https://www.processon.com/chart_image/585147f6e4b0c74cb9fb28c5.png" alt=""></p>
<h4 id="通信机制">通信机制</h4><h6 id="模块配置表">模块配置表</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "remoteModuleConfig": &#123;</span><br><span class="line">        "RCTSQLManager": &#123;</span><br><span class="line">            "methods": &#123;</span><br><span class="line">                "query": &#123;</span><br><span class="line">                    "type": "remote",</span><br><span class="line">                    "methodID": 0</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "moduleID": 4</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OC会生成一份模块配置表传给JS，配置表里包括了模块以及模块暴露的方法</p>
<h6 id="取所有的模块类">取所有的模块类</h6><p>每个模块都实现RCTBridgeModule接口，可以通过runtime接口的objc_getClassList和objc_copyClassList取出项目里所有的类，判断是否实现了RCTBridgeModule接口，就可以找到所有的模块类，实现在RCTBridgeModuleClassesByModuleID()方法里。</p>
<h6 id="取模块里暴露给JS的方法">取模块里暴露给JS的方法</h6><p>怎么做到部分暴露，部分不暴露呢？常见的思路是给需要暴露的函数添加统一的前缀，然后用runtime方法class_getInstanceMethod取出所有方法名字，提取统一前缀的方法，这样做是否有点太累赘，需要每个函数添加统一的前缀。ReactNative用了另外一种黑魔法解决这个问题：编译属性 <strong> attribute </strong>。</p>
<p>对于宏RCT_EXPORT()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RCT_EXPORT(JS_name) __attribute__((used, section(&#34;__DATA,RCTExport&#34; \&#10;))) static const char *__rct_export_entry__[] = &#123; __func__, #JS_name &#125;</span><br></pre></td></tr></table></figure>
<p>这个宏的作用是用编译属性 <strong> attribute</strong> 给二进制文件新建一个section，属于 <strong>DATA数据段，名字为RCTExport，并在这个段里加入当前方法名。编译器在编译时会找到 </strong> <strong>attribute</strong> __ 进行处理，为生成的可执行文件加入相应的内容。</p>
<p>整体的模块类/方法提取实现在RCTRemoteModulesConfig()方法里</p>
<h2 id="为什么用ReactNative?">为什么用ReactNative?</h2><h4 id="ReactNative带来了什么？">ReactNative带来了什么？</h4><p>ReactNative为移动开发带来了新思路，learn once, write anywhere</p>
<h2 id="怎么用ReactNative?">怎么用ReactNative?</h2><p>Facebook为ReactNative提供了强大的官方文档和社区，当然在github上也很轻松就能找到各种问题的解决方式</p>
<h2 id="ReactNative的实际应用">ReactNative的实际应用</h2><ol>
<li>XX会，X蜂中有实际运用到ReactNative开发档期活动页，但是ReactNative诟病的listView性能问题还不是很好的能够解决，因此一般用的时候为了规避风险应该采用降级策略。</li>
<li>携程火车票业务，在页面变化频繁的简单页面或者稍复杂页应用</li>
<li>详细分析还可以参见<a href="http://yolynn.com/2016/11/11/RN&amp;Weex/">如何一网打尽React、Redux、ReactNative、Vue、Weex、微信小程序？</a></li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/09/22/reactnative/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/09/02/react/">
                            React基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-09-02T18:15:02+08:00">
	
		    Sep 02, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习React需要会什么？">学习React需要会什么？</h2><p>React的功能很单一，主要负责渲染的功能，跟angular还不一样，ng大而全，React专一，因此在React开发中还需要结合其它工具，比如Redux管理数据，React-router管理路由，按需加载immutable.js，ES6, Webpack等，初次之外最基本的的条件是要学习JSX语法，其实对于有JS基础的同学也难度不大。</p>
<h2 id="React是什么">React是什么</h2><h4 id="工作流">工作流</h4><p>JS操作DOM的代价是非常昂贵的，访问频次越高，消耗的内存的越大，用户体验越差，React并没有直接让脚本操作DOM，而是引入了Visual DOM，当状态发生变化时，创建新的Visual DOM与旧的Visual DOM比较异同(Diff算法)，只让变化的部分进行渲染，所以整个过程省去了DOM的获取和操作，而仅仅只有渲染过程。</p>
<h4 id="Diff算法">Diff算法</h4><p><img src="https://www.processon.com/chart_image/584fa0eee4b05021858eac2c.png" alt=""><br>React提出了一种假设，相同的结点具有类似的结构，而不同的结点具有不同的结构。在这种假设基础上进行<strong>逐层</strong>比较，如果发现结点不同，则删除旧结点及其包含的子节点；如果结点相同，则进行属性修改。</p>
<h4 id="组件化">组件化</h4><p>React的组件由DOM和state数据组成，两者泾渭分明，state决定着视图的状态。React通过setState控制视图的更新，setState会自动调用render函数，触发视图重新渲染，如果只是state数据变化没有调用setState并不会触发更新。</p>
<h4 id="组件的创建">组件的创建</h4><ol>
<li>React.createClass()</li>
<li>class Main extends React.Component </li>
</ol>
<h4 id="组件生命周期">组件生命周期</h4><p><img src="https://www.processon.com/chart_image/584fa55fe4b05021858f5add.png" alt=""></p>
<h4 id="组件之间的通信">组件之间的通信</h4><p>React推崇单向数据流，自上而下进行数据的传递</p>
<ol>
<li>如果是父子级关系，父级将一个回调函数当做属性传递给子级，子级直接调用函数和父级通信。</li>
<li>组件层级嵌套深，可使用上下文getChildContext传递信息，这样不需要将函数一层层往下传，任何一层子级可以通过this.context直接访问</li>
<li>兄弟关系得组件无法通信，只能利用同一层的上级作为中转站，如果兄弟组件都是最高层组件，必须在他们外层再套一层组件，用来保存数据、传递信息，这其实就是Redux所做的事情。</li>
<li>组件之间的信息还可以通过全局事件传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取</li>
</ol>
<h2 id="为什么用React?">为什么用React?</h2><p>在拥有Visual DOM提高性能的基础上，组件是拥有独立功能的视图模块，许多小的组件能组成一个大的组件，整个页面就是由一个个组件组合而成，它的好处是利于重用和维护。</p>
<h2 id="怎么用React?">怎么用React?</h2><h4 id="React-Router">React-Router</h4><p>Router也是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展示相应的组件。</p>
<ol>
<li>Router对路由地址和组件进行了绑定，具有嵌套功能表示路由地址的包含关系。</li>
<li>Router可以向组件传递7个属性：children, history, location, params, route, routeParams, routes，每个属性都包含路由的相关信息。</li>
<li>Router提供Link标签，这只是对a标签的封装，点击链接跳转并不是默认的方式，Router阻止了a标签的默认行为并用pushState进行hash值的转变，切换页面的过程中会先发生url地址的转变，Router监听到地址的改变根据Router的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render重新渲染DOM</li>
<li>页面较多时，项目越来越大，初次渲染的速度就会很慢，这时候需要按需加载，只有切换到对应页面时才加载对应的js文件，React配合webpack进行按需加载方法简单，Route的component改为getComponent，组件用require.ensure方式获取，并在webpack中配置chunkFilename.</li>
</ol>
<h4 id="Redux">Redux</h4><h6 id="为什么要用Redux?">为什么要用Redux?</h6><p>Redux并非必须的，它的作用是在顶层组件上面加上一个组件，用来进行逻辑运算，存储数据，实现组件尤其是顶层组件之间的通信。如果组件之间通信不多，逻辑不复杂，这个时候用回调函数，context就行，没必要引入Redux。</p>
<h6 id="工作流-1">工作流</h6><p><img src="https://www.processon.com/chart_image/584fa95ce4b0160bc4dde483.png" alt=""></p>
<h2 id="React的实际应用">React的实际应用</h2><p>React的影响力让其已经成为一种开发方式，基于React的组件思想，衍生出了譬如ReactNative、Vue、Weex</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/09/02/react/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/08/22/css/">
                            CSS基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-08-22T18:15:02+08:00">
	
		    Aug 22, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习CSS需要会什么？">学习CSS需要会什么？</h2><p>DSL作为领域特定语言，其基本思想“求专不求全”，不像通用目的语言那样覆盖目标范围涵盖一切软件问题，而是针对某一特定问题的计算机语言，其实自计算机被发明起，人们就是开始使用DSL了，常用的DSL你还需要了解它们的用途：</p>
<ol>
<li>SQL 关系型数据库，用于查询和变更数据</li>
<li>CSS 样式表描述语言</li>
<li>HTML web标记型语言</li>
<li>Ant、Rake、Make 用于软件系统构建的语言</li>
<li>YACC、Bison、ANTLR 用来生成语法分析器的语言</li>
<li>RSpec、Cucumber Ruby环境下的行为驱动测试语言</li>
</ol>
<p>DSL是用“有限表达力”来描述DSL最重要的特征，DSL也只能给一个专门领域建模，但是表现力更强。</p>
<h2 id="CSS是什么？">CSS是什么？</h2><p>CSS全称是“层叠样式表 Cascading Style Sheets”，它主要用于定义HTML内容在浏览器内的显示内容，比如文字、颜色、字体等</p>
<h4 id="工作流">工作流</h4><p><img src="https://www.processon.com/chart_image/5853930ee4b097c6e69d2487.png" alt=""></p>
<ul>
<li>选择符：选择器，用来指明网页中要应用样式规则的元素</li>
<li>声明：“{}”  属性 和 值用 “：”分隔</li>
<li>CSS样式：内联、嵌入、外部三种</li>
</ul>
<h2 id="为什么要用CSS?">为什么要用CSS?</h2><h4 id="CSS3">CSS3</h4><p>CSS3带来了更多的新特性，使其更好用、更强大：</p>
<ul>
<li>圆角-半径（border-radius:8px）</li>
<li>阴影（box-shadow:10px）</li>
<li>文字特效（text-shadow、）</li>
<li>线性渐变（gradient）</li>
<li>旋转（transform）</li>
<li>transform:rotate(9deg) scale(0.85,0.90) </li>
<li>translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li>
<li>增加了更多的CSS选择器</li>
<li>多背景 rgba</li>
</ul>
<h4 id="Bootstrap">Bootstrap</h4><p>github上不乏有各种类似Bootstrap提供了强大CSS功能的现成的好用的库</p>
<p>举个🌰:<br><a href="http://www.jianshu.com/p/31118d83cb5f" target="_blank" rel="external">10个值得前端收藏的CSS3动效库（工具）</a></p>
<h4 id="SASS_&amp;_LESS">SASS &amp; LESS</h4><p>CSS预处理技术，为CSS（DSL）增加了编程特性</p>
<h2 id="CSS怎么用？">CSS怎么用？</h2><h4 id="元素类型">元素类型</h4><ul>
<li>块级元素（block）: div h1 hr p table ul form</li>
<li>行内元素（inline）: span a img span br </li>
<li>可变元素（inline-block）: 既在行内显示，又能设置宽高</li>
</ul>
<h4 id="盒模型">盒模型</h4><p>页面上的每个元素（包括内联元素）都可以看成一个盒子。<br><img src="http://myblogimage.qiniudn.com/illustration%5Cthree_core_concepts_of_cssD65A4E60-A213-481C-86D6-A3929A0A8D28.png" alt=""><br>显而易见，盒模型有四部分组成：</p>
<p><strong>content -&gt; padding -&gt; border -&gt; margin</strong></p>
<p>所以一个元素的宽度</p>
<ol>
<li>content + 2 <em> padding + 2 </em> border + 2 * margin</li>
<li>IE9以下： content + 2 * margin</li>
</ol>
<p>W3C为了解决差异，在CSS3中加了box-sizing属性，当设置了box-sizing:border-box;时，就和IE的标准一致。一般加上这个：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*, *<span class="pseudo">:before</span>, *<span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">-moz-box-sizing</span>:<span class="value"> border-box</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-box-sizing</span>:<span class="value"> border-box</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="position">position</h4><p>定位有五种：<a href="http://www.w3school.com.cn/cssref/pr_class_position.asp" target="_blank" rel="external">参考实例</a></p>
<ol>
<li>static </li>
<li>relative</li>
<li>absolute</li>
<li>fixed</li>
<li>inherit</li>
</ol>
<p>注意：位置在absolute和fixed时，会发生三件事：</p>
<ol>
<li>元素往Z轴方向上移一层，会覆盖下层元素</li>
<li>元素变为块级元素，可以设置宽高</li>
<li>如果本身是块级元素，元素宽度则由100%变为auto</li>
</ol>
<h4 id="float">float</h4><p>元素浮动四个属性：</p>
<ol>
<li>left</li>
<li>right</li>
<li>none</li>
<li>inherit</li>
</ol>
<p>前辈经验分享：</p>
<ul>
<li><a href="http://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html" target="_blank" rel="external">经验分享：CSS浮动(float,clear)通俗讲解</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/" target="_blank" rel="external">CSS float浮动的深入研究、详解及拓展(一)</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%BA%8C/" target="_blank" rel="external">CSS float浮动的深入研究、详解及拓展(二)</a></li>
<li><a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="external">那些年我们一起清除过的浮动</a></li>
</ul>
<p>注意：</p>
<ol>
<li>只有左右浮动，没有上下浮动</li>
<li>元素设置float后，会往Z轴上移一层（与position:absolute一致)</li>
<li>浮动不会影响上一个兄弟元素</li>
<li>浮动后，下一个兄弟元素会紧贴到该元素之前没有设置float的元素之后（就是下一个元素会补位）</li>
<li>下一个兄弟元素有内联元素，则会绕该元素显示，类似文字环绕图片效果</li>
<li>该元素变为块级元素，相当于设置了display:block;</li>
</ol>
<h2 id="CSS的实际应用">CSS的实际应用</h2><h4 id="Bootstrap-1">Bootstrap</h4><ul>
<li>预处理脚本 SASS LESS</li>
<li>一个框架 多钟设备</li>
<li>特性齐全</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/08/22/css/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/08/17/web_start/">
                            Web 应用的构建过程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-08-17T18:15:02+08:00">
	
		    Aug 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="Web_应用的构建过程">Web 应用的构建过程</h6><p>在刚创建项目的时候，我们都会有一个完整的构建思路。</p>
<ul>
<li><p>Compile。对于那些不是用浏览器的前端项目来说，如 ES6、CoffeeScript，他们还需要将代码编译成浏览器使用的 JavaScript 版本。对于 Java 语言来说，他需要一个编译的过程，在这个编译的过程中，会检查一些语法问题。</p>
</li>
<li><p>Check Style。通常我们会在我们的项目里定义一些代码规范，如 JavaScript 中的使用两个空格的缩进，Java 的 Checkstyle 中一个函数不能超过30行的限制。</p>
</li>
<li><p>单元测试。作为测试中最基础也是最快的测试，这个测试将集中于测试单个函数的是不是正确的。</p>
</li>
<li><p>功能测试。功能测试的意义在于，保证一个功能依赖的几个函数组合在一起也是可以工作的。</p>
</li>
<li><p>Mock Server。当我们的代码依赖于第三方服务的时候，我们就需要一个 Mock Server 来保证我们的功能代码可以独立地测试。</p>
</li>
<li><p>集成测试。这一步将集成前台、后台，并且运行起最后将上线的应用。接着依据于用户所需要的功能来编写相应的测试，来保证一个个的功能是可以工作的。</p>
</li>
<li><p>打包。对于部署来说，直接安装一个 RPM 包，或者 DEB 包是最方便的事。在这个包里会包含应用程序所需的所有二进制文件、数据和配置文件等等。</p>
</li>
<li><p>上传包。在完成打包后，我们就可以上传这个软件包了。</p>
</li>
<li><p>部署。最后，我们就可以在我们的线上环境中安装这个软件包。</p>
</li>
</ul>
<h6 id="Web_应用的构建实战">Web 应用的构建实战</h6><pre><code>下面就让我们来构建一个简单的 Web 应用，来实践一下这个过程。在这里，我们要使用到的一个工具是 Gulp，当然对于 Grunt 也是类似的。

Gulp 入门指南

Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。
全局安装 gulp：
$ npm install --<span class="keyword">global</span> gulp
作为项目的开发依赖（devDependencies）安装：
$ npm install --save-dev gulp
在项目根目录下创建一个名为 gulpfile.js 的文件：
<span class="keyword">var</span> gulp = <span class="keyword">require</span>(<span class="string">'gulp'</span>);

gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="comment">// 将你的默认的任务代码放在这</span>
});
运行 gulp：
$ gulp
默认的名为 <span class="keyword">default</span> 的任务（task）将会被运行，在这里，这个任务并未做任何事情。接下来，我们就可以打造我们的应用的构建系统了。

代码质量检测工具

当 C 还是一门新型的编程语言时，还存在一些未被原始编译器捕获的常见错误，所以程序员们开发了一个被称作 lint 的配套项目用来扫描源文件，查找问题。

对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有 JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语言来说比较重要。

<span class="number">2011</span>年，一个叫 Anton Kovalyov 的前端程序员借助开源社区的力量弄出来了 JSHint，其思想基本上和 JSLint 是一致的，但是其有一下几项优势：

可配置规则，每个团队可以自己定义自己想要的代码规范。
对社区非常友好，社区支持度高。
可定制的结果报表。
下面就让我们来安装这个软件吧：

安装及使用

npm install jshint gulp-jshint --save-dev
示例代码:

<span class="keyword">var</span> jshint = <span class="keyword">require</span>(<span class="string">'gulp-jshint'</span>);
<span class="keyword">var</span> gulp   = <span class="keyword">require</span>(<span class="string">'gulp'</span>);

gulp.task(<span class="string">'lint'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">return</span> gulp.src(<span class="string">'./lib/*.js'</span>)
    .pipe(jshint())
    .pipe(jshint.reporter(<span class="string">'YOUR_REPORTER_HERE'</span>));
});
自动化测试工具

一般来说，自动测试应该从两部分考虑：

单元测试
功能测试
Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架，

<span class="keyword">var</span> gulp = <span class="keyword">require</span>(<span class="string">'gulp'</span>);
<span class="keyword">var</span> mocha = <span class="keyword">require</span>(<span class="string">'gulp-mocha'</span>);

gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> gulp.src(<span class="string">'test.js'</span>, {read: <span class="keyword">false</span>})
        <span class="comment">// gulp-mocha needs filepaths so you can't have any plugins before it</span>
        .pipe(mocha({reporter: <span class="string">'nyan'</span>}));
});
</code></pre><ul>
<li><p>编译</p>
<p>  对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。</p>
<p>  动态语言的编译</p>
<p>  可以说这类型的语言，是以我们常见的 JavaScript 为代表。</p>
<p>  CoffeeScript 是一套 JavaScript 的转译语言，并且它增强了 JavaScript 的简洁性与可读性。</p>
<p>  Webpack 是一款模块加载器兼打包工具，它能把各种资源，例如 JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</p>
<p>  Babel 是一个转换编译器，它能将 ES6 转换成ES5，以便在较低版本的浏览器中正确运行。</p>
</li>
<li><p>打包</p>
<p>  在 GNU/Linux 系统的软件包里通过包含了已压缩的软件文件集以及该软件的内容信息。常见的软件包有</p>
<p>  DEB。Debian 软件包格式，文件扩展名为 .deb<br>  RPM（原 Red Hat Package Manager，现在是一个递归缩写）。该软件包分为二进制包（Binary）、源代码包（Source）和 Delta 包三种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM 自动编译、安装。源代码包经常以 src.rpm 作为后缀名。<br>  压缩文档 tar.gz。通常是该软件的源码，故而在安装的过程中需要编译、安装，并且在编译时需要自己手动安装所需要依赖的软件。在软件仓库没有最新版本的软件时，tar.gz 往往是最好的选择。<br>  由于这里的打包过程比较繁琐，就不介绍了。有兴趣的读者可以自己了解一下。</p>
</li>
<li><p>上传及发布包</p>
<p>  上传包之前我们需要创建一个相应的文件服务器，又或者是相应的软件源。并且对于我们的产品环境的服务器来说，我们还需要指定好这个软件源才能安装这个包。</p>
<p>  以 Ubuntu 为例，Ubuntu 里的许多应用程序软件包，是放在网络里的服务器上，这些服务器网站，就称作“源”，从源里可以很方便地获取软件包。</p>
<p>  因而在这一步中，我们所需要做的事便是将我们打包完的软件上传到相应的服务器上。</p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/08/17/web_start/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/07/22/javascript/">
                            JavaScript基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-07-22T18:15:02+08:00">
	
		    Jul 22, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习JavaScript需要会什么？">学习JavaScript需要会什么？</h2><p>现在的用户无论是用电脑还是手机都免不了要和网页多多少少打交道，网页技术随着互联网出现而出现，随着互联网爆发而爆发，在互联网不断往前发展的同是JavaScript起到了无法替代的作用，而最新的版本ES6（ES2015）在2015年发布，给JavaScript带来了全新的语法糖，也让JavaScript的编写更容易，更可观。</p>
<h2 id="JavaScript是什么">JavaScript是什么</h2><h4 id="工作流">工作流</h4><p>JavaScript是一种动态、弱类型、基于原型的语言，通过浏览器可以直接执行。当浏览器遇到\<script\>标记的时候，浏览器会执行之间的JavaScript代码，嵌入的JavaScript代码是按顺序执行的，JavaScript里面都是对象，有一种原型机制，将所有的对象联系起来。</script\></p>
<h4 id="原型和原型链">原型和原型链</h4><p><img src="https://www.processon.com/chart_image/58493602e4b031ce54234be6.png" alt=""></p>
<h4 id="作用域和上下文">作用域和上下文</h4><p>JavaScript作用域分两种:</p>
<ol>
<li>全局作用域</li>
<li>局部作用域</li>
</ol>
<p>在JavaScript，函数是对象，一切皆对象，那么函数也和其它对象一样，拥有可以通过代码访问的属性和一系列供JavaScript引擎访问的内部属性。其中有个内部属性[[Scope]]，该属性包含了函数被创建的作用域中对象的集合，此集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>举个🌰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当add创建时，它的作用域会填入一个全局对象，该全局对象包含了所有的全局变量，如下图（图中只列举部分）：<br><img src="https://www.processon.com/chart_image/58524894e4b05a0284734630.png" alt=""></p>
<p>函数add的作用域将在执行时用到，例如执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>执行此代码是会创建一个称为“运行期上下文（execution context）”的内部对象，运行期上下文定义了函数执行时的环境，每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</p>
<p>这些值按照他们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象随之被销毁。新的作用域链如下图：<br><img src="https://www.processon.com/chart_image/58524b1de4b07ab5f2c9f38e.png" alt=""></p>
<p>在函数执行时，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据，该过程从作用域链头部，也就是activation object开始搜索，查找同名的标识符，如果找到了就用对应的变量，如果没找到继续搜索作用域链中的下一对象，如果搜索完毕未找到，则认为未定义。</p>
<h4 id="单线程和异步">单线程和异步</h4><p>从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。</p>
<h6 id="任务队列">任务队列</h6><ol>
<li>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li>
<li>异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li>
</ol>
<p>他们的运行机制：</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100801.jpg" alt=""></p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<h4 id="数据类型">数据类型</h4><p>String、Number、Boolean、null、undefined、Object(Array、Date …)</p>
<h4 id="闭包">闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pos = start;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Move to '</span> + (pos += <span class="number">2</span>) + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> move_next = move(<span class="number">6</span>); </span><br><span class="line">move_next();  <span class="comment">// Move to 8. </span></span><br><span class="line">move_next();  <span class="comment">// Move to 10.</span></span><br></pre></td></tr></table></figure>
<p>move函数的内部匿名函数持有了move的属性pos，导致pos属性不会随着move的生命周期结束而结束。</p>
<h2 id="为什么要用JavaScript?">为什么要用JavaScript?</h2><h4 id="基础">基础</h4><p>JavaScript可以把基础很好的总结为三座大山</p>
<h4 id="关于新技术">关于新技术</h4><p>基础很重要，新技术很危险，学习的同时带着“质疑精神”</p>
<h2 id="JavaScript怎么用？">JavaScript怎么用？</h2><h4 id="CSS预处理器">CSS预处理器</h4><p>SASS的变量方案也会带来一些问题：学习成本；调试工作量；代码整合不方便</p>
<h4 id="跨界、CoffeeScript、TypeScript和ES6">跨界、CoffeeScript、TypeScript和ES6</h4><p>CoffeeScript和TypeScript分别是Ruby和C#社区的产物，它们都觉得JavaScript语法不够好，想改善它。只是它们俩分别代表了豪放派和严谨派，是两个极端，让它们俩先打一架好了</p>
<p>ES6带来了很多好用的语法糖</p>
<ol>
<li>let const </li>
<li>Promise</li>
<li>Class extends</li>
<li>Module import export</li>
<li>字符串、正则、数值、函数、对象都有扩展</li>
<li>详细教程参见:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a></li>
</ol>
<h4 id="Node">Node</h4><p>Node当前的用途：</p>
<ul>
<li>服务端开发</li>
<li>脚本工具</li>
</ul>
<p>随着前端的网络性能优化技巧逐渐完善，前端要做的事情变得越来越麻烦：图片合并、图片压缩、代码合并、代码压缩、动态加载、CDN。如果再加上jsLint之类的代码检查，就更加麻烦了。之前流行的加载是线上动态加载，requirejs那种方式，而现在流行在打包阶段按需加载，这就使得打包变得更加复杂。Node能为前端带来专业的开源的工具，这是打包脚本最好的结果，比自己折腾些质量一般的脚本好太多了！</p>
<h4 id="Angular">Angular</h4><p>整套代码组织的思路和服务端的MVC框架如出一辙：URL路由 + Controller + 数据抽象 + 模板引擎。虽然服务端出身的同学会倍感亲切，但这真的不是前端代码最好的组织方式。</p>
<h4 id="React">React</h4><p>React总的来说，不像Angular走错了路，但因为全家桶的原因门槛越来越高，这不是个好现象，未来有待观察，那么在它之前关于抽象和面向对象，你真的掌握了吗？封装、继承、多态、设计模式、解耦、API设计这些真的都熟练了吗？</p>
<h4 id="SPA(单页应用程序single_page_web_application)">SPA(单页应用程序single page web application)</h4><p>SPA真正的威力不是把多个网页变成单个网页，而是在产品形态上就彻底跳出网页般的排版布局。比如说做游戏、做网络IDE、做网页版PhotoShop之类。而这，需要的不仅是技术能力，而进一步需要产品设计能力，能不能技术驱动产品创新，不要再折腾什么技术工程化，发点力在技术产品化上。</p>
<h4 id="ReactNative_和_phoneGap">ReactNative 和 phoneGap</h4><ul>
<li>ReactNative阉割的CSS导致前端技能受限，对Native底层的黑盒导致调试和扩展的困难，学习性价比不一定高</li>
<li>PhoneGap把jsBridge写好，团队合作很方便，但是webview性能问题是瓶颈</li>
</ul>
<h4 id="微信小程序">微信小程序</h4><p>看过SDK的同学觉得跟HTML5没有半毛钱关系，这是一个伪HTML5的技术，开发的同学又多了一个平台要侍候。</p>
<h4 id="全栈">全栈</h4><p>全栈这个口号其实很毁人——别误解我的意思，我不是反对个人往全栈方向发展，而是想说，全栈并不容易，不是说前端开发的同学学了Node就全栈了，也不是说后端同学有了Angular和Bootstrap就全栈了，更不是说前端或者后端玩玩React Native，就能让iOS和Android下岗了。我发现一个可怕的事情是，全栈的口号让一些同学忽略了其他领域的知识深度，然后靠自我安慰甚至是自欺欺人地贬低其他领域的知识，以安慰自己已然全栈。</p>
<h4 id="前端核心竞争力">前端核心竞争力</h4><p>什么是核心呢？HTML、CSS和JavaScript。我指的是原生的这些东西，不用上来就跟我说React的JavaScriptx语法重定义了HTML，Sass改良了CSS，TypeScript给JavaScript带来了静态语言的语法，这些都是外围，今天是React，明天可以换成Angular，今天是Sass明天可以换成Less，今天是TypeScript明天可以是CoffeeScript，这些不重要。就像jQuery鼎盛时期，很多同学不学原生JavaScript，上来直接就上手jQuery一样，走不远。要理解jQuery为什么这么封装，其实在底层发生了什么，用原生会遇到什么问题，直接用原生能解决吗？把原生的技巧学熟了，这些外围的东西上手很快，而且什么情况下用什么，心里会非常有底。团队合作需要考虑的事情很多，要有责任感，别只顾着做自己的Geek。</p>
<p>强力推荐这些你不该错过的书：</p>
<ul>
<li>《CSS网站布局实录》——国产CSS2入门书，有些技巧已经淘汰，但仍不失为最好的CSS入门教程。</li>
<li>《无懈可击的Web设计》——讲CSS应用技巧的书，国内外粉丝别多，说是开创了CSS技巧流派也不为过。</li>
<li>《DOM JavaScript编程艺术》——JavaScript最好的入门书，没有之一，这本书是帮助你了解如何将DOM、CSS和JavaScript连接起来的一本书。严格来说，后端Node根本不算JavaScript，JavaScript是基于ES语法的一门脱水语言，如何实现的胶水？这本书将带你入门。</li>
<li>《JavaScript高级程序设计》 ——JavaScript必读的一本精典，读完之后对JavaScript的理解和实 践会上升非常大的一个台阶。</li>
<li>《编写高质量代码——Web前端开发修炼之道》 —— 这本书重点讲团队合作的注意事项。虽然一些具体的技巧，在今天已然过时，比如IE6的hack，但在团队合作方面的思考，直到今天我也没看到其他书在讲，这些思想没有其他书可替代。</li>
<li>《HTML5和CSS3权威指南》——目前为止，我读过的HTML5方面最好的一本原创书。配合实例进行API讲解，非常详细具体。连HTML5都提供了哪些底层的东西都不知道，又该如何去用好它呢？在我看来，是学习HTML5的必读书。</li>
<li>《响应式Web设计：HTML5和CSS3实战》——作者是《无懈可击的Web设计》忠实粉丝，所以很自然地，这也是本CSS技巧流派的书，侧重点在CSS3的实践技巧上，让人大开眼界。</li>
<li>《JavaScript设计模式》——JavaScript在实战时的高级技巧。</li>
</ul>
<h2 id="JavaScript的实际应用">JavaScript的实际应用</h2><ol>
<li>PC端浏览器</li>
<li>移动端浏览器</li>
<li>超级App的Hybrid</li>
<li>微信公众号这种App开放平台</li>
<li>微信朋友圈微博的营销页面</li>
<li>百度轻应用（很小众）</li>
<li>后台（部分公司）</li>
<li>微信小程序（姑且也算）</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/07/22/javascript/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/2016/page/2/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 1 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2016 yolynn. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.png"/>
        
            <h4 id="about-card-name">yolynn</h4>
        
            <h5 id="about-card-bio"><p>云在青天水在瓶 - 幽灵鸟</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>vip.com</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/jquery.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/assets/js/tranquilpeak.js" type="text/javascript"></script>
<!--SCRIPTS END-->



</html>
