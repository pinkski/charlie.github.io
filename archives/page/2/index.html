
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="yolynn">
    <title>Archives - yolynn</title>
    <meta name="author" content="yolynn">
    
    
        <link rel="icon" href="http://yolynn.com/assets/images/head.png">
    
    
    <meta name="description" content="云在青天水在瓶">
<meta property="og:type" content="blog">
<meta property="og:title" content="yolynn">
<meta property="og:url" content="http://yolynn.com/archives/page/2/index.html">
<meta property="og:site_name" content="yolynn">
<meta property="og:description" content="云在青天水在瓶">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yolynn">
<meta name="twitter:description" content="云在青天水在瓶">
    
    
        
    
    
        <meta property="og:image" content="http://yolynn.com/assets/images/head.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">yolynn</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="/#about">
        
        
            <i class="fa fa-lg fa-head.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.png"/>
            </a>
            <span class="sidebar-profile-name">yolynn</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/yolynn-bird" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://weibo.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-weibo"></i>
                    <span class="sidebar-button-desc">global.weibo</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://stackoverflow.com/users/2662962/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-stack-overflow"></i>
                    <span class="sidebar-button-desc">Stack Overflow</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.instagram.com/yolynn.bird" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-instagram"></i>
                    <span class="sidebar-button-desc">global.instagram</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://dribbble.com/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-dribbble"></i>
                    <span class="sidebar-button-desc">global.dribbble</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="http://yolynn.com/2010/04/22/weixin/"
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-weixin"></i>
                    <span class="sidebar-button-desc">global.weixin</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.zhihu.com/people/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-flickr"></i>
                    <span class="sidebar-button-desc">global.zhihu</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto://zxl20zxl@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/08/17/web_start/">
                            Web 应用的构建过程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-08-17T18:15:02+08:00">
	
		    Aug 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="Web_应用的构建过程">Web 应用的构建过程</h6><p>在刚创建项目的时候，我们都会有一个完整的构建思路。</p>
<ul>
<li><p>Compile。对于那些不是用浏览器的前端项目来说，如 ES6、CoffeeScript，他们还需要将代码编译成浏览器使用的 JavaScript 版本。对于 Java 语言来说，他需要一个编译的过程，在这个编译的过程中，会检查一些语法问题。</p>
</li>
<li><p>Check Style。通常我们会在我们的项目里定义一些代码规范，如 JavaScript 中的使用两个空格的缩进，Java 的 Checkstyle 中一个函数不能超过30行的限制。</p>
</li>
<li><p>单元测试。作为测试中最基础也是最快的测试，这个测试将集中于测试单个函数的是不是正确的。</p>
</li>
<li><p>功能测试。功能测试的意义在于，保证一个功能依赖的几个函数组合在一起也是可以工作的。</p>
</li>
<li><p>Mock Server。当我们的代码依赖于第三方服务的时候，我们就需要一个 Mock Server 来保证我们的功能代码可以独立地测试。</p>
</li>
<li><p>集成测试。这一步将集成前台、后台，并且运行起最后将上线的应用。接着依据于用户所需要的功能来编写相应的测试，来保证一个个的功能是可以工作的。</p>
</li>
<li><p>打包。对于部署来说，直接安装一个 RPM 包，或者 DEB 包是最方便的事。在这个包里会包含应用程序所需的所有二进制文件、数据和配置文件等等。</p>
</li>
<li><p>上传包。在完成打包后，我们就可以上传这个软件包了。</p>
</li>
<li><p>部署。最后，我们就可以在我们的线上环境中安装这个软件包。</p>
</li>
</ul>
<h6 id="Web_应用的构建实战">Web 应用的构建实战</h6><pre><code>下面就让我们来构建一个简单的 Web 应用，来实践一下这个过程。在这里，我们要使用到的一个工具是 Gulp，当然对于 Grunt 也是类似的。

Gulp 入门指南

Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。
全局安装 gulp：
$ npm install --<span class="keyword">global</span> gulp
作为项目的开发依赖（devDependencies）安装：
$ npm install --save-dev gulp
在项目根目录下创建一个名为 gulpfile.js 的文件：
<span class="keyword">var</span> gulp = <span class="keyword">require</span>(<span class="string">'gulp'</span>);

gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="comment">// 将你的默认的任务代码放在这</span>
});
运行 gulp：
$ gulp
默认的名为 <span class="keyword">default</span> 的任务（task）将会被运行，在这里，这个任务并未做任何事情。接下来，我们就可以打造我们的应用的构建系统了。

代码质量检测工具

当 C 还是一门新型的编程语言时，还存在一些未被原始编译器捕获的常见错误，所以程序员们开发了一个被称作 lint 的配套项目用来扫描源文件，查找问题。

对应于不同的语言都会有不同的 lint 工具，在 JavaScript 中就有 JSLint。JavaScript 是一门年轻、语法灵活多变且对格式要求相对松散的语言，因此这样的工具对于这门语言来说比较重要。

<span class="number">2011</span>年，一个叫 Anton Kovalyov 的前端程序员借助开源社区的力量弄出来了 JSHint，其思想基本上和 JSLint 是一致的，但是其有一下几项优势：

可配置规则，每个团队可以自己定义自己想要的代码规范。
对社区非常友好，社区支持度高。
可定制的结果报表。
下面就让我们来安装这个软件吧：

安装及使用

npm install jshint gulp-jshint --save-dev
示例代码:

<span class="keyword">var</span> jshint = <span class="keyword">require</span>(<span class="string">'gulp-jshint'</span>);
<span class="keyword">var</span> gulp   = <span class="keyword">require</span>(<span class="string">'gulp'</span>);

gulp.task(<span class="string">'lint'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">return</span> gulp.src(<span class="string">'./lib/*.js'</span>)
    .pipe(jshint())
    .pipe(jshint.reporter(<span class="string">'YOUR_REPORTER_HERE'</span>));
});
自动化测试工具

一般来说，自动测试应该从两部分考虑：

单元测试
功能测试
Mocha 是一个可以运行在 Node.js 和浏览器环境里的测试框架，

<span class="keyword">var</span> gulp = <span class="keyword">require</span>(<span class="string">'gulp'</span>);
<span class="keyword">var</span> mocha = <span class="keyword">require</span>(<span class="string">'gulp-mocha'</span>);

gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> gulp.src(<span class="string">'test.js'</span>, {read: <span class="keyword">false</span>})
        <span class="comment">// gulp-mocha needs filepaths so you can't have any plugins before it</span>
        .pipe(mocha({reporter: <span class="string">'nyan'</span>}));
});
</code></pre><ul>
<li><p>编译</p>
<p>  对于静态型语言来说，编译是一个很重要的步骤。不过，对于动态语言来说也存在这样的工具。</p>
<p>  动态语言的编译</p>
<p>  可以说这类型的语言，是以我们常见的 JavaScript 为代表。</p>
<p>  CoffeeScript 是一套 JavaScript 的转译语言，并且它增强了 JavaScript 的简洁性与可读性。</p>
<p>  Webpack 是一款模块加载器兼打包工具，它能把各种资源，例如 JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</p>
<p>  Babel 是一个转换编译器，它能将 ES6 转换成ES5，以便在较低版本的浏览器中正确运行。</p>
</li>
<li><p>打包</p>
<p>  在 GNU/Linux 系统的软件包里通过包含了已压缩的软件文件集以及该软件的内容信息。常见的软件包有</p>
<p>  DEB。Debian 软件包格式，文件扩展名为 .deb<br>  RPM（原 Red Hat Package Manager，现在是一个递归缩写）。该软件包分为二进制包（Binary）、源代码包（Source）和 Delta 包三种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM 自动编译、安装。源代码包经常以 src.rpm 作为后缀名。<br>  压缩文档 tar.gz。通常是该软件的源码，故而在安装的过程中需要编译、安装，并且在编译时需要自己手动安装所需要依赖的软件。在软件仓库没有最新版本的软件时，tar.gz 往往是最好的选择。<br>  由于这里的打包过程比较繁琐，就不介绍了。有兴趣的读者可以自己了解一下。</p>
</li>
<li><p>上传及发布包</p>
<p>  上传包之前我们需要创建一个相应的文件服务器，又或者是相应的软件源。并且对于我们的产品环境的服务器来说，我们还需要指定好这个软件源才能安装这个包。</p>
<p>  以 Ubuntu 为例，Ubuntu 里的许多应用程序软件包，是放在网络里的服务器上，这些服务器网站，就称作“源”，从源里可以很方便地获取软件包。</p>
<p>  因而在这一步中，我们所需要做的事便是将我们打包完的软件上传到相应的服务器上。</p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/08/17/web_start/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/07/22/javascript/">
                            JavaScript基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-07-22T18:15:02+08:00">
	
		    Jul 22, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习JavaScript需要会什么？">学习JavaScript需要会什么？</h2><p>现在的用户无论是用电脑还是手机都免不了要和网页多多少少打交道，网页技术随着互联网出现而出现，随着互联网爆发而爆发，在互联网不断往前发展的同是JavaScript起到了无法替代的作用，而最新的版本ES6（ES2015）在2015年发布，给JavaScript带来了全新的语法糖，也让JavaScript的编写更容易，更可观。</p>
<h2 id="JavaScript是什么">JavaScript是什么</h2><h4 id="工作流">工作流</h4><p>JavaScript是一种动态、弱类型、基于原型的语言，通过浏览器可以直接执行。当浏览器遇到\<script\>标记的时候，浏览器会执行之间的JavaScript代码，嵌入的JavaScript代码是按顺序执行的，JavaScript里面都是对象，有一种原型机制，将所有的对象联系起来。</script\></p>
<h4 id="原型和原型链">原型和原型链</h4><p><img src="https://www.processon.com/chart_image/5865217ce4b049e79ee3878a.png" alt=""></p>
<h4 id="作用域和上下文">作用域和上下文</h4><p>JavaScript作用域分两种:</p>
<ol>
<li>全局作用域</li>
<li>局部作用域</li>
</ol>
<p>在JavaScript，函数是对象，一切皆对象，那么函数也和其它对象一样，拥有可以通过代码访问的属性和一系列供JavaScript引擎访问的内部属性。其中有个内部属性[[Scope]]，该属性包含了函数被创建的作用域中对象的集合，此集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>举个🌰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当add创建时，它的作用域会填入一个全局对象，该全局对象包含了所有的全局变量，如下图（图中只列举部分）：<br><img src="https://www.processon.com/chart_image/58524894e4b05a0284734630.png" alt=""></p>
<p>函数add的作用域将在执行时用到，例如执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>执行此代码是会创建一个称为“运行期上下文（execution context）”的内部对象，运行期上下文定义了函数执行时的环境，每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</p>
<p>这些值按照他们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象随之被销毁。新的作用域链如下图：<br><img src="https://www.processon.com/chart_image/58524b1de4b07ab5f2c9f38e.png" alt=""></p>
<p>在函数执行时，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据，该过程从作用域链头部，也就是activation object开始搜索，查找同名的标识符，如果找到了就用对应的变量，如果没找到继续搜索作用域链中的下一对象，如果搜索完毕未找到，则认为未定义。</p>
<h4 id="单线程和异步">单线程和异步</h4><p>从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。</p>
<h6 id="任务队列">任务队列</h6><ol>
<li>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li>
<li>异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li>
</ol>
<p>他们的运行机制：</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100801.jpg" alt=""></p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<h4 id="数据类型">数据类型</h4><p>String、Number、Boolean、null、undefined、Object(Array、Date …)</p>
<h4 id="闭包">闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pos = start;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Move to '</span> + (pos += <span class="number">2</span>) + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> move_next = move(<span class="number">6</span>); </span><br><span class="line">move_next();  <span class="comment">// Move to 8. </span></span><br><span class="line">move_next();  <span class="comment">// Move to 10.</span></span><br></pre></td></tr></table></figure>
<p>move函数的内部匿名函数持有了move的属性pos，导致pos属性不会随着move的生命周期结束而结束。</p>
<h2 id="为什么要用JavaScript?">为什么要用JavaScript?</h2><h4 id="基础">基础</h4><p>JavaScript可以把基础很好的总结为三座大山</p>
<h4 id="关于新技术">关于新技术</h4><p>基础很重要，新技术很危险，学习的同时带着“质疑精神”</p>
<h2 id="JavaScript怎么用？">JavaScript怎么用？</h2><h4 id="CSS预处理器">CSS预处理器</h4><p>SASS的变量方案也会带来一些问题：学习成本；调试工作量；代码整合不方便</p>
<h4 id="跨界、CoffeeScript、TypeScript和ES6">跨界、CoffeeScript、TypeScript和ES6</h4><p>CoffeeScript和TypeScript分别是Ruby和C#社区的产物，它们都觉得JavaScript语法不够好，想改善它。只是它们俩分别代表了豪放派和严谨派，是两个极端，让它们俩先打一架好了</p>
<p>ES6带来了很多好用的语法糖</p>
<ol>
<li>let const </li>
<li>Promise</li>
<li>Class extends</li>
<li>Module import export</li>
<li>字符串、正则、数值、函数、对象都有扩展</li>
<li>详细教程参见:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a></li>
</ol>
<h4 id="Node">Node</h4><p>Node当前的用途：</p>
<ul>
<li>服务端开发</li>
<li>脚本工具</li>
</ul>
<p>随着前端的网络性能优化技巧逐渐完善，前端要做的事情变得越来越麻烦：图片合并、图片压缩、代码合并、代码压缩、动态加载、CDN。如果再加上jsLint之类的代码检查，就更加麻烦了。之前流行的加载是线上动态加载，requirejs那种方式，而现在流行在打包阶段按需加载，这就使得打包变得更加复杂。Node能为前端带来专业的开源的工具，这是打包脚本最好的结果，比自己折腾些质量一般的脚本好太多了！</p>
<h4 id="Angular">Angular</h4><p>整套代码组织的思路和服务端的MVC框架如出一辙：URL路由 + Controller + 数据抽象 + 模板引擎。虽然服务端出身的同学会倍感亲切，但这真的不是前端代码最好的组织方式。</p>
<h4 id="React">React</h4><p>React总的来说，不像Angular走错了路，但因为全家桶的原因门槛越来越高，这不是个好现象，未来有待观察，那么在它之前关于抽象和面向对象，你真的掌握了吗？封装、继承、多态、设计模式、解耦、API设计这些真的都熟练了吗？</p>
<h4 id="SPA(单页应用程序single_page_web_application)">SPA(单页应用程序single page web application)</h4><p>SPA真正的威力不是把多个网页变成单个网页，而是在产品形态上就彻底跳出网页般的排版布局。比如说做游戏、做网络IDE、做网页版PhotoShop之类。而这，需要的不仅是技术能力，而进一步需要产品设计能力，能不能技术驱动产品创新，不要再折腾什么技术工程化，发点力在技术产品化上。</p>
<h4 id="ReactNative_和_phoneGap">ReactNative 和 phoneGap</h4><ul>
<li>ReactNative阉割的CSS导致前端技能受限，对Native底层的黑盒导致调试和扩展的困难，学习性价比不一定高</li>
<li>PhoneGap把jsBridge写好，团队合作很方便，但是webview性能问题是瓶颈</li>
</ul>
<h4 id="微信小程序">微信小程序</h4><p>看过SDK的同学觉得跟HTML5没有半毛钱关系，这是一个伪HTML5的技术，开发的同学又多了一个平台要侍候。</p>
<h4 id="全栈">全栈</h4><p>全栈这个口号其实很毁人——别误解我的意思，我不是反对个人往全栈方向发展，而是想说，全栈并不容易，不是说前端开发的同学学了Node就全栈了，也不是说后端同学有了Angular和Bootstrap就全栈了，更不是说前端或者后端玩玩React Native，就能让iOS和Android下岗了。我发现一个可怕的事情是，全栈的口号让一些同学忽略了其他领域的知识深度，然后靠自我安慰甚至是自欺欺人地贬低其他领域的知识，以安慰自己已然全栈。</p>
<h4 id="前端核心竞争力">前端核心竞争力</h4><p>什么是核心呢？HTML、CSS和JavaScript。我指的是原生的这些东西，不用上来就跟我说React的JavaScriptx语法重定义了HTML，Sass改良了CSS，TypeScript给JavaScript带来了静态语言的语法，这些都是外围，今天是React，明天可以换成Angular，今天是Sass明天可以换成Less，今天是TypeScript明天可以是CoffeeScript，这些不重要。就像jQuery鼎盛时期，很多同学不学原生JavaScript，上来直接就上手jQuery一样，走不远。要理解jQuery为什么这么封装，其实在底层发生了什么，用原生会遇到什么问题，直接用原生能解决吗？把原生的技巧学熟了，这些外围的东西上手很快，而且什么情况下用什么，心里会非常有底。团队合作需要考虑的事情很多，要有责任感，别只顾着做自己的Geek。</p>
<p>强力推荐这些你不该错过的书：</p>
<ul>
<li>《CSS网站布局实录》——国产CSS2入门书，有些技巧已经淘汰，但仍不失为最好的CSS入门教程。</li>
<li>《无懈可击的Web设计》——讲CSS应用技巧的书，国内外粉丝别多，说是开创了CSS技巧流派也不为过。</li>
<li>《DOM JavaScript编程艺术》——JavaScript最好的入门书，没有之一，这本书是帮助你了解如何将DOM、CSS和JavaScript连接起来的一本书。严格来说，后端Node根本不算JavaScript，JavaScript是基于ES语法的一门脱水语言，如何实现的胶水？这本书将带你入门。</li>
<li>《JavaScript高级程序设计》 ——JavaScript必读的一本精典，读完之后对JavaScript的理解和实 践会上升非常大的一个台阶。</li>
<li>《编写高质量代码——Web前端开发修炼之道》 —— 这本书重点讲团队合作的注意事项。虽然一些具体的技巧，在今天已然过时，比如IE6的hack，但在团队合作方面的思考，直到今天我也没看到其他书在讲，这些思想没有其他书可替代。</li>
<li>《HTML5和CSS3权威指南》——目前为止，我读过的HTML5方面最好的一本原创书。配合实例进行API讲解，非常详细具体。连HTML5都提供了哪些底层的东西都不知道，又该如何去用好它呢？在我看来，是学习HTML5的必读书。</li>
<li>《响应式Web设计：HTML5和CSS3实战》——作者是《无懈可击的Web设计》忠实粉丝，所以很自然地，这也是本CSS技巧流派的书，侧重点在CSS3的实践技巧上，让人大开眼界。</li>
<li>《JavaScript设计模式》——JavaScript在实战时的高级技巧。</li>
</ul>
<h2 id="JavaScript的实际应用">JavaScript的实际应用</h2><ol>
<li>PC端浏览器</li>
<li>移动端浏览器</li>
<li>超级App的Hybrid</li>
<li>微信公众号这种App开放平台</li>
<li>微信朋友圈微博的营销页面</li>
<li>百度轻应用（很小众）</li>
<li>后台（部分公司）</li>
<li>微信小程序（姑且也算）</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/07/22/javascript/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/07/17/my_git/">
                            我的git之旅
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-07-17T18:15:02+08:00">
	
		    Jul 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="background">background</h6><blockquote>
<p>从什么时候起，终于摆脱了SVN的梦魇，发现有了git真是太爽了，对于SVN的印象总是在解决冲突，而对于git确实顺畅的敲击的各种命令耍酷装X，确实给人的感觉太好了</p>
</blockquote>
<h6 id="版本控制">版本控制</h6><pre><code>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
虽然基于 Git 的工作流可能并不是一个非常好的实践，但是在这里我们以这个工作流做为实践来开展我们的项目。如下图所示是一个基于 Git 的项目流：
</code></pre><p><img src="http://ww1.sinaimg.cn/large/801b780agw1f8xm6cf8obj20jr0oin16.jpg" alt=""></p>
<pre><code>基于 Git 的工作流
基于 Git 的工作流
我们日常会工作在 “develop” 分支（那条线）上，通常来说每个迭代我们会发布一个新的版本，而这个新的版本将会直接上线到产品环境。那么上线到产品环境的这个版本就需要打一个版本号——这样不仅可以方便跟踪我们的系统，而且当出错的时候我们也可以直接回滚到上一个版本。如果在上线的时候有些 <span class="keyword">Bug </span>不得不去修复，并且由于上线的新功能很重要，我们就需要一些 Hotfix。而从整个过程来看，版本控制起了一个非常大的作用。

不仅仅如此，版本控制的最大重要是在开发的过程中扮演的角色。通过版本管理系统，我们可以：

将某个文件回溯到之前的状态。
将项目回退到过去某个时间点。
在修改 <span class="keyword">Bug </span>时，可以查看修改历史，查出修改原因
只要版本控制系统还在，你可以任意修改项目中的文件，并且还可以轻松恢复。
常用的版本管理系统有 Git、SVN，但是从近年来看 Git 似乎更受市场欢迎。
</code></pre><h6 id="Git">Git</h6><pre><code>从一般开发者的角度来看，Git 有以下功能：

从服务器上克隆数据库（包括代码和版本信息）到单机上。
在自己的机器上创建分支，修改代码。
在单机上自己创建的分支上提交代码。
在单机上合并分支。
新建一个分支，把服务器上最新版的代码 fetch 下来，然后跟自己的主分支合并。
生成补丁（<span class="keyword">patch</span>），把补丁发送给主开发者。
看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。
一般开发者之间解决冲突的方法，开发者之间可以使用 pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。
从主开发者的角度（假设主开发者不用开发代码）看，Git 有以下功能：

查看邮件或者通过其它方式查看一般开发者的提交状态。
打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。
向公共服务器提交结果，然后通知所有开发人员。
</code></pre><h6 id="Git_初入">Git 初入</h6><pre><code>如果是第一次使用 Git，你需要设置署名和邮箱：

$ git config --global user<span class="class">.name</span> <span class="string">"用户名"</span>
$ git config --global user<span class="class">.email</span> <span class="string">"电子邮箱"</span>
你可以在 GitHub 新建免费的公开仓库或在 Coding<span class="class">.net</span> 新建免费的私有仓库。

按照 GitHub 的文档 或 Coding<span class="class">.net</span> 的文档 配置 SSH Key，然后将代码仓库 clone 到本地，其实就是将代码复制到你的机器里，并交由 Git 来管理：

$ git clone git@github<span class="class">.com</span>:username/repository<span class="class">.git</span>
或
$ git clone git@git<span class="class">.coding</span><span class="class">.net</span>:username/repository<span class="class">.git</span>
或使用 HTTPS 地址进行 clone：

$ git clone https:<span class="comment">//username:password@github.com/username/repository.git</span>
或
$ git clone https:<span class="comment">//username:password@git.coding.net/username/repository.git</span>
你可以修改复制到本地的代码了（ symfony-docs-chs 项目里都是 rst 格式的文档）。当你觉得完成了一定的工作量，想做个阶段性的提交：

向这个本地的代码仓库添加当前目录的所有改动：

$ git add .
或者只是添加某个文件：

$ git add -<span class="tag">p</span>
我们可以输入

$ git status
来看现在的状态，如下图是添加之前的：
</code></pre><p><img src="http://ww1.sinaimg.cn/large/801b780agw1f8xm8uen05j20u20d2ag4.jpg" alt=""></p>
<pre><code><span class="keyword">Before </span><span class="keyword">add
</span><span class="keyword">Before </span><span class="keyword">add
</span>下面是添加之后 的
</code></pre><p><img src="http://ww4.sinaimg.cn/large/801b780agw1f8xm9k6fa4j20yk0ba0xi.jpg" alt=""></p>
<pre><code><span class="label">After</span> <span class="keyword">add
</span><span class="label">After</span> <span class="keyword">add
</span>可以看到状态的变化是从黄色到绿色，即 unstage 到 <span class="keyword">add。
</span>
在完成添加之后，我们就可以写入相应的提交信息——如这次修改添加了什么内容 、这次修改修复了什么问题等等。在我们的工作流程里，我们使用 Jira 这样的工具来管理我们的项目，也会在我们的 Commit Message 里写上作者的名字，如下：

$ git commit -m <span class="string">"[GROWTH-001] Phodal: add first commit &amp; example"</span>
在这里的GROWTH-<span class="number">001</span>就相当于是我们的任务号，Phodal 则对应于用户名，后面的提交信息也会写明这个任务是干嘛的。

由于有测试的存在，在完成提交之后，我们就需要运行相应的测试来保证我们没有破坏原来的功能。因此，我们就可以<span class="keyword">PUSH我们的代码到服务器端：
</span>
$ git <span class="keyword">push
</span>这样其他人就可以看到我们修改的代码。
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2016/07/17/my_git/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/07/06/jspatch_commonQ/">
                            jspatch常见问题
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-07-06T12:50:02+08:00">
	
		    Jul 06, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="background">background</h2><blockquote>
<p>jspatch虽然好用、易用，能快速帮助解决线上问题，但同时也是一把双刃剑，用的时候需要小心翼翼，从调试、测试到上线需要时刻保持警惕，以下针对项目中遇到的实际问题及解决办法做个总结。</p>
</blockquote>
<ul>
<li>block传递</li>
</ul>
<p>当要把 JS 函数作为 block 参数给 OC时，需要先使用 block(paramTypes, function) 接口包装: </p>
<p>OC代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)uploadWithBlock:(FinishBlock)block force:(<span class="built_in">BOOL</span>)force &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">    </span><br><span class="line">        block(<span class="string">@"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uploadWithBlock_force: <span class="function"><span class="keyword">function</span>(<span class="params">tmpBlock, force</span>) </span>&#123;</span><br><span class="line">	tmpBlock = block(<span class="string">"NSString *"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//use str to do something</span></span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	self.ORIGuploadWithBlock_force(tmpBlock, force);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：JS 没有 block 类型的变量，OC 的 block 对象传到 JS 会变成 JS function，所有要从 JS 传 block 给 OC 都需要用 block() 接口包装。</p>
</blockquote>
<ul>
<li>block 里使用 self 变量</li>
</ul>
<p>js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleUserLogin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">var</span> tmpSelf = self;</span><br><span class="line">    </span><br><span class="line">	dispatch_after(<span class="number">15</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   </span><br><span class="line">		tmpSelf.uploadWithBlock(<span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	self.ORIGhandleUserLogin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在 block 里无法使用 self 变量，需要在进入 block 之前使用临时变量保存它</p>
</blockquote>
<ul>
<li>block 使用限制</li>
</ul>
<p>从 JS 传 block 到 OC，有两个限制：</p>
<ol>
<li>block 参数个数最多支持6个。（若需要支持更多，可以修改源码）</li>
<li>block 参数类型不能是 double。</li>
</ol>
<h6 id="JSPatch_Aspect兼容问题">JSPatch Aspect兼容问题</h6><ul>
<li><p>原因</p>
<p>  我们的项目中引入了 JSPatch 作为我们的 hot fix方案。 JSPatch 也会 hook 住对象的 forwradInvocation 方法，并且 swizzling 相应的 method ，使其指向转发 IMP ,由于 aspects 也是基于这两者实现的，那么会不会导致问题呢(其实类似的问题也会发生在对象提前被 kvo 了，会不会有影响)？</p>
<p>   回过头去看3.2.1 我们先是 hook了 类的 forwardInvocation 使其指向了 <strong>ASPECTS_ARE_BEING_CALLED</strong>，然后在 swizzling method 那里，aspect 有做一个判断，如果传入的 selector 指向了转发 IMP ,那么我们什么也不做。因此可想而知，如果传入的 selector 先被 JSPatch hook ,那么，这里我们将不会再处理,也就不会生成 aliasSelector 。</p>
<p>  这会导致什么问题了？设想一下，当 selector 被触发的时候，由于 selector 指向了转发 IMP ，因此会进入消息转发过程，同时由于 forwardInvocation 被 aspects 所 hook ,最终会进入到 aspects 的处理逻辑 <strong>ASPECTS_ARE_BEING_CALLED</strong> 中来。让我们回过头去看看3.2.2中的分析，由于找不到 aliasSelector 的 IMP 实现，因此会在此进行消息转发。而在 3.2.2.1 的分析中我们知道，子类并没有实现 NSSelectorFromString(AspectsForwardInvocationSelectorName) ，所以这里的流程就会进入 doesNotRecognizeSelector，从而抛出异常。</p>
</li>
<li><p>解决方案</p>
<p>  出现上诉问题的原因在于，当 aliasSelector 没有被找到的时候，我们没能将消息正常的转发，也就是没有实现一个 NSSelectorFromString(AspectsForwardInvocationSelectorName) ， 使得消息有机会重新转发回去的方法。因此解决方案也就呼之欲出了，我的做法是在对子类的 forwardInvocation 方法进行交换而不仅仅是替换，实现逻辑如下，强制生成一个 NSSelectorFromString(AspectsForwardInvocationSelectorName) 指向原对象的 forwardInvocation 的实现。</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">   subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">   ...</span><br><span class="line">   IMP originalImplementation = class_replaceMethod(subclass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_<span class="built_in">CALLED__</span>, <span class="string">"v@:@"</span>);</span><br><span class="line">   <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(subclass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName),   originalImplementation, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Method baseTargetMethod = class_getInstanceMethod(baseClass, <span class="keyword">@selector</span>(forwardInvocation:));</span><br><span class="line">        IMP baseTargetMethodIMP = method_getImplementation(baseTargetMethod);</span><br><span class="line">       <span class="keyword">if</span> (baseTargetMethodIMP) &#123;</span><br><span class="line">               class_addMethod(subclass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), baseTargetMethodIMP, <span class="string">"v@:@"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意如果 originalImplementation 为空，那么生成的 NSSelectorFromString(AspectsForwardInvocationSelectorName) 将指向 baseClass 也就是真正的这个对象的 forwradInvocation ,这个其实也就是 JSPatch hook 的方法。同时为了保证 block 的执行顺序（也就是前面介绍的 before hooks / instead hooks / after hooks ），这里需要将这段代码提前到 after hooks 执行之前进行。这样就解决了 forwardInvocation 在外面已经被 hook 之后的冲突问题。</p>
</blockquote>
<h6 id="super()调用问题">super()调用问题</h6><blockquote>
<p>可能是super call loop不完善导致， 1.0版本， 还没测试1.1版本</p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/07/06/jspatch_commonQ/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/06/30/ios_memory_analysis/">
                            iOS内存管理探究
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-06-30T18:15:02+08:00">
	
		    Jun 30, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="Background">Background</h2><h4 id="时间轴">时间轴</h4><ol>
<li>2010年，国内iOS开发刚兴起，手动管理内存（MRC）是一个必经的阶段</li>
<li>2011年，WWDC提出了自动引用计数（ARC），依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员</li>
<li>2013年，苹果人为ARC足够成熟，废弃macOS上的垃圾回收机制，ARC迅速被接受</li>
<li>2014年，WWDC推出Swift语言，继续使用ARC</li>
</ol>
<h4 id="基础">基础</h4><p><a href="http://yolynn.com/2015/07/20/ios_arc_mrc/">iOS内存管理基础到进阶</a></p>
<h2 id="什么是引用计数">什么是引用计数</h2><p>引用计数是一个简单有效的管理对象生命周期的方式，除了Objective-C和Swift还有COM、C++11等语言使用。<br><img src="https://www.processon.com/chart_image/587345e5e4b09f680a3a3881.png" alt=""></p>
<h2 id="为什么用引用计数">为什么用引用计数</h2><ul>
<li><p>对象A生成一个对象M,调用对象B的某一方法，对象M作为参数传递，在没有引用计数情况下，内存原则是“谁申请谁释放”，那么对象A应在对象B不需要对象M时销毁M，但是对象B可能只是临时用一下M，也可能觉得M很重要，把M作为自己的成员变量，这种情况下什么时候去销毁M就成了一个难题<br><img src="https://www.processon.com/chart_image/58735027e4b087b19d4d7f55.png" alt=""></p>
</li>
<li><p>暴力的方式，是对象A调用B之后，马上销毁M，然后B需要将M复制一份，作为另一个对象M2，这意味着更多的内存申请、复制、释放工作，太影响性能<br><img src="https://www.processon.com/chart_image/587350bde4b032a566118f0b.png" alt=""> </p>
</li>
<li><p>引用计数方式，在参数M的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完之后再把引用计数减1。</p>
</li>
</ul>
<h2 id="Q_&amp;_A">Q &amp; A</h2><h4 id="不要向已经释放的对象发送消息">不要向已经释放的对象发送消息</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);<span class="comment">//1</span></span><br><span class="line">   [object release];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>最后一行，引用计数没有变为0，为什么？因为对象已经回收，而我们向已回收的对象发送了retainCount消息，所以它输出的结果应该是不确定的，如果对象所占的内存被复用了，可能会crash。</p>
<p>不确定值为什么是1不是0？因为最后一次执行release时，系统知道马上要回收内存了，没必要将retainCount减1了，对象回收后retainCount变得没有意义，不将1变为0，可以减少一次内存的写操作，加速对象的回收，这是编译器的优化操作。</p>
<h4 id="ARC下的内存管理问题">ARC下的内存管理问题</h4><p>ARC能够解决90%的内存管理，另外10%的内存管理需要开发者自己处理，盲目的依赖ARC，可能引起的问题主要集中在：</p>
<ol>
<li>过度使用block，无法解决循环引用问题</li>
<li>遇到底层CoreFoundation对象，需要手动管理它们的引用计数</li>
</ol>
<h6 id="循环引用问题">循环引用问题</h6><p>两个对象相互持有对方<br><img src="https://www.processon.com/chart_image/587343dae4b032a5660fe9fd.png" alt=""></p>
<p>多个对象依次持有对方，形成一个环状<br><img src="https://www.processon.com/chart_image/58734393e4b087b19d4be3a0.png" alt=""></p>
<h6 id="主动断开循环引用">主动断开循环引用</h6><p><img src="https://www.processon.com/chart_image/587345e5e4b09f680a3a3881.png" alt=""></p>
<p>常见于各种与block相关的代码逻辑中，比如:</p>
<ul>
<li>Controller持有网络请求对象</li>
<li>网络请求对像持有回调的block</li>
<li>回调的block里使用了self,持有了Controller</li>
</ul>
<p>解决办法：网络请求对象执行完block之后，主动释放对block的持有，打破循环引用，比如 self.successCompletionBlock = nil，但是更常用的方式是使用弱引用</p>
<h6 id="弱引用">弱引用</h6><p><img src="https://www.processon.com/chart_image/58734744e4b09f680a3a64f5.png" alt=""></p>
<p>系统对于每一个有若引用的对象，都维护一个表来记录它所有的弱引用的指针地址，当一个对象的引用计数为0时，系统通过这张表找到所有的弱引用指针，继而把它们都置为nil</p>
<p>弱引用的使用有额外的开销，避免盲目使用弱引用，在写界面元素时都用weak不太合适：</p>
<ol>
<li>创建对象时，可能因为weak不持有，造成刚创建就被释放</li>
<li>大部分ViewController的视图对象的生命周期与ViewController本身是一致的，没有必要</li>
</ol>
<h6 id="使用Xcode检测循环引用">使用Xcode检测循环引用</h6><ul>
<li>一段循环引用的代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *firstArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *secondArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [firstArray addObject:secondArray];</span><br><span class="line">    [secondArray addObject:firstArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Instuments =&gt; Leaks</li>
</ul>
<p><img src="http://blog.devtang.com/images/memory-instruments-1.jpg" alt=""></p>
<ul>
<li>Console</li>
</ul>
<p><img src="http://blog.devtang.com/images/memory-instruments-2.jpg" alt=""></p>
<ul>
<li>Cycle &amp; Roots</li>
</ul>
<p><img src="http://blog.devtang.com/images/memory-instruments-3.png" alt=""></p>
<h6 id="CoreFoundation对象的内存管理">CoreFoundation对象的内存管理</h6><p>CoreFoundation对象，大多以 XxxCreateWithXxx 方式创建：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 CTFontRef 对象</span></span><br><span class="line">CTFontRef fontRef = CTFontCreateWithName((<span class="built_in">CFStringRef</span>)<span class="string">@"ArialMT"</span>, fontSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数加 1， 等价retain</span></span><br><span class="line"><span class="built_in">CFRetain</span>(fontRef);</span><br><span class="line"><span class="comment">// 引用计数减 1，等价release</span></span><br><span class="line"><span class="built_in">CFRelease</span>(fontRef);</span><br></pre></td></tr></table></figure>
<p>ARC下有时需要将CoreFoundation对象转换成Objective-C对象，需要告诉编译器，转换过程中引用计数需要如何调整。引入<strong>bridge</strong>关键字：</p>
<ul>
<li>__bridge: 只做类型转换，不修改引用计数，原来的CoreFoundation对象在不用时，需要调用CFRelease方法</li>
<li>__bridge_retained:类型转换后，引用计数加1，不用时需要调用CFRelease方法</li>
<li>__bridge_transfer:类型转换后，引用计数交给ARC管理，不用时需要调用CFRelease方法</li>
</ul>
<h2 id="Summary">Summary</h2><p>有了ARC，内存管理工作大大减轻，但是依然需要理解引用计数的原理，以及ARC的优点和常见问题，综上几个核心点：</p>
<ol>
<li>引用计数</li>
<li>循环引用</li>
<li>CoreFoundation内存管理</li>
</ol>
<p>在实践中多做一些内存管理相关的探究，加深对内存管理的理解以及增长更多避免内存泄露的经验。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/06/30/ios_memory_analysis/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/06/17/my_tasking/">
                            我的任务清单是怎么安排的？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-06-17T18:15:02+08:00">
	
		    Jun 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="background">background</h6><blockquote>
<p>相信你的每一天都离不开任务，工作任务自然，日常生活琐事亦是任务，其实把人生比作一款游戏，为了增强玩家的粘性，设置了每日签到、主线任务、支线任务、日常任务，每当你完成一项任务就会收获金钱和经验</p>
<p>那么作为程序猿的我们，何不摒弃文绉绉要么定个什么短期长期目标啥的，听到了就好累的感觉，从而选择模拟打游戏的方式过每一天，既可以收货金钱经验又不失掉乐趣，何乐而不为？</p>
<p>虽然我还在摸索这个人生游戏，但我已经从中收获了很多乐趣和成就感，也不断让自己进步，我现在采取的方式大概要依赖几个重要的APP，分享给大家： wunderlist、pomotodo、evernote、pocket</p>
</blockquote>
<h6 id="Tasking">Tasking</h6><pre><code>举个例子，如何开始编码，这应该也是一项基础的能力。结合日常，重新演绎一下这个过程：

有一个明确的实现目标。
评估目标并将其拆解成任务<span class="comment">(TODO)</span>。
规划任务的步骤<span class="comment">(TODO)</span>
学习相关技能
执行 Task，遇到难题就跳到第二步。
</code></pre><h6 id="如何_Tasking_一本书">如何 Tasking 一本书</h6><pre><code>以本文的写作为例，细分上面的过程就是：

我有了一个中心思想——在某种意义上来说就是标题。
依据中心思想我将这篇文章分成了四小节。
然后我开始写四小节的内容。
直到完成。
而如果将其划分到一个编程任务，那么也是一样的：

我们想到做一个 xxx 的 idea。
为了这个 idea 我们需要分成几步，或者几层设计。
对于每一步，我们应该做点什么
我们需要学习怎样的技能
集成每一步的代码，就有了我们的系统。
现在让我们以这本书的写作过程为例，来看看这个过程是怎么发生的。

在计划写一本书的时候，我们有关于这本书主题的一些想法。正是一些想法慢慢地凝聚成一个稳定的想法，不过这不是我们所要讨论的重点。

当我们已经有了一本书的相关话题的时候，我们会打算去怎么做？先来个头脑风暴，在上面写满我们的一些想法，如这本书最开始划分了这七步：

<span class="number">1.</span>从零开始
<span class="number">2.</span>编码
<span class="number">3.</span>上线
<span class="number">4.</span>数据分析
<span class="number">5.</span>持续交付
<span class="number">6.</span>遗留系统
<span class="number">7.</span>回顾与新架构

接着，依据我们的想法整理出几个章节。如本书最初的时候只有七个章节，但是我们还需要第一个章节来指引新手，因此变成了八个章节。对应于每一个章节，我们都需要想好每一章里的内容。如在第一章里，又可以分成不同的几部分。随后，我们再对每一部分的内容进行任务划分，那么我们就会得到一个又一个的小的章节。在每个小的章节里，我们都可以大概策划一下我们要写的内容。

然后我们就可以开始写这样的一本书——由一节节汇聚成一章，由一章一章汇聚成一本。
</code></pre><h6 id="Tasking_开发任务">Tasking 开发任务</h6><pre><code>现在，让我们简单地来 Tasking 如何开发一个博客。作为一个程序员，如果我们要去开始一个博客系统的话，那么我们会怎么做？

先规划一下我们所需要的功能——如后台、评论、Social 等等，并且我们还应该设计我们博客的 Mockup。

随后我们就可以简单地设计一下系统的架构，如传统的前后端结合。
我们就可以进行技术选型了——使用哪个后端框架、使用哪个前端框架。
创建我们的 hello,world，然后开始进行一个功能的编码工作。
编码时，我们就需要不断地查看、添加测试等等。
完成一个个功能的时候，我们就会得到一个子模块。
依据一个个子模块，我们就可以得到我们的博客系统。
与我们日常开发一致的是：我们需要去划分任务的优先级。换句话来说，我们需要先实现我们的核心功能。

对于我们的博客系统来说，最主要的功能就是发博客、展示博客。往简单地说，一篇博客应该有这么基础的四部分：

<span class="number">1.</span>标题
<span class="number">2.</span>内容
<span class="number">3.</span>作者
<span class="number">4.</span>时间
<span class="number">5.</span>Slug

然后，我们就需要创建相应的 Model，根据这个 Model，我们就可以创建相应的控制器代码。再配置下路由，添加下页面。对于有些系统来说，我们就可以完成博客系统的展示了。
</code></pre><h6 id="写代码只是在码字">写代码只是在码字</h6><pre><code>编程这件事情实际上一点儿也不难，当我们只是在使用一个工具创造一些东西的时候，比如我们拿着电烙铁、芯片、电线等去焊一个电路板的时候，我们学的是如何运用这些工具。虽然最后我们的电路板可以实现相同的功能，但是我们可以一眼看到差距所在。

换个贴切一点的比喻，比如烧菜做饭，对于一个优秀的厨师和一个像我这样的门外汉而言，就算给我们相同的食材、厨具，一段时间后也许一份是诱人的美食，一份只能喂猪了——即使我模仿着厨师的步骤一步步地来，也许看上去会差不多，但是一吃便吃出差距了。

我们还做不好饭，还焊不好电路，还写不好代码，很大程度上并不是因为我们比别人笨，而只是别人比我们做了更多。有时候一种机缘巧遇的学习或者 bug 的出现，对于不同的人的编程人生都会有不一样的影响<span class="comment">(ps:说的好像是蝴蝶效应)</span>。我们只是在使用工具，使用的好与坏，在某种程序上决定了我们写出来的质量。

写字便是如此，给我们同样的纸和笔<span class="comment">(ps:减少无关因素)</span>，不同的人写出来的字的差距很大，写得好的相比于写得不好的 ，只是因为练习得更多。而编程难道不也是如此么，最后写代码这件事就和写字一样简单了。

刚开始写字的时候，我们需要去了解一个字的笔划顺序、字体结构，而这些因素相当于语法及其结构。熟悉了之后，写代码也和写字一样是简简单单的事。
</code></pre><h6 id="学习编程只是在学造句">学习编程只是在学造句</h6><pre><code>多么无聊的一个标题
计算机语言同人类语言一样，有时候我们也许会感慨一些计算机语言是多么地背离我们的世界，但是他们才是真正的计算机语言。

计算机语言是模仿人类的语言，从 <span class="keyword">if</span> 到其他，而这些计算机语言又比人类语言简单。故而一开始学习语言的时候我们只是在学习造句，用一句话来概括一句代码的意思，或者可以称之为函数、方法(<span class="function"><span class="keyword">method</span>)。

于是我们开始组词造句，以便最后能拼凑出一整篇文章。</span>
</code></pre><h6 id="编程是在写作">编程是在写作</h6><pre><code>编程是在写作，这是一个怎样的玩笑?这是在讽刺那些写不好代码，又写不好文章的么
代码如诗，又或者代码如散文。总的来说，这是相对于英语而言，对于中文而言可不是如此。如果用一种所谓的中文语言写出来的代码，不能像中文诗一样，那么它就算不上是一种真正的中文语言。

那些所谓的写作逻辑对编程的影响

早期的代码是以行数算的，文章是以字数算的
代码是写给人看的，文章也是写给人看的
编程同写作一样，都由想法开始
代码同文章一样都可以堆砌出来<span class="comment">(ps:如本文)</span>
写出好的文章不容易，需要反复琢磨，写出好的代码不也是如此么
构造一个类，好比是构造一个人物的性格特点，多一点不行，少一点又不全
代码生成，和生成诗一样，没有情感，过于机械化
。。。

然而好的作家和一般的写作者，区别总是很大，对同一个问题的思考程度也是不同的。从一个作者到一个作家的过程，是一个不断写作不断积累的过程。而从一个普通的程序员到一个优秀的程序员也是如此，需要一个不断编程的过程。

当我们开始真正去编程的时候，我们还会纠结于“僧推月下门”还是“僧敲月下门”的时候，当我们越来越熟练就容易决定究竟用哪一个。而这样的“推敲”，无论在写作中还是在编程中都是相似的过程。

写作的过程真的就是一次探索之旅，而且它会贯穿人的一生。
因此：

编程只是在码字，难道不是么？
真正的想法都在脑子里，而不在纸上，或者 IDE 里。
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2016/06/17/my_tasking/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/05/17/my_html/">
                            我的HTML5之旅
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-05-17T18:15:02+08:00">
	
		    May 17, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="background">background</h6><blockquote>
<p>如果我说只有经历过IE6适配的前端才能算老资历的前端恐怕没有人会反对吧，哈哈，你猜对了，我也是受过IE6折磨的一员，当初做毕业时的时候、抑或者刚参加工作那会儿</p>
<p>那时候，把产品会议一开，老大的需求一下来，连原型设计都没有，可能就是指某个系统或者网站说道，我要的跟这个差不多，或者在它的基础上拓展几个功能，那时候作为菜鸟的我并没有觉得有什么问题，只是一股脑的投入代码中去了，当然首先找到相似的网站或者系统，参考别人HTML和CSS如何实现页面框架和布局，再通过js联通后端数据，好了，做完后给老大看，老大的电脑显然没有安装chrome，而是古老的IE6，各种特效异常，哎~ 痛苦的事情由此展开，简直犹如滔滔江水，连绵不绝</p>
<p>现在的新同学们应该非常的庆幸，有so many的前端技术可供使用，虽然实显得更为复杂了，但是做的事情或者做完事情后的维护都变得简单了很多啊</p>
<p>下面我还是讲下我是如何学习HTML CSS  JavaScript的吧</p>
</blockquote>
<h6 id="HTML">HTML</h6><pre><code>之所以从 HTML 开始，是因为我们不需要配置一个复杂的开发环境，也许你还不知道开发环境是什么东西，不过这也没关系，毕竟这些知识需要慢慢的接触才能有所了解，尤其是对于普通的业余爱好者来说，当然，对于专业选手而言自然不是问题。HTML 是 Web 的核心语言，也算是比较基础的语言。

hello,world

hello,world 是一个传统，所以在这里也遵循这个有趣的传统，我们所要做的事情其实很简单，虽然也有一点点 hack 的感觉。——让我们先来新建一个文件并命名为“helloworld.html”。

(PS:大部分人应该都是在 Windows 环境下工作的，所以你需要新建一个文本，然后重命名，或者你需要一个编辑器，在这里我们推荐用 Sublime Text 。破解不破解，注册不注册都不会对你的使用有太多的影响。)

新建文件

输入
hello,world
保存为-&gt;“helloworld.html”，

双击打开这个文件。 正常情况下都应该是用你的默认浏览器打开。只要是一个正常工作的现代浏览器，都应该可以看到上面显示的是“Hello,world”。

这才是最短的 hello,world 程序，但是呢？在 Ruby 中会是这样子的

2.0.0-p353 :001 &gt; p "hello,world"
"hello,world"
    =&gt; "hello,world"
2.0.0-p353 :002 &gt;
等等，如果你了解过 HTML 的话，会觉得这一点都不符合语法规则，但是他工作了，没有什么比安装完 Nginx 后看到 It works! 更让人激动了。

遗憾的是，它可能无法在所有的浏览器上工作，所以我们需要去调试其中的 bug。

调试 hello,world

我们会发现我们的代码在浏览器中变成了下面的代码，如果你和我一样用的是 Chrome，那么你可以右键浏览器中的空白区域，点击审查元素，就会看到下面的代码。

<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
这个才是真正能在大部分浏览器上工作的代码，所以复制它到编辑器里吧。

说说 hello,world

我很不喜欢其中的<span class="tag">&lt;<span class="title">*</span>&gt;</span><span class="tag">&lt;/<span class="title">*</span>&gt;</span>，但是我也没有找到别的方法来代替它们，所以这是一个设计得当的语言。甚至大部分人都说这算不上是一门真正的语言，不过 HTML 的原义是

超文本标记语言
所以我们可以发现其中的关键词是标记——markup，也就是说 html 是一个 markup，head 是一个 markup，body 也是一个 markup。

然而，我们真正工作的代码是在 body 里面，至于为什么是在这里面，这个问题就太复杂了。打个比方来说：

我们所使用的汉语是人类用智慧创造的，我们所正在学的这门语言同样也是人类创造的。

我们在自己的语言里遵循着 桌子是桌子，凳子是凳子 的原则，很少有人会问为什么。

中文？

所以我们也可以把计算机语言与现实世界里用于交流沟通的语言划上一个等号。而我们所要学习的语言，并不是我们最熟悉的汉语语言，所以我们便觉得这些很复杂，但是如果我们试着用汉语替换掉上面的代码的话

<span class="tag">&lt;<span class="title">语言</span>&gt;</span>
    <span class="tag">&lt;<span class="title">头</span>&gt;</span><span class="tag">&lt;<span class="title">结束头</span>&gt;</span>
    <span class="tag">&lt;<span class="title">身体</span>&gt;</span>你好，世界<span class="tag">&lt;<span class="title">结束身体</span>&gt;</span>
<span class="tag">&lt;<span class="title">结束语言</span>&gt;</span>
这看上去很奇怪，只是因为是直译过去的原因，也许你会觉得这样会好理解一点，但是输入上可就一点儿也不方便，因为这键盘本身就不适合我们去输入汉字，同时也意味着可能你输入的会有问题。

让我们把上面的代码代替掉原来的代码然后保存，打开浏览器会看到下面的结果

<span class="tag">&lt;<span class="title">语言</span>&gt;</span> <span class="tag">&lt;<span class="title">头</span>&gt;</span><span class="tag">&lt;<span class="title">结束头</span>&gt;</span> <span class="tag">&lt;<span class="title">身体</span>&gt;</span>你好，世界<span class="tag">&lt;<span class="title">结束身体</span>&gt;</span> <span class="tag">&lt;<span class="title">结束语言</span>&gt;</span>
更不幸的结果可能是

<span class="tag">&lt;<span class="title">璇█</span>&gt;</span> <span class="tag">&lt;<span class="title">澶�</span>&gt;</span><span class="tag">&lt;<span class="title">缁撴潫澶�</span>&gt;</span> <span class="tag">&lt;<span class="title">韬綋</span>&gt;</span>浣犲ソ锛屼笘鐣�<span class="tag">&lt;<span class="title">缁撴潫韬綋</span>&gt;</span> <span class="tag">&lt;<span class="title">缁撴潫璇█</span>&gt;</span>
这是一个编码问题，对中文支持不友好。

我们把上面的代码改为和标记语言一样的结构

<span class="tag">&lt;<span class="title">语言</span>&gt;</span>
    <span class="tag">&lt;<span class="title">头</span>&gt;</span><span class="tag">&lt;/<span class="title">头</span>&gt;</span>
    <span class="tag">&lt;<span class="title">身体</span>&gt;</span>你好，世界<span class="tag">&lt;/<span class="title">身体</span>&gt;</span>
<span class="tag">&lt;/<span class="title">语言</span>&gt;</span>
于是我们看到的结果便是

<span class="tag">&lt;<span class="title">语言</span>&gt;</span> <span class="tag">&lt;<span class="title">头</span>&gt;</span> <span class="tag">&lt;<span class="title">身体</span>&gt;</span>你好，世界
被 Chrome 浏览器解析成什么样了？

<span class="tag">&lt;<span class="title">html</span>&gt;</span><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;<span class="title">语言</span>&gt;</span>
        <span class="tag">&lt;<span class="title">头</span>&gt;</span><span class="comment">&lt;!--头--&gt;</span>
        <span class="tag">&lt;<span class="title">身体</span>&gt;</span>你好，世界<span class="comment">&lt;!--身体--&gt;</span>
    <span class="comment">&lt;!--语言--&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">html</span>&gt;</span>      
以<span class="comment">&lt;!--开头，--&gt;</span>结尾的是注释，写给人看的代码，不是给机器看的，所以机器不会去理解这些代码。

但是当我们把代码改成

<span class="tag">&lt;<span class="title">whatwewanttosay</span>&gt;</span>你好世界<span class="tag">&lt;/<span class="title">whatwewanttosay</span>&gt;</span>
浏览器上面显示的内容就变成了

你好世界
或许你会觉得很神奇，但是这一点儿也不神奇，虽然我们的中文语法也遵循着标记语言的标准，但是我们的浏览器不支持中文标记。

结论:

浏览器对中文支持不友好。
浏览器对英文支持友好。
刚开始的时候不要对中文编程有太多的想法，这是很不现实的:

现有的系统都是基于英语语言环境构建的，对中文支持不是很友好。
中文输入的速度在某种程度上来说没有英语快。
我们离开话题已经很远了，但是这里说的都是针对于那些不满于英语的人来说的，只有当我们可以从头构建一个中文系统的时候才是可行的，而这些就要将 CPU、软件、硬件都包含在内，甚至我们还需要考虑重新设计 CPU 的结构，在某种程度上来说会有些不现实。或许，需要一代又一代人的努力。忘记那些吧，师夷之长技以制夷。

其它 HTML 标记

添加一个标题，

<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
我们便可以在浏览器的最上方看到“标题”二字，就像我们常用的淘宝网，也包含了上面的东西，只是还包括了更多的东西，所以你也可以看懂那些我们可以看到的淘宝的标题。

<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
hello,world
<span class="tag">&lt;<span class="title">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">h2</span>&gt;</span>次标题<span class="tag">&lt;/<span class="title">h2</span>&gt;</span>
<span class="tag">&lt;<span class="title">h3</span>&gt;</span>...<span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
<span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
更多的东西可以在一些书籍上看到，这边所要说的只是一次简单的语言入门，其它的东西都和这些类似。

小结

美妙之处

我们简单地上手了一门不算是语言的语言，浏览器简化了这其中的大部分过程，虽然没有 C 和其他语言来得有专业感，但是我们试着去开始写代码了。我们可能在未来的某一篇中可能会看到类似的语言，诸如 Python，我们所要做的就是

$ python file.py
=&gt;hello,world
然后在终端上返回结果。只是因为在我看来学会 HTML 是有意义的，简单的上手，然后再慢慢地深入，如果一开始我们就去理解指针，开始去理解类。我们甚至还知道程序是怎么编译运行的时候，在这个过程中又发生了什么。虽然现在我们也没能理解这其中发生了什么，但是至少展示了

中文编程语言在当前意义不大，不现实，效率不高兼容性差
语言的语法是固定的。（ps:虽然我们也可以进行扩充，我们将会在后来支持上述的中文标记。）
已经开始写代码，而不是还在配置开发环境。
随身的工具才是最好的，最常用的 code 也才是实在的。
更多

我们还没有试着去解决“某商店里的糖一颗5块钱，小明买了3颗糖，小明一共花了多少钱”的问题。也就是说我们学会的是一个还不能解决实际问题的语言，于是我们还需要学点东西，比如 JavaScript, CSS。我们可以将 JavaScript 理解为解决问题的语言，HTML 则是前端显示，CSS 是配置文件，这样的话，我们会在那之后学会成为一个近乎专业的程序员。我们刚刚学习了一下怎么在前端显示那些代码的行为，于是我们还需要 JavaScript。
</code></pre><h6 id="CSS">CSS</h6><pre><code>如果说 HTML 是建筑的框架，CSS 就是房子的装修。那么 JavaScript 呢，我听到的最有趣的说法是小三——还是先让我们回到代码上来吧。

下面就是我们之前说到的代码，CSS 将 Red 三个字母变成了红色。

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"para"</span> <span class="attribute">style</span>=<span class="value">"color:red"</span>&gt;</span>Red<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
只是，

var para=document.getElementById("para");
para.style.color="blue";
将字体变成了蓝色，CSS+HTML 让页面有序的工作着，但是 JavaScript 却打乱了这些秩序，有着唯恐世界不乱的精彩，也难怪被冠以小三之名了——或许终于可以理解，为什么以前人们对于 JavaScript 没有好感了——不过这里要讲的是正室，也就是 CSS，这时还没有 JavaScript。

Red Fonts
Red Fonts
简介

这不是一篇专业讲述 CSS 的书籍，所以我不会去说 CSS 是怎么来的，有些东西我们既然可以很容易从其他地方知道，也就不需要花太多时间去重复。诸如重构等这些的目的之一也在于去除重复的代码，不过有些重复是不可少的，也是有必要的，而通常这些东西可能是由其他地方复制过来的。

到目前为止我们没有依赖于任何特殊的硬件或者是软件，对于我们来说我们最基本的需求就是一台电脑，或者可以是你的平板电脑，当然也可以是你的智能手机，因为他们都有个浏览器，而这些都是能用的，对于我们的 CSS 来说也不会有例外的。

CSS(Cascading Style Sheets)，到今天我也没有记得他的全称，CSS 还有一个中文名字是层叠式样式表，事实上翻译成什么可能并不是我们关心的内容，我们需要关心的是他能做些什么。作为三剑客之一，它的主要目的在于可以让我们方便灵活地去控制 Web 页面的外观表现。我们可以用它做出像淘宝一样复杂的界面，也可以像我们的书本一样简单，不过如果要和我们书本一样简单的话，可能不需要用到 CSS。HTML 一开始就是依照报纸的格式而设计的，我们还可以继续用上面说到的编辑器，又或者是其他的。如果你喜欢 DreamWeaver 那也不错，不过一开始使用 IDE 可无助于我们写出良好的代码。

忘说了，CSS 也是有版本的，和 Windows，Linux 内核等等一样，但是更新可能没有那么频繁，HTML 也是有版本的，JavaScript 也是有版本的，复杂的东西不是当前考虑的内容。

代码结构

对于我们的上面的 Red 示例来说，如果没有一个好的结构，那么以后可能就是这样子。

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">style</span>=<span class="value">"font-size: 22px;color: #f00;text-align: center;padding-left: 20px;"</span>&gt;</span>如果没有一个好的结构<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">style</span>=<span class="value">"font-size: 44px;color: #3ed;text-indent: 2em;padding-left: 2em;"</span>&gt;</span>那么以后可能就是这样子。。。。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
虽然我们看到的还是一样的:

No Style
No Style
于是我们就按各种书上的建议重新写了上面的代码

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>CSS example<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
        <span class="class">.para</span><span class="rules">{
            <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">22px</span></span></span>;
            <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#f00</span></span></span>;
            <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
            <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">20px</span></span></span>;
        }</span>
        <span class="class">.para2</span><span class="rules">{
            <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">44px</span></span></span>;
            <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#3ed</span></span></span>;
            <span class="rule"><span class="attribute">text-indent</span>:<span class="value"> <span class="number">2em</span></span></span>;
            <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">2em</span></span></span>;
        }</span>
    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para"</span>&gt;</span>如果没有一个好的结构<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para2"</span>&gt;</span>那么以后可能就是这样子。。。。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
总算比上面好看也好理解多了，这只是临时的用法，当文件太大的时候，正式一点的写法应该如下所示:

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>CSS example<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>&gt;</span><span class="css"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para"</span>&gt;</span>如果没有一个好的结构<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para2"</span>&gt;</span>那么以后可能就是这样子。。。。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
我们需要

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>CSS example<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"./style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para"</span>&gt;</span>如果没有一个好的结构<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para2"</span>&gt;</span>那么以后可能就是这样子。。。。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
然后我们有一个像 app.js 一样的 style.css 放在同目录下，而他的内容便是

.para{
    font-size: 22px;
    color: #f00;
    text-align: center;
    padding-left: 20px;
}
.para2{
    font-size: 44px;
    color: #3ed;
    text-indent: 2em;
    padding-left: 2em;
}
这代码和 JS 的代码有如此多的相似

var para={
    font_size: '22px',
    color: '#f00',
    text_align: 'center',
    padding_left: '20px',
}
而22px、20px以及#f00都是数值，因此：

var para={
    font_size: 22px,
    color: #f00,
    text_align: center,
    padding_left: 20px,
}
目测差距已经尽可能的小了，至于这些话题会在以后讨论到，如果要让我们的编译器更正确的工作，那么我们就需要非常多这样的符号，除非你乐意去理解:

(dotimes (i 4) (print i))
总的来说我们减少了符号的使用，但是用 lisp 便带入了更多的括号，不过这是一种简洁的表达方式，也许我们可以在其他语言中看到。

\d{2}/[A-Z][a-z][a-z]/\d{4}
上面的代码，是为了从一堆数据中找出“某日/某月/某年”。如果一开始不理解那是正则表达式，就会觉得那个很复杂。

这门语言可能是为设计师而设计的，但是设计师大部分还是不懂编程的，不过相对来说这门语言还是比其他语言简单易懂一些。

样式与目标

如下所示，就是我们的样式

.para{
    font-size: 22px;
    color: #f00;
    text-align: center;
    padding-left: 20px;
}
我们的目标就是

如果没有一个好的结构
所以样式和目标在这里牵手了，问题是他们是如何在一起的呢？下面就是 CSS 与 HTML 沟通的重点所在了:

选择器

我们用到的选择器叫做类选择器，也就是 class，或者说应该称之为 class 选择器更合适。与类选择器最常一起出现的是 ID 选择器，不过这个适用于比较高级的场合，诸如用 JS 控制 DOM 的时候就需要用到 ID 选择器。而基本的选择器就是如下面的例子:

p.para{
    color: #f0f;
}
将代码添加到 style.css 的最下面会发现“如果没有一个好的结构”变成了粉红色，当然我们还会有这样的写法

p&gt;.para{
    color: #f0f;
}
为了产生上面的特殊的样式，虽然不好看，但是我们终于理解什么叫层叠样式了，下面的代码的权重比上面高，也因此有更高的优先规则。

而通常我们可以通过一个

p{
    text-align: left;
}
这样的元素选择器来给予所有的 p 元素一个左对齐。

还有复杂一点的复合型选择器，下面的是 HTML 文件

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>CSS example<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"./style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para"</span>&gt;</span>如果没有一个好的结构<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para2"</span>&gt;</span>那么以后可能就是这样子。。。。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
还有 CSS 文件

.para{
    font-size: 22px;
    color: #f00;
    text-align: center;
    padding-left: 20px;
}   
.para2{
    font-size: 44px;
    color: #3ed;
    text-indent: 2em;
    padding-left: 2em;
}

p.para{
    color: #f0f;
}
div#content p {
    font-size: 22px;
}
更有趣的 CSS

一个包含了 para2 以及 para_bg 的例子

<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"para2 para_bg"</span>&gt;</span>那么以后可能就是这样子。。。。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
我们只是添加了一个黑色的背景

.para_bg{
    background-color: #000;
}
重新改变后的网页变得比原来有趣了很多，所谓的继承与合并就是上面的例子。

我们还可以用 CSS3 做出更多有趣的效果，而这些并不在我们的讨论范围里面，因为我们讨论的是 be a geek。

或许我们写的代码都是那么的简单，从 HTML 到 JavaScript，还有现在的 CSS，只是总有一些核心的东西，而不是去考虑那些基础语法，基础的东西我们可以在实践的过程中一一发现。但是我们可能发现不了，或者在平时的使用中考虑不到一些有趣的用法或者说特殊的用法，这时候可以通过观察一些精致设计的代码中学习到。复杂的东西可以变得很简单，简单的东西也可以变得很复杂。
</code></pre><h6 id="JavaScript">JavaScript</h6><pre><code>JavaScript 现在已经无处不在了，也许你正打开的某个网站，他便可能是 node.js+json+javascript+mustache.js 完成的，虽然你还没理解上面那些是什么，也正是因为你不理解才需要去学习更多的东西。但是你只要知道 JavaScript 已经无处不在了，它可能就在你手机上的某个 app 里，就在你浏览的网页里，就运行在你 IDE 中的某个进程里。

hello,world

这里我们还需要有一个 helloworld.html，JavaScript 是专为网页交互而设计的脚本语言，所以我们一点点来开始这部分的旅途，先写一个符合标准的 helloworld.html

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
然后开始融入我们的 JavaScript，向 HTML 中插入JavaScript 的方法，就需要用到 HTML 中的 <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="handlebars"><span class="xml"> 标签，我们先用页面嵌入的方法来写 helloworld。

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
            <span class="built_in">document</span>.write(<span class="string">'hello,world'</span>);
        </span></span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
按照标准的写法，我们还需要声明这个脚本的类型

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
            <span class="built_in">document</span>.write(<span class="string">'hello,world'</span>);
        </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
没有显示 hello,world ?试试下面的代码

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
            <span class="built_in">document</span>.write(<span class="string">'hello,world'</span>);
        </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>
            disable Javascript
        <span class="tag">&lt;/<span class="title">noscript</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
JavaScriptFul

我们需要让我们的代码看上去更像是 js，同时是以 js 结尾。就像 C 语言的源码是以 C 结尾的，我们也同样需要让我们的代码看上去更正式一点。于是我们需要在 helloworld.html 的同一文件夹下创建一个 app.js 文件，在里面写着

document.write('hello,world');
同时我们的 helloworld.html 还需要告诉我们的浏览器 js 代码在哪里

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>
            disable Javascript
        <span class="tag">&lt;/<span class="title">noscript</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
从数学出发

让我们回到第一章讲述的小明的问题，从实际问题下手编程，更容易学会编程。小学时代的数学题最喜欢这样子了——某商店里的糖一个5块钱，小明买了3个糖，小明一共花了多少钱。在编程方面，也许我们还算是小学生。最直接的方法就是直接计算 3x5=?

document.write(3*5);
document.write 实际也我们可以理解为输出，也就是往页面里写入 3*5 的结果，在有双引号的情况下会输出字符串。我们便会在浏览器上看到15，这便是一个好的开始，也是一个糟糕的开始。
</code></pre><h6 id="设计和编程">设计和编程</h6><pre><code>对于实际问题，如果我们只是止于所要得到的结果，很多年之后，我们就成为了 code monkey。对这个问题进行再一次设计，所谓的设计有些时候会把简单的问题复杂化，有些时候会使以后的扩展更加简单。这一天因为这家商店的糖价格太高了，于是店长将价格降为了<span class="number">4</span>块钱。

<span class="built_in">document</span>.write(<span class="number">3</span>*<span class="number">4</span>);
于是我们又得到了我们的结果，但是下次我们看到这些代码的时候没有分清楚哪个是糖的数量，哪个是价格，于是我们重新设计了程序

price=<span class="number">4</span>;
num=<span class="number">3</span>;
<span class="built_in">document</span>.write(price*num);
这才能叫得上是程序设计，或许你注意到了“;”这个符号的存在，我想说的是这是另外一个标准，我们不得不去遵守，也不得不去 fuck。

函数

记得刚开始学三角函数的时候，我们会写

sin <span class="number">30</span>=<span class="number">0.5</span>
而我们的函数也是类似于此，换句话说，因为很多搞计算机的先驱都学好了数学，都把数学世界的规律带到了计算机世界，所以我们的函数也是类似于此，让我们从一个简单的开始。

<span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="built_in">document</span>.write(<span class="string">"hello,world"</span>);
}
hello();
当我第一次看到函数的时候，有些小激动终于出现了。我们写了一个叫 hello 的函数，它返回了往页面中写入 hello,world 的方法，然后我们调用了 hello 这个函数，于是页面上有了 hello,world。

<span class="function"><span class="keyword">function</span> <span class="title">sin</span>(<span class="params">degree</span>)</span>{
    <span class="keyword">return</span> <span class="built_in">document</span>.write(<span class="built_in">Math</span>.sin(degree));
}
sin(<span class="number">30</span>);
在这里 degree 就称之为变量。 于是输出了 -<span class="number">0.9880316240928602</span>，而不是 <span class="number">0.5</span>，因为这里用的是弧度制，而不是角度制。

sin(<span class="number">30</span>)
的输出结果有点类似于sin <span class="number">30</span>。写括号的目的在于，括号是为了方便解析，这个在不同的语言中可能是不一样的，比如在 Ruby 中我们可以直接用类似于数学中的表达:

<span class="number">2.0</span><span class="number">.0</span>-p353 :<span class="number">004</span> &gt; <span class="built_in">Math</span>.sin <span class="number">30</span>
=&gt; -<span class="number">0.9880316240928618</span>
<span class="number">2.0</span><span class="number">.0</span>-p353 :<span class="number">005</span> &gt;
我们可以在函数中传入多个变量，于是我们再回到小明的问题，就会这样去编写代码。

<span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">price,num</span>)</span>{
    result=price*num;
    <span class="built_in">document</span>.write(result);
}
calc(<span class="number">3</span>,<span class="number">4</span>);
但是从某种程度上来说，我们的 calc 做了计算的事又做了输出的事，总的来说设计上有些不好。

重新设计

我们将输出的工作移到函数的外面，

<span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">price,num</span>)</span>{
    <span class="keyword">return</span> price*num;
}
<span class="built_in">document</span>.write(calc(<span class="number">3</span>,<span class="number">4</span>));
接着我们用一种更有意思的方法来写这个问题的解决方案

<span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">price,num</span>)</span>{
    <span class="keyword">return</span> price*num;
}
<span class="function"><span class="keyword">function</span> <span class="title">printResult</span>(<span class="params">price,num</span>)</span>{
    <span class="built_in">document</span>.write(calc(price,num));
}
printResult(<span class="number">3</span>, <span class="number">4</span>)
看上去更专业了一点点，如果我们只需要计算的时候我们只需要调用 calc，如果我们需要输出的时候我们就调用 printResult 的方法。

object 和函数

我们还没有说清楚之前我们遇到过的 <span class="built_in">document</span>.write 以及 <span class="built_in">Math</span>.sin 的语法为什么看上去很奇怪，所以让我们看看他们到底是什么，修改 app.js 为以下内容

<span class="built_in">document</span>.write(<span class="keyword">typeof</span> <span class="built_in">document</span>);
<span class="built_in">document</span>.write(<span class="keyword">typeof</span> <span class="built_in">Math</span>);
<span class="keyword">typeof</span> <span class="built_in">document</span> 会返回 <span class="built_in">document</span> 的数据类型，就会发现输出的结果是

object object
所以我们需要去弄清楚什么是 object。对象的定义是

无序属性的集合，其属性可以包含基本值、对象或者函数。
创建一个 object，然后观察这便是我们接下来要做的

store={};
store.candyPrice=<span class="number">4</span>;
store.candyNum=<span class="number">3</span>;
<span class="built_in">document</span>.write(store.candyPrice * store.candyNum);
我们就有了和 <span class="built_in">document</span>.write 一样的用法，这也是对象的美妙之处，只是这里的对象只是包含着基本值，因为

<span class="keyword">typeof</span> story.candyPrice=<span class="string">"number"</span>
一个包含对象的对象应该是这样子的。

store={};
store.candyPrice=<span class="number">4</span>;
store.candyNum=<span class="number">3</span>;
<span class="built_in">document</span>.writeln(store.candyPrice * store.candyNum);

<span class="keyword">var</span> wall=<span class="keyword">new</span> <span class="built_in">Object</span>();
wall.store=store;
<span class="built_in">document</span>.write(<span class="keyword">typeof</span> wall.store);
而我们用到的 <span class="built_in">document</span>.write 和上面用到的 <span class="built_in">document</span>.writeln 都是属于这个无序属性集合中的函数。

下面代码说的就是这个无序属性集合中的函数。

<span class="keyword">var</span> IO=<span class="keyword">new</span> <span class="built_in">Object</span>();
<span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">result</span>)</span>{
    <span class="built_in">document</span>.write(result);
};
IO.print=print;
IO.print(<span class="string">"a obejct with function"</span>);
IO.print(<span class="keyword">typeof</span> IO.print);
我们定义了一个叫 IO 的对象，声明对象可以用

<span class="keyword">var</span> store={};
又或者是

<span class="keyword">var</span> store=<span class="keyword">new</span> <span class="built_in">Object</span>();
两者是等价的，但是用后者的可读性会更好一点，我们定义了一个叫print的函数，他的作用也就是 <span class="built_in">document</span>.write，IO 中的print 函数是等价于 print() 函数，这也就是对象和函数之间的一些区别，对象可以包含函数，对象是无序属性的集合，其属性可以包含基本值、对象或者函数。

复杂一点的对象应该是下面这样的一种情况。

<span class="keyword">var</span> Person={name:<span class="string">"phodal"</span>,weight:<span class="number">50</span>,height:<span class="number">166</span>};
<span class="function"><span class="keyword">function</span> <span class="title">dream</span>(<span class="params"></span>)</span>{
    future;
};
Person.future=dream;
<span class="built_in">document</span>.write(<span class="keyword">typeof</span> Person);
<span class="built_in">document</span>.write(Person.future);
而这些会在我们未来的实际编程过程中用得更多。

面向对象

开始之前先让我们简化上面的代码，

Person.future=<span class="function"><span class="keyword">function</span> <span class="title">dream</span>(<span class="params"></span>)</span>{
    future;
}
看上去比上面的简单多了，不过我们还可以简化为下面的代码。。。

<span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.name=<span class="string">"phodal"</span>;
    <span class="keyword">this</span>.weight=<span class="number">50</span>;
    <span class="keyword">this</span>.height=<span class="number">166</span>;
    <span class="keyword">this</span>.future=<span class="function"><span class="keyword">function</span> <span class="title">dream</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="string">"future"</span>;
    };
};
<span class="keyword">var</span> person=<span class="keyword">new</span> Person();
<span class="built_in">document</span>.write(person.name+<span class="string">"&lt;br&gt;"</span>);
<span class="built_in">document</span>.write(<span class="keyword">typeof</span> person+<span class="string">"&lt;br&gt;"</span>);
<span class="built_in">document</span>.write(<span class="keyword">typeof</span> person.future+<span class="string">"&lt;br&gt;"</span>);
<span class="built_in">document</span>.write(person.future()+<span class="string">"&lt;br&gt;"</span>);
只是在这个时候 Person 是一个函数，但是我们声明的 person 却变成了一个对象 一个Javascript函数也是一个对象，并且，所有的对象从技术上讲也只不过是函数。 这里的“&lt;br&gt;”是 HTML 中的元素，称之为 DOM，在这里起的是换行的作用，我们会在稍后介绍它，这里我们先关心下 <span class="keyword">this</span>。<span class="keyword">this</span> 关键字表示函数的所有者或作用域，也就是这里的 Person。

上面的方法显得有点不可取，换句话说和一开始的

<span class="built_in">document</span>.write(<span class="number">3</span>*<span class="number">4</span>);
一样，不具有灵活性，因此在我们完成功能之后，我们需要对其进行优化，这就是程序设计的真谛——解决完实际问题后，我们需要开始真正的设计，而不是解决问题时的编程。

<span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params">name,weight,height</span>)</span>{
    <span class="keyword">this</span>.name=name;
    <span class="keyword">this</span>.weight=weight;
    <span class="keyword">this</span>.height=height;
    <span class="keyword">this</span>.future=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="string">"future"</span>;
    };
};
<span class="keyword">var</span> phodal=<span class="keyword">new</span> Person(<span class="string">"phodal"</span>,<span class="number">50</span>,<span class="number">166</span>);
<span class="built_in">document</span>.write(phodal.name+<span class="string">"&lt;br&gt;"</span>);
<span class="built_in">document</span>.write(phodal.weight+<span class="string">"&lt;br&gt;"</span>);
<span class="built_in">document</span>.write(phodal.height+<span class="string">"&lt;br&gt;"</span>);
<span class="built_in">document</span>.write(phodal.future()+<span class="string">"&lt;br&gt;"</span>);
于是，产生了这样一个可重用的 JavaScript 对象, <span class="keyword">this</span> 关键字确立了属性的所有者。

其他

JavaScript 还有一个很强大的特性，也就是原型继承，不过这里我们先不考虑这些部分，用尽量少的代码及关键字来实际我们所要表达的核心功能，这才是这里的核心，其他的东西我们可以从其他书本上学到。

所谓的继承，

<span class="keyword">var</span> Chinese=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.country=<span class="string">"China"</span>;
}

<span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params">name,weight,height</span>)</span>{
    <span class="keyword">this</span>.name=name;
    <span class="keyword">this</span>.weight=weight;
    <span class="keyword">this</span>.height=height;
    <span class="keyword">this</span>.futrue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="string">"future"</span>;
    }
}
Chinese.prototype=<span class="keyword">new</span> Person();

<span class="keyword">var</span> phodal=<span class="keyword">new</span> Chinese(<span class="string">"phodal"</span>,<span class="number">50</span>,<span class="number">166</span>);
<span class="built_in">document</span>.write(phodal.country);
完整的 JavaScript 应该由下列三个部分组成:

核心(ECMAScript)——核心语言功能
文档对象模型(DOM)——访问和操作网页内容的方法和接口
浏览器对象模型(BOM)——与浏览器交互的方法和接口
我们在上面讲的都是 ECMAScript，也就是语法相关的，但是 JS 真正强大的，或者说我们最需要的可能就是对 DOM 的操作，这也就是为什么 jQuery 等库可以流行的原因之一，而核心语言功能才是真正在哪里都适用的，至于 BOM，真正用到的机会很少，因为没有完善的统一的标准。

一个简单的 DOM 示例,

<span class="xml"><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>
        disable Javascript
    <span class="tag">&lt;/<span class="title">noscript</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"para"</span> <span class="attribute">style</span>=<span class="value">"color:red"</span>&gt;</span>Red<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
我们需要修改一下 helloworld.html 添加

<span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"para"</span> <span class="attribute">style</span>=<span class="value">"color:red"</span>&gt;</span>Red<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
同时还需要将 script 标签移到 body 下面，如果没有意外的话我们会看到页面上用红色的字体显示 Red，修改 app.js。

var para=document.getElementById("para");
para.style.color="blue";
接着，字体就变成了蓝色，有了 DOM 我们就可以对页面进行操作，可以说我们看到的绝大部分的页面效果都是通过 DOM 操作实现的。</span>
</code></pre><h6 id="美妙之处">美妙之处</h6><pre><code>这里说到的 JavaScript 仅仅只是其中的一小小部分，忽略掉的东西很多，只关心的是如何去设计一个实用的 app，作为一门编程语言，它还有其他强大的内制函数，要学好需要一本有价值的参考书。这里提到的只是其中不到<span class="number">20</span>%的东西，其他的<span class="number">80</span>%或者更多会在你解决问题的时候出现。

我们可以创建一个对象或者函数，它可以包含基本值、对象或者函数。
我们可以用 JavaScript 修改页面的属性，虽然只是简单的示例。
我们还可以去解决实际的编程问题。
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2016/05/17/my_html/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/05/04/design_pattern/">
                            设计模式总览
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-05-04T18:15:02+08:00">
	
		    May 04, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="background">background</h2><blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
</blockquote>
<h2 id="设计模式的六大原则">设计模式的六大原则</h2><p><img src="http://7d9j3g.com1.z0.glb.clouddn.com/ebe2f25f298e311e8b958950ff9203a8" alt=""></p>
<ol>
<li>开闭原则（Open Close Principle）</li>
</ol>
<blockquote>
<p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
</blockquote>
<ol>
<li>里氏代换原则（Liskov Substitution Principle）</li>
</ol>
<blockquote>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
</blockquote>
<ol>
<li>依赖倒转原则（Dependence Inversion Principle）</li>
</ol>
<blockquote>
<p>这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。</p>
</blockquote>
<ol>
<li>接口隔离原则（Interface Segregation Principle）</li>
</ol>
<blockquote>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
</blockquote>
<ol>
<li>迪米特法则，又称最少知道原则（Demeter Principle）</li>
</ol>
<blockquote>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
</blockquote>
<ol>
<li>合成复用原则（Composite Reuse Principle）</li>
</ol>
<blockquote>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
</blockquote>
<h2 id="设计模式">设计模式</h2><p><img src="http://7d9j3g.com1.z0.glb.clouddn.com/be049062fe8d53a7d29dce88ce8e9861" alt=""></p>
<p><img src="http://7d9j3g.com1.z0.glb.clouddn.com/559da82a979cc01be72070447ca10b68" alt=""></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/05/04/design_pattern/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/04/19/computer/">
                            计算机课程串联
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-04-19T18:15:02+08:00">
	
		    Apr 19, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="background">background</h2><blockquote>
<p>不说废话，开门见山</p>
</blockquote>
<h4 id="一,_计算机组成原理">一, 计算机组成原理</h4><ul>
<li>这门学科告诉你什么是计算机。</li>
<li>首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。</li>
<li>综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。</li>
<li>最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。</li>
<li>其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。</li>
</ul>
<h4 id="二，操作系统">二，操作系统</h4><ul>
<li>综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。</li>
<li>比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。</li>
<li><p>理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。</p>
</li>
<li><p>现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！</p>
</li>
<li>我希望我写过的程序能在任何一台机上运行。</li>
<li>我希望我能边听音乐边干活——即同一时间可以运行多个程序。</li>
<li>我希望别人写的傻×东西不要影响到我的工作——即多任务控制。</li>
<li>我希望计算机里面的各种资源都能得到良好的组织，更快的访问。</li>
<li>我希望我的用户界面更好看，使用更方便，功能更强大！</li>
<li>我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！</li>
<li>如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。</li>
<li><p>计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。</p>
</li>
<li><p>而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。</p>
</li>
<li>操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。</li>
<li><p>操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。<br>当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。</p>
</li>
<li><p>既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。</p>
</li>
<li><p>我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。</p>
</li>
<li><p>至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。</p>
</li>
</ul>
<h4 id="三，数据结构">三，数据结构</h4><ul>
<li>数据结构的作用，就是为了提高硬件利用率。</li>
<li><p>比如操作系统需要查找用户应用程序”office”在硬盘的哪个位置，盲目的搜索一遍硬盘肯定是低效的，这时候搞个b+树作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。</p>
</li>
<li><p>数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。</p>
</li>
</ul>
<h4 id="四，计算机网络">四，计算机网络</h4><ul>
<li><p>计算机网络分为3块：</p>
<ol>
<li>硬件<ul>
<li>网卡，网线，交换机这些，用来处理数据的。</li>
</ul>
</li>
<li><p>协议</p>
<ul>
<li>数据在网络中通信如何组织？如何识别？如何保证数据的正确性？<br>这2块我就不多说了。</li>
</ul>
</li>
<li><p>操作系统</p>
</li>
</ol>
</li>
<li>这就是如何把计算机网络和操作系统结合起来的问题了。</li>
<li>对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。</li>
<li>操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。</li>
<li><p>传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。</p>
</li>
<li><p>简单来说就是这样，如果以后有时间，我再把osi七层协议中的内容和操作系统的交互再详述一遍吧。</p>
</li>
<li><p>网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。</p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/04/19/computer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/04/08/paradigm/">
                            多编程范式杂感
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-04-08T18:15:02+08:00">
	
		    Apr 08, 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="background">background</h2><blockquote>
<p>现有语言的编程范式有：过程式，面向对象，函数式，逻辑式。随着软件工业化程度的普及，以及软件的复杂度越来越高，编程语言的发展历程也是从最初的过程式（命令式）语言c，发展到以java语言为代表的面向对象编程语言。而逻辑编程语言(以prolog为代表）和函数式语言(lisp系列）还多用在学术和人工智能领域中。近几年，随着多核，云计算时代的到来。函数式编程语言逐渐浮出水面，最经典的语言以scheme,common-lisp,ml,clojure,go为代表.而且最近的jdk8也逐步加入了functional,closure,lambda等语法，而且scala的作者也越来越推崇编码者以函数式语言的思维来coding。可见编程语言的发展也是满足时代的变化不断变化着。从其中的发展历程中我们可以看到：技术的发展都是在围绕着解决“软件的复杂度”这个基本的需求而发展的。</p>
</blockquote>
<h3 id="一、_编程语言概述">一、 编程语言概述</h3><ul>
<li>编程语言是计算机的符号，是人和计算机的通信符号和协议。我们学习一门新的编程语言时，应该观察这门语言的那些特性呢？《SICP》一书的作者列举了一下三点：<ul>
<li>primitive elements. （基本元素）</li>
<li>means of combination. （组合手段）</li>
<li>means of abstraction. (抽象手段）</li>
</ul>
</li>
<li>以上3个特性，基本上涵盖了所有编程语言的特性，并且也是一个语言设计者从开始就要考虑的。我对这三点的理解：primitive elements表示语言的基本符号（基本数据类型，关键字等）也就是词法部分。means of combination利用基本元素通过组合的过程构建大型程序的手段，不同的语言提供的组合手段是不同的，下边我会详细描述。means of abstraction表示抽象，抽象是解决软件复杂度的重要手段，让软件的可读性，可扩展，可重复利用等得到提升。一下会从组合元素和抽象手段来对比更重语言特性。</li>
</ul>
<h3 id="二、_组合手段">二、 组合手段</h3><ul>
<li>汇编语言：算是最简单的词法和语法形式了。汇编器通过直译的过程将汇编代码翻译为二进制代码。 提供的primitive elements有：数字，字符，-，+，*，/ ， case,if, break, go，指令等基本元素；</li>
<li>c语言相比汇编语言更高级，让程序员脱离和寄存器，内存直接打交道的工作，提供了更多的组合手段：比如数组，结构体等数据结构。</li>
<li>java语言自称是面向对象语言，所以比c语言更进一步，通过强大的类型系统手段来组合属性和方法。</li>
<li>lisp方言以s-expression（著名的S表达式）来组合数据和函数。在lisp中不区分数据和函数，一切皆为数据。</li>
</ul>
<h3 id="三、_抽象手段">三、 抽象手段</h3><ul>
<li>从c语言开始，以函数为单元提供了对程序的抽象。这样大大的提高了程序的可复用，模块化等。让团队合作编码也成为可能。</li>
<li>面向对象编程：基本上隐藏了计算机的细节，开发者通过对象来抽象具体业务。但严格意义上来说java也属于imperative-lang的范畴而且都是传值调用。相比来说,python,ruby更面向对象一些，python融合了面向对象和函数式编程范式，更接近自然语言些。</li>
<li>以lisp为代表的函数式语言：以函数和模块为抽象手段；common-lisp基于宏开发了一套object-oriented的编程方式。 我比较倾向于函数式编程理念：函数的无副作用（不用考虑线程安全，特别是对于变态的Haskell），高阶函数，闭包,lambda等。</li>
</ul>
<h3 id="四、_类型系统">四、 类型系统</h3><ul>
<li>大家平时经常会说：javascript是一个弱类型的语言，java语言是强类型的语言。将编程语言从类型系统的角度区分语言也很有趣。一般来说弱类型语言更偏向自然语言一些，语法也很自由活泼些。而现今语言的走势也趋向与弱类型方向.</li>
<li>实现：我们知道计算机是结构化很强的，堆栈上一个二进制位的错误就会导致溢出，bus等错误。所以语言层面的自由得益于编译器或者解释器的功劳。比如java,c等语言有很强的编译时类型检测机制，强类型的好处驱使编码人员写出很少有语法，语义错误的代码，对IDE的支持也很棒，是大型技术团队的基石。</li>
<li>弱类型语言让我们获取了自由（不需要类型信息），让程序员少敲了许多键盘。自由是有代价的，编译器或解释器中内含类型推理(infer type); 类型推理是利用归一方法，基于上下文中的变量显式类型，操作符，返回值等信息，利用栈和逐渐替换的过程来推到出类型。 弱类型虽然可以轻松编译通过（或者不需要编译而是解释执行），但都是有类型检查过程的，只是将此过程延迟到运行时了。所以弱类型语言结构化不强，编码时很难确保类型无误，IDE，大型团队开发也不友好。 但是通过一些分析器可以不断的检测语法，语义错误，相当于达到了强类型语言的IDE效果。</li>
</ul>
<h3 id="五、编译/解释">五、编译/解释</h3><ul>
<li>java语言是解释型还是编译型的呢？ 这个很难说，从java source code -&gt; class byte code 的过程式javac编译器的过程。但是byte code 在jvm上执行的过程可能是解释执行也可能是编译执行的。解释型和编译型的内部都遵从编译原理的过程：词法分析-&gt; 语法分析-&gt;语义解析 -&gt; 编译器后端-&gt; native code . 的过程。 但有各自的优点：</li>
<li>解释器：加载code速度快；解释器需要维护运行时上下文等信息。所以加载必要的代码，片段解释执行。但是对于相同的代码都经过编译过程就很多余，造成时间浪费。</li>
<li>编译器：执行速度快。而且编译器后端也更容易优化中间代码，因为优化过程式一个结构化过程：往往需要遍历整个中间代码，整体优化代码，提高运行效率。</li>
<li>runtime：一般来说解释型语言需要在内存维护运行时上下文信息，服务于运行过程中变量的查找，绑定，scope等。 而编译语言基于堆栈模型执行代码，相对来说运行时简单，运行速度也快；</li>
<li>hotspot-jvm结合了解释和编译的各自优点；最先解释执行过程，如果方法被频繁执行，而且达到热点(hotspot),jvm会启动编译过程，将次代码编译为native-code，然后缓存起来，下一次的调研直接执行即可。 hotspot-jvm执行基于堆栈的指令byte code, 这一点也是基于跨平台byte-code运行的考虑，而牺牲了寄存器指令； （基于android操作系统上的dalvik虚拟机是基于寄存器指令的）；</li>
<li>所以说，设计一个语言往往是一个权衡过程；获取的“自由”越多，”牺牲“也更大。</li>
</ul>
<h3 id="六、_总结:">六、 总结:</h3><ul>
<li>最初从图灵为了解决莱布尼茨提出的：是否存在一个通用模型来解决一切计算任务这个命题，提出了图灵机。到冯洛伊曼仿真人脑神经元思考过程产生第一台基于存储器，运算器的计算机ENIAC，至今，计算机硬件技术并没有实质性的变化，只是随着摩尔定律的破灭，人们发展了多级高级缓存，多核，多cpu技术来支撑越来越大的计算任务。 在这个过程中，随着人们对逻辑学，符号学,算法的不断研究，用来和计算机交互的语言也越来越抽象和丰富。我们通过这个形象的符号来抽象时间和空间，通过这个形象的符号来解决软件的复杂性问题，通过这个符号来表达指令的计算过程。</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/04/08/paradigm/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/ ">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/3/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 2 of 5</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 yolynn. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.png"/>
        
            <h4 id="about-card-name">yolynn</h4>
        
            <h5 id="about-card-bio"><p>云在青天水在瓶 - 幽灵鸟</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>vip.com</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/jquery.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/assets/js/tranquilpeak.js" type="text/javascript"></script>
<!--SCRIPTS END-->



</html>
