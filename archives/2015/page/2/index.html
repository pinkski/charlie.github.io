
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="yolynn">
    <title>Archives: 2015 - yolynn</title>
    <meta name="author" content="yolynn">
    
    
        <link rel="icon" href="http://yolynn.com/assets/images/head.png">
    
    
    <meta name="description" content="云在青天水在瓶">
<meta property="og:type" content="blog">
<meta property="og:title" content="yolynn">
<meta property="og:url" content="http://yolynn.com/archives/2015/page/2/index.html">
<meta property="og:site_name" content="yolynn">
<meta property="og:description" content="云在青天水在瓶">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yolynn">
<meta name="twitter:description" content="云在青天水在瓶">
    
    
        
    
    
        <meta property="og:image" content="http://yolynn.com/assets/images/head.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">yolynn</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="/#about">
        
        
            <i class="fa fa-lg fa-head.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.png"/>
            </a>
            <span class="sidebar-profile-name">yolynn</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/yolynn-bird" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://weibo.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-weibo"></i>
                    <span class="sidebar-button-desc">global.weibo</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://stackoverflow.com/users/2662962/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-stack-overflow"></i>
                    <span class="sidebar-button-desc">Stack Overflow</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.instagram.com/yolynn.bird" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-instagram"></i>
                    <span class="sidebar-button-desc">global.instagram</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://dribbble.com/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-dribbble"></i>
                    <span class="sidebar-button-desc">global.dribbble</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="http://yolynn.com/2010/04/22/weixin/"
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-weixin"></i>
                    <span class="sidebar-button-desc">global.weixin</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.zhihu.com/people/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-flickr"></i>
                    <span class="sidebar-button-desc">global.zhihu</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto://zxl20zxl@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/08/10/ios_thread/">
                            iOS多线程基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-08-10T18:15:02+08:00">
	
		    Aug 10, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习iOS多线程需要会什么？">学习iOS多线程需要会什么？</h2><p>进程是系统中并发执行的基本单位，线程是进程中执行运算的最小单位。</p>
<h2 id="iOS多线程是什么？">iOS多线程是什么？</h2><h4 id="Pthreads">Pthreads</h4><p>基于C语言，移植性强</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;pthread.h&#62;&#10;pthread_t thread;&#10;pthread_create(&#38;thread, NULL, start, NULL);</span><br></pre></td></tr></table></figure>
<h4 id="NSThread">NSThread</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];&#10;[thread start];</span><br></pre></td></tr></table></figure>
<h4 id="GCD">GCD</h4><h6 id="异步">异步</h6><p>异步和同步最大的区别在于异步不会<strong>阻塞当前线程</strong>，是否等待block完成后返回</p>
<h6 id="队列">队列</h6><ol>
<li>串行队列<ul>
<li>主队列                 dispatch_get_main_queue()</li>
<li>自定义队列            dispatch_queue_create(“私有串行”, DISPATCH_QUEUE_SERIAL)</li>
</ul>
</li>
<li>并行队列<ul>
<li>全局并发队列            dispatch_get_global_queue()</li>
<li>自定义队列            dispatch_queue_create(“私有并行”, DISPATCH_QUEUE_CONCURRENT)</li>
</ul>
</li>
</ol>
<h6 id="任务">任务</h6><ol>
<li>dispatch_sync(queue, block)</li>
<li>dispatch_async(queue, block)</li>
<li>dispatch_barrier_sync(queue, block)<ul>
<li>传入的queue是自定义DISPATCH_QUEUE_CONCURRENT queue</li>
<li>阻塞queue </li>
<li>执行block前的任务后，执行block，解除阻塞</li>
</ul>
</li>
<li>dispatch_barrier_async(queue, block)<ul>
<li>传入的queue是自定义DISPATCH_QUEUE_CONCURRENT queue</li>
<li>阻塞queue </li>
<li>阻塞当前线程</li>
</ul>
</li>
</ol>
<h6 id="队列_+_任务">队列 + 任务</h6><ol>
<li>队列组<ul>
<li>dispatch_group_create()</li>
<li>dispatch_group_async(group, queue, block)</li>
<li>dispatch_group_notify(group, queue, block)</li>
</ul>
</li>
</ol>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/index.html" target="_blank" rel="external">查看更多关于GCD的坑</a></p>
<h4 id="NSOperation_&amp;_NSOperationQueue">NSOperation &amp; NSOperationQueue</h4><p>是对GCD更高一层的封装</p>
<h6 id="NSOperation">NSOperation</h6><ol>
<li>NSInvocationOperation </li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];&#10;[operation start];</span><br></pre></td></tr></table></figure>
<ol>
<li>NSBlockOperation</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;      NSLog(@&#34;%@&#34;, [NSThread currentThread]);&#10;  &#125;];&#10;  &#10;//&#28155;&#21152;&#22810;&#20010;Block&#65292;&#25903;&#25345;&#22810;&#32447;&#31243;&#10;for (NSInteger i = 0; i &#60; 5; i++) &#123;&#10;&#9;[operation addExecutionBlock:^&#123;&#10;&#9;NSLog(@&#34;&#31532;%ld&#27425;&#65306;%@&#34;, i, [NSThread currentThread]);&#10;&#9;&#125;];&#10;&#125;&#10;&#10;[operation start];</span><br></pre></td></tr></table></figure>
<h6 id="NSOperationQueue">NSOperationQueue</h6><ol>
<li>主队列<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>其它队列</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//1.&#21019;&#24314;&#19968;&#20010;&#20854;&#20182;&#38431;&#21015;    &#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];&#10;&#10;//2.&#21019;&#24314;NSBlockOperation&#23545;&#35937;&#10;NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;%@&#34;, [NSThread currentThread]);&#10;&#125;];&#10;&#10;//3.&#28155;&#21152;&#22810;&#20010;Block&#10;for (NSInteger i = 0; i &#60; 5; i++) &#123;&#10;    [operation addExecutionBlock:^&#123;&#10;        NSLog(@&#34;&#31532;%ld&#27425;&#65306;%@&#34;, i, [NSThread currentThread]);&#10;    &#125;];&#10;&#125;&#10;&#10;//4.&#38431;&#21015;&#28155;&#21152;&#20219;&#21153;&#10;[queue addOperation:operation];</span><br></pre></td></tr></table></figure>
<ol>
<li>maxConcurrentOperationCount 最大并发数</li>
<li>任务依赖</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//1.&#20219;&#21153;&#19968;&#65306;&#19979;&#36733;&#22270;&#29255;&#10;NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;&#19979;&#36733;&#22270;&#29255; - %@&#34;, [NSThread currentThread]);&#10;    [NSThread sleepForTimeInterval:1.0];&#10;&#125;];&#10;&#10;//2.&#20219;&#21153;&#20108;&#65306;&#25171;&#27700;&#21360;&#10;NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;&#25171;&#27700;&#21360;   - %@&#34;, [NSThread currentThread]);&#10;    [NSThread sleepForTimeInterval:1.0];&#10;&#125;];&#10;&#10;//3.&#20219;&#21153;&#19977;&#65306;&#19978;&#20256;&#22270;&#29255;&#10;NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;&#19978;&#20256;&#22270;&#29255; - %@&#34;, [NSThread currentThread]);&#10;    [NSThread sleepForTimeInterval:1.0];&#10;&#125;];&#10;&#10;//4.&#35774;&#32622;&#20381;&#36182;&#10;[operation2 addDependency:operation1];      //&#20219;&#21153;&#20108;&#20381;&#36182;&#20219;&#21153;&#19968;&#10;[operation3 addDependency:operation2];      //&#20219;&#21153;&#19977;&#20381;&#36182;&#20219;&#21153;&#20108;&#10;&#10;//5.&#21019;&#24314;&#38431;&#21015;&#24182;&#21152;&#20837;&#20219;&#21153;&#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];&#10;[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];</span><br></pre></td></tr></table></figure>
<h2 id="为什么要用iOS多线程？">为什么要用iOS多线程？</h2><ol>
<li>易于调度、提高并发、充分发挥硬件多核优势</li>
</ol>
<h2 id="iOS多线程怎么用？">iOS多线程怎么用？</h2><h4 id="死锁">死锁</h4><h6 id="为什么死锁">为什么死锁</h6><p>使用同步函数添加任务阻塞当前线程，则当前线程任务需等待添加的任务，被添加到队列的任务具有FIFO性质，它也在等待当前线程任务执行，进入相互等待造成死锁。</p>
<h6 id="怎么避免死锁">怎么避免死锁</h6><ol>
<li>同步转异步，释放阻塞</li>
<li>任务添加到并发队列或其它队列</li>
</ol>
<h4 id="线程安全">线程安全</h4><p>多个线程抢占同一资源进行操作，如何避免？</p>
<ol>
<li>@synchronized(self)</li>
<li>dispatch_semaphore<ul>
<li>dispatch_semaphore_create(1)<ul>
<li>dispatch_semaphore_signal </li>
<li>dispatch_semaphore_wait</li>
</ul>
</li>
</ul>
</li>
<li>NSLock</li>
<li>pthread_mutex </li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)runSemaphore &#123;&#10;    &#10;    // 2, dispatch_semaphore&#10;    dispatch_semaphore_t signal = dispatch_semaphore_create(1);&#10;    dispatch_time_t overtime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);&#10;    &#10;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;&#10;        &#10;        dispatch_semaphore_wait(signal, overtime);  //signal value - 1&#10;        NSLog(@&#34;&#25805;&#20316;1&#65292;&#24320;&#22987;&#34;);&#10;        sleep(2);&#10;        NSLog(@&#34;&#25805;&#20316;1&#65292;&#32467;&#26463;&#34;);&#10;        dispatch_semaphore_signal(signal); //signal value + 1&#10;    &#125;);&#10;    &#10;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;&#10;        &#10;        sleep(1);&#10;        dispatch_semaphore_wait(signal, overtime);  //signal value = 0  to  1&#10;        NSLog(@&#34;&#25805;&#20316;2&#65292;&#24320;&#22987;&#34;);&#10;        dispatch_semaphore_signal(signal);  //signal value = 2&#10;    &#125;);&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延迟执行">延迟执行</h4><h6 id="perform">perform</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(run:) withObject:@&#34;abc&#34; afterDelay:3];</span><br></pre></td></tr></table></figure>
<h6 id="GCD-1">GCD</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21019;&#24314;&#38431;&#21015;&#10;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&#10;// &#35774;&#32622;&#24310;&#26102;&#65292;&#21333;&#20301;&#31186;&#10;double delay = 3; &#10;&#10;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^&#123;&#10;    // 3&#31186;&#21518;&#38656;&#35201;&#25191;&#34892;&#30340;&#20219;&#21153;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="NSTimer">NSTimer</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@&#34;abc&#34; repeats:NO];</span><br></pre></td></tr></table></figure>
<h4 id="单例_dispatch_once">单例 dispatch_once</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Tool : NSObject &#60;NSCopying&#62;&#10;&#10;+ (instancetype)sharedTool;&#10;&#10;@end&#10;&#10;@implementation Tool&#10;&#10;static id _instance;&#10;&#10;+ (instancetype)sharedTool &#123;&#10;    static dispatch_once_t onceToken;&#10;    dispatch_once(&#38;onceToken, ^&#123;&#10;        _instance = [[Tool alloc] init];&#10;    &#125;);&#10;&#10;    return _instance;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<h4 id="其它线程回主线程">其它线程回主线程</h4><ul>
<li>NSThread</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br></pre></td></tr></table></figure>
<ul>
<li>GCD</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>NSOperation</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;&#10;&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="iOS多线程的实际应用">iOS多线程的实际应用</h2><h4 id="XX会">XX会</h4><h4 id="X蜂">X蜂</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/08/10/ios_thread/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/07/20/ios_arc_mrc/">
                            iOS内存管理基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-07-20T18:15:02+08:00">
	
		    Jul 20, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习内存管理需要会什么？">学习内存管理需要会什么？</h2><p>思考下，苹果为什么有了MRC又设计ARC？</p>
<p>iOS内存管理模型</p>
<ol>
<li>自动垃圾收集（iOS环境不支持）</li>
<li>手动引用计数和自动释放池（MRC）</li>
<li>自动引用计数（ARC）  </li>
</ol>
<h2 id="内存管理是什么？">内存管理是什么？</h2><h3 id="MRC">MRC</h3><h4 id="引用计数器">引用计数器</h4><ol>
<li>对象被引用的次数，也可说有多少人正在用这个对象</li>
<li>初始化时为1<ul>
<li>创建并持有对象：alloc new copy mutableCopy</li>
<li>持有对象：retain</li>
</ul>
</li>
<li>计数为0时，对象占用的内存被系统回收</li>
</ol>
<h4 id="引用计数器操作">引用计数器操作</h4><ol>
<li>retain +1</li>
<li>release -1</li>
<li>retainCount 显示计数</li>
</ol>
<h4 id="dealloc方法">dealloc方法</h4><ol>
<li>[super dealloc];一定在最后一行</li>
<li>不能直接调用</li>
<li>一旦对象被回收，继续使用会野指针</li>
</ol>
<h4 id="野指针_&amp;_空指针">野指针 &amp; 空指针</h4><ol>
<li>野指针即一个指针指向了“<strong>僵尸对象</strong>（不能再使用的对象）”</li>
<li>给野指针发消息报错：EXC_BAD_ACCESS</li>
<li>避免野指针发消息报错，对象释放后，将指针置为空指针<ul>
<li>空指针即没有指向任何存储空间（存的nil）</li>
<li>向空指针发送消息没有任何反应</li>
</ul>
</li>
</ol>
<h4 id="MRC_单个对象管理">MRC 单个对象管理</h4><ol>
<li>谁创建(alloc copy)，谁release</li>
<li>谁retain, 谁release</li>
</ol>
<h4 id="MRC_多个对象管理">MRC 多个对象管理</h4><p><img src="https://www.processon.com/chart_image/5864740be4b0e069269f1e34.png" alt=""></p>
<ol>
<li>setter方法</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setRoom:(Room *)room &#123;&#10;&#9;// &#21482;&#26377;&#25151;&#38388;&#19981;&#21516;&#26102;&#25165;&#38656;&#35201;release &#21644; retain&#10;&#9;if (_room != room) &#123;&#10;&#9;&#9;// &#23558;&#20197;&#21069;&#30340;&#25151;&#38388;release -1&#10;&#9;&#9;[_room release];&#10;&#9;&#9;&#10;&#9;&#9;_room = [room retain];&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MRC_@property参数">MRC @property参数</h4><ol>
<li>成员变量前加上<strong>@property</strong>，自动生成<strong>基本</strong>的setter/getter</li>
<li>property加上<strong>retain</strong>，自动生成<strong>有内存管理</strong>的setter/getter</li>
<li>property加上<strong>assign</strong>，自动生成基本的setter/getter，<strong>默认</strong>什么都不加就是assign</li>
</ol>
<h4 id="MRC_循环引用">MRC 循环引用</h4><ul>
<li>当两端互相引用时，应该一端用retain，一端用assign</li>
</ul>
<h4 id="autoreleasepool">autoreleasepool</h4><ol>
<li><strong>[p autorelease]</strong> 给p发送一条autorelease消息，将p放到autoreleasepool，在autoreleasepool释放时做一次release操作</li>
<li>autorelease方法返回对象本身，引用计数不会变化</li>
</ol>
<h6 id="autoreleasepool_好处">autoreleasepool 好处</h6><ol>
<li>不用关心释放时间</li>
<li>不用关心什么时候调用release</li>
</ol>
<h6 id="autoreleasepool_原理">autoreleasepool 原理</h6><p>autoreleasepool实际上只是把对release的调用延迟了</p>
<ol>
<li>声明__autoreleasepool时，构造函数<strong>__AtAutoreleasePool()</strong>执行，即<strong>atautoreleasepoolobj = objc_autoreleasePoolPush()</strong></li>
<li>出了当前作用域时，析构函数<strong>~__AtAutoreleasePool()</strong>执行，即<strong>objc_autoreleasePoolPop(atautoreleasepoolobj)</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;&#125;</span><br></pre></td></tr></table></figure>
<p>简化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="comment">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PUSH操作</li>
</ul>
<p>每调用一次 push 操作就会创建一个新的 autoreleasepool ，即往 AutoreleasePoolPage 中插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。</p>
<ul>
<li>Autorelease操作</li>
</ul>
<p>它跟 push 操作的实现非常相似。只不过 push 操作插入的是一个 POOL_SENTINEL ，而 autorelease 操作插入的是一个具体的 autoreleased 对象</p>
<ul>
<li>POP操作</li>
</ul>
<p>pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址，即 pool token 。当执行 pop 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release</p>
<h6 id="autoreleasepool_创建和使用">autoreleasepool 创建和使用</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#26041;&#24335;1&#10;NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];&#10;Person *p = [[[Person alloc] init] autorelease];&#10;[autoreleasePool drain];&#10;&#10;// &#26041;&#24335;2&#10;@autoreleasepool&#10;&#123; // &#21019;&#24314;&#19968;&#20010;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;        Person *p = [[Person new] autorelease];&#10;        // &#23558;&#20195;&#30721;&#20889;&#21040;&#36825;&#37324;&#23601;&#25918;&#20837;&#20102;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;&#125; // &#38144;&#27585;&#33258;&#21160;&#37322;&#25918;&#27744;(&#20250;&#32473;&#27744;&#23376;&#20013;&#25152;&#26377;&#23545;&#35937;&#21457;&#36865;&#19968;&#26465;release&#28040;&#24687;)</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_注意">autoreleasepool 注意</h6><ul>
<li>并不是放到autoreleasepool代码中,都会自动加入到自动释放池</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#10;    // &#22240;&#20026;&#27809;&#26377;&#35843;&#29992; autorelease &#26041;&#27861;,&#25152;&#20197;&#23545;&#35937;&#27809;&#26377;&#21152;&#20837;&#21040;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;    Person *p = [[Person alloc] init];&#10;    [p run];&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>autorelease是一个方法, 只有在autoreleasepool中调用才有效</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#10;&#125;&#10;// &#27809;&#26377;&#19982;&#20043;&#23545;&#24212;&#30340;&#33258;&#21160;&#37322;&#25918;&#27744;, &#21482;&#26377;&#22312;&#33258;&#21160;&#37322;&#25918;&#27744;&#20013;&#35843;&#29992;autorelease&#25165;&#20250;&#25918;&#21040;&#37322;&#25918;&#27744;&#10;Person *p = [[[Person alloc] init] autorelease];&#10;[p run];&#10;&#10;// &#27491;&#30830;&#20889;&#27861;&#10;@autoreleasepool &#123;&#10;    Person *p = [[[Person alloc] init] autorelease];&#10; &#125;&#10;&#10;// &#27491;&#30830;&#20889;&#27861;&#10;Person *p = [[Person alloc] init];&#10;@autoreleasepool &#123;&#10;    [p autorelease];&#10;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_嵌套">autoreleasepool 嵌套</h6><ol>
<li>AutoreleasePool 以 <strong>栈</strong>形式存在</li>
<li>栈只有一个入口，调用autorelease会将对象放到<strong>栈顶的自动释放池</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123; // &#26632;&#24213;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;    @autoreleasepool &#123;&#10;        @autoreleasepool &#123; // &#26632;&#39030;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;            Person *p = [[[Person alloc] init] autorelease];&#10;        &#125;&#10;        Person *p = [[[Person alloc] init] autorelease];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_for循环">autoreleasepool for循环</h6><ol>
<li>尽量避免对大内存使用autorelease</li>
<li>不要把for循环放在@autoreleasepool之间，会造成内存峰值上升</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20869;&#23384;&#26292;&#28072;&#10;@autoreleasepool &#123;&#10;    for (int i = 0; i &#60; 99999; ++i) &#123;&#10;        Person *p = [[[Person alloc] init] autorelease];&#10;    &#125;&#10;&#125;&#10;&#10;// &#20869;&#23384;&#19981;&#20250;&#26292;&#28072;&#10;for (int i = 0; i &#60; 99999; ++i) &#123;&#10;    @autoreleasepool &#123;&#10;        Person *p = [[[Person alloc] init] autorelease];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_错误用法">autoreleasepool 错误用法</h6><ol>
<li>不能连续调用autorelease</li>
<li>调用autorelease后又调用release</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#10; // &#38169;&#35823;&#20889;&#27861;, &#36807;&#24230;&#37322;&#25918;&#10;    Person *p = [[[[Person alloc] init] autorelease] autorelease];&#10; &#125;&#10; &#10; @autoreleasepool &#123;&#10;    Person *p = [[[Person alloc] init] autorelease];&#10;    [p release]; // &#38169;&#35823;&#20889;&#27861;, &#36807;&#24230;&#37322;&#25918;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ARC">ARC</h3><ol>
<li>Automatic Reference Counting，自动引用计数，自iOS5 LLVM3.0引入</li>
<li>解决了广大iOS开发者所憎恨的手动内存管理的麻烦</li>
<li>通过生成正确的代码去自动释放或者保持对象，我们完全不用担心编译器会出错</li>
</ol>
<h4 id="ARC_判断是否需要释放">ARC 判断是否需要释放</h4><p>只要还有一个强指针指向对象，对象就会保存在内存中</p>
<ol>
<li>强指针  被__strong修饰</li>
<li>弱指针  被__weak修饰</li>
</ol>
<h4 id="ARC_注意">ARC 注意</h4><ol>
<li>不能调用release</li>
<li>不能调用autorelease</li>
<li>不能调用[super dealloc]</li>
</ol>
<h4 id="ARC_单个对象管理">ARC 单个对象管理</h4><ul>
<li>局部变量释放，对象随之释放</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        Person *p = [[Person alloc] init];&#10;    &#125; // &#25191;&#34892;&#21040;&#36825;&#19968;&#34892;&#23616;&#37096;&#21464;&#37327;p&#37322;&#25918;&#10;    // &#30001;&#20110;&#27809;&#26377;&#24378;&#25351;&#38024;&#25351;&#21521;&#23545;&#35937;, &#25152;&#20197;&#23545;&#35937;&#20063;&#37322;&#25918;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空指针，对象随之释放</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        Person *p = [[Person alloc] init];&#10;        p = nil; // &#25191;&#34892;&#21040;&#36825;&#19968;&#34892;, &#30001;&#20110;&#27809;&#26377;&#24378;&#25351;&#38024;&#25351;&#21521;&#23545;&#35937;, &#25152;&#20197;&#23545;&#35937;&#34987;&#37322;&#25918;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认清空所有指针都是强指针</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        // p1&#21644;p2&#37117;&#26159;&#24378;&#25351;&#38024;&#10;        Person *p1 = [[Person alloc] init];&#10;        __strong Person *p2 = [[Person alloc] init];&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>弱指针需要明确说明（<strong>千万不要使用弱指针保存新创建的对象</strong>）</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        // p&#26159;&#24369;&#25351;&#38024;, &#23545;&#35937;&#20250;&#34987;&#31435;&#21363;&#37322;&#25918;&#10;        __weak Person *p1 = [[Person alloc] init];&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ARC_多个对象管理">ARC 多个对象管理</h4><ul>
<li>ARC和MRC一样，想拥有某个对象需要用强指针指向，但是不需要调用dealloc中release</li>
</ul>
<h4 id="ARC_@property">ARC @property</h4><ul>
<li>strong : 用于OC对象，相当于MRC中的retain</li>
<li>weak : 用于OC对象，相当于MRC中的assign</li>
<li>assign : 用于基本数据类型，跟MRC中的assign一样</li>
</ul>
<h4 id="ARC_循环引用">ARC 循环引用</h4><ul>
<li>A拥有B，B也拥有A，那么必须一方使用弱指针</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&#10;@property (nonatomic, strong) Dog *dog;&#10;@end&#10;&#10;@interface Dog : NSObject&#10;// &#38169;&#35823;&#20889;&#27861;, &#24490;&#29615;&#24341;&#29992;&#20250;&#23548;&#33268;&#20869;&#23384;&#27844;&#38706;&#10;//@property (nonatomic, strong) Person *owner;&#10;&#10;// &#27491;&#30830;&#20889;&#27861;, &#24403;&#22914;&#26524;&#20445;&#23384;&#23545;&#35937;&#24314;&#35758;&#20351;&#29992;weak&#10;@property (nonatomic, weak) Person *owner;&#10;@end</span><br></pre></td></tr></table></figure>
<h2 id="为什么用内存管理?">为什么用内存管理?</h2><h4 id="NSThread_&amp;_NSRunLoop_&amp;_NSAutoreleasePool">NSThread &amp; NSRunLoop &amp; NSAutoreleasePool</h4><ol>
<li>每个线程（包括主线程）都拥有一个专属的NSRunLoop，并在需要时自动创建</li>
<li>主线程的NSRunLoop对象（包括系统级别的其它线程）的每个event loop开始前，自动创建一个autoreleasepool，并在event loop结束时drain</li>
<li>每个autoreleasepool对应且只对应一个线程</li>
</ol>
<h2 id="内存管理怎么用？">内存管理怎么用？</h2><p>这些情况需要手动添加autoreleasepool：</p>
<ol>
<li>编写的程序不是基于UI框架的，比如命令行工具</li>
<li>编写的循环中创建了大量的临时对象  </li>
<li>创建了一个辅助线程</li>
</ol>
<h2 id="内存管理实际应用">内存管理实际应用</h2><h4 id="项目">项目</h4><ol>
<li>YYKit ：解决循环中创建的大量临时对象</li>
<li>AFNetworking： 创建了辅助线程</li>
<li>XX会 混编时， 标注MRC文件：-fno-objc-arc</li>
</ol>
<h4 id="ARC_实例">ARC 实例</h4><ol>
<li>ARC想要主动释放，最好是提前置为nil</li>
<li>ARC下获取引用计数<ul>
<li>KVC  [obj valueForKey:@”retainCount”] </li>
<li>私有API _objc_rootRetainCount(obj)</li>
<li>CFGetRetainCount((__bridge CFTypeRef)(obj))</li>
</ul>
</li>
</ol>
<h4 id="MRC_实例">MRC 实例</h4><ol>
<li>下面这种情况会报错吗？（注意计算retainCount）</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	YLAutorelease *obj = [[YLAutorelease alloc] init];      <span class="comment">//1</span></span><br><span class="line">    _tableView = [[<span class="built_in">UITableView</span> alloc] init];                <span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj retainCount:%ld"</span>, [obj retainCount]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView retainCount:%ld"</span>, [_tableView retainCount]);</span><br><span class="line">    </span><br><span class="line">    [obj performSelector:<span class="keyword">@selector</span>(test) withObject:_tableView afterDelay:<span class="number">1</span>];   <span class="comment">//obj 2 , tableView 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj retainCount:%ld"</span>, [obj retainCount]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView retainCount:%ld"</span>, [_tableView retainCount]);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [obj release];</span></span><br><span class="line"><span class="comment">//    [_tableView release];</span></span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:obj selector:<span class="keyword">@selector</span>(test) object:_tableView];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj retainCount:%ld"</span>, [obj retainCount]);       <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView retainCount:%ld"</span>, [_tableView retainCount]);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>NSString的引用计数是随机值，NSMutableString的引用计数是正常值</p>
<ul>
<li>NSString的class是__NSCFConstantString，字符串常量</li>
<li>NSMutableString的class是__NSCFString，有引用计数</li>
</ul>
</li>
<li><p>对于字符串常量、NSNumber做常量时？</p>
<ul>
<li>retain 和 release都不会有影响，因为系统不会回收，也不会对其做引用计数</li>
</ul>
</li>
<li><p>stringWithFormat创建的string？</p>
<ul>
<li>为变量，所以会有引用计数</li>
<li>现在返回的已经是常量，见后面的例子</li>
</ul>
</li>
<li><p>stringWithString创建的string?</p>
<ul>
<li>取决于它后面的string对象，如果是常量则不做计数，如果是变量则做计数</li>
</ul>
</li>
<li><p>除了alloc new copy mutableCopy retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？</p>
<ul>
<li>容器类array、dic addObject；release时，里面的成员都会release一次，和autorelease pool一致</li>
<li>addsubview, 因为view有栈(subviews)，加入栈中retainCount+1</li>
<li>navcontroller的push, 因为nav有栈(viewcontrollers)，加入栈中retainCount+1</li>
<li>performSelector 调用时target和info都会加1，结束时减1</li>
</ul>
</li>
<li><p>苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。</p>
</li>
<li><p>几个copy, mutableCopy的例子</p>
</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">   <span class="built_in">NSMutableString</span> *str = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSMutableString</span> *str2 = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//1,1</span></span><br><span class="line">   </span><br><span class="line">   str2 = [str <span class="keyword">copy</span>];         <span class="comment">//copy返回一个不可变对象属于常量</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//1,-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]); <span class="comment">//-1,-1</span></span><br><span class="line"></span><br><span class="line">str2 = [str <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//-1,-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"abc%@"</span>, <span class="string">@"hehe"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"bbc%@"</span>, <span class="string">@"hehe"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]); <span class="comment">//-1,-1</span></span><br><span class="line"></span><br><span class="line">str2 = [str mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//-1,1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>block内存管理，详见后续文章</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/07/20/ios_arc_mrc/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/20/c_pointer/">
                            指针基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-20T18:15:02+08:00">
	
		    Jun 20, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习指针需要会什么？">学习指针需要会什么？</h2><p>如何完全理解一个复杂类型，记住一条原则：</p>
<ul>
<li>从<strong>变量名</strong>处起，根据<strong>运算符优先级</strong>结合，一步一步分析</li>
</ul>
<p>举几个🌰：</p>
<ol>
<li>int p;    <ul>
<li>从p开始，先与int结合，说明p是<strong>整型变量</strong></li>
</ul>
</li>
<li>int *p;    <ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>，</li>
<li>再与int结合，说明<strong>指针指向int型</strong>，</li>
<li>所以p是返回int型数据的指针</li>
</ul>
</li>
<li>int p[3];<ul>
<li>从p开始，先与[]结合，说明p是<strong>数组</strong>，</li>
<li>再与int结合，说明<strong>[]里面是int型</strong>,</li>
<li>所以p是返回int型数据的数组</li>
</ul>
</li>
<li>int *p[3];<ul>
<li>从p开始，先与[]结合，说明p是<strong>数组</strong>，</li>
<li>再与*结合，说明<strong>[]里面是指针型</strong>，</li>
<li>再与int结合，说明<strong>指针指向内容是int型</strong>，</li>
<li>所以p是由返回int型数据的指针组成的数组</li>
</ul>
</li>
<li>int (*p)[3];<ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>，</li>
<li>再与[]结合，说明<strong>指针指向[]型</strong>，</li>
<li>再与int结合，说明<strong>[]里是int型</strong>，</li>
<li>所以p是指向由int型数据组成的数组的指针</li>
</ul>
</li>
<li>int **p;<ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>，</li>
<li>再与*结合，说明<strong>指针指向指针型</strong>，</li>
<li>再与int结合，说明<strong>二级指针指向int型</strong>,</li>
<li>所以p是二级指针</li>
</ul>
</li>
<li>int p(int);<ul>
<li>从p开始，先与()结合，说明p是<strong>函数</strong>，</li>
<li>分析()里面，函数有一个<strong>int型参数</strong>,</li>
<li>再与int结合，函数<strong>返回类型是int</strong></li>
</ul>
</li>
<li>int (*p)(int);<ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>,</li>
<li>再与()结合，说明<strong>指针指向函数</strong>，</li>
<li>分析()里面，函数有一个<strong>int型参数</strong>,</li>
<li>再与int结合，函数<strong>返回类型是int</strong>,</li>
<li>所以p是指向有一个整型参数且返回类型为整数的函数的指针</li>
</ul>
</li>
<li>int *(*p(int))[3];<ul>
<li>从p开始，先与()结合，说明p是一个<strong>函数</strong>,</li>
<li>分析()里面，函数有一个<strong>int型参数</strong>，</li>
<li>再与*结合，函数<strong>返回类型是指针</strong>，</li>
<li>再与[]结合，说明返回的<strong>指针指向[]</strong>,</li>
<li>再与*结合，说明<strong>[]里是指针</strong>，</li>
<li>再与int结合，说明指针<strong>指向的是int型</strong>，</li>
<li>所以p是一个参数为一个int型且返回一个指向整型指针变量组成的数组的指针变量的函数</li>
</ul>
</li>
</ol>
<h2 id="指针是什么？">指针是什么？</h2><p>指针是一个特殊的变量，它存储的数值被解释成内存里的一个地址</p>
<p>先声明几个指针🌰：</p>
<ol>
<li>int *ptr;</li>
<li>char *ptr;</li>
<li>int **ptr;</li>
<li>int (*ptr)[3];</li>
<li>int *(*ptr)[4] </li>
</ol>
<h4 id="指针的类型">指针的类型</h4><p>把指针名字去掉，剩下部分就是指针类型</p>
<h4 id="指向的类型">指向的类型</h4><p>把指针名和名字左边的*去掉，剩下部分就是指针指向的类型</p>
<ul>
<li>指针的类型（指针本身的类型）和指针指向的类型是<strong>两个概念</strong></li>
</ul>
<h4 id="指针的值_—_或叫指针指向的内存区">指针的值 — 或叫指针指向的内存区</h4><p>在32位操作系统里，指针都是一个32位整数，指针指向的内存区就是从指针的值代表的那个<strong>内存地址开始</strong>，长度为<strong>sizeof(指针指向的类型)</strong>的一片内存区</p>
<ul>
<li>我们说一个指针的值是XX，相当于说指针指向了以XX为首地址的一片内存区域</li>
<li>我们说一个指针指向了某块内存区域，相当于说指针的值是这块内存区域的首地址</li>
</ul>
<h4 id="指针本身占据的内存区域">指针本身占据的内存区域</h4><p><strong>sizeof(指针的类型)</strong>，32位系统里，指针占据4个字节</p>
<h2 id="为什么用指针？">为什么用指针？</h2><p>C语言的精华和唯一的难点就是指针，搞定指针等于搞定了C语言</p>
<p>指针 -&gt; C语言 -&gt; C++ -&gt; 数据结构 -&gt; 算法 -&gt; 范型编程与STL和STL源码剖析</p>
<h2 id="指针怎么用？">指针怎么用？</h2><h4 id="指针的算术运算">指针的算术运算</h4><p>指针可以加上或减去一个整数</p>
<ul>
<li>和数值的加减运算不一样，以单元为单位</li>
<li>两个指针不能进行加法运算，得到的结果不知道指向何处</li>
<li>两个指针可以进行减法运算，但是类型必须相同，一般用于数组</li>
</ul>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)a;  <span class="comment">//强制类型转换不会改变a的类型</span></span><br><span class="line">ptr++;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">指针ptr加了<span class="number">1</span>，编译器处理：ptr的值加上了<span class="keyword">sizeof</span>(<span class="keyword">int</span>)，在<span class="number">32</span>位程序里，是加了<span class="number">4</span>，因为<span class="keyword">int</span>占据<span class="number">4</span>个字节。</span><br><span class="line"></span><br><span class="line">🌰<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">	(*ptr)++;</span><br><span class="line">	ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个单元的值加1，每次循环都将指针ptr加1个单元，所以每次循环都能访问到下一个单元。</p>
<h4 id="运算符_&amp;_和_*">运算符 &amp; 和 *</h4><p>&amp;是取地址运算符，*是间接运算符</p>
<ul>
<li>&amp;a的运算结果是一个指针，指针的类型是a的类型加个*，指针指向的类型是a的类型，指针指向的地址是a的地址</li>
<li><em>p的结果五花八门，\</em>p的结果是p所指向的东西，这个东西的特点：它的类型是p指向的类型，它占用的地址是p指向的地址</li>
</ul>
<p>🌰1： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">int</span> b; <span class="keyword">int</span> *p; <span class="keyword">int</span> **ptr;</span><br><span class="line"></span><br><span class="line">p = &amp;a; <span class="comment">//&amp;a的结果是一个指针，类型是int *, 指向的类型是int, 指向的地址是a的地址</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">24</span>; <span class="comment">//*p的结果，它的类型是int，它占用的地址是p指向的地址，*p就是变量a</span></span><br><span class="line"></span><br><span class="line">ptr = &amp;p; <span class="comment">//&amp;p的结果是指针，类型是p的类型加个*，这里是int **，该指针指向的类型是p的类型，这里是int *，该指针所指向的地址就是指针 p 自己的地址</span></span><br><span class="line"></span><br><span class="line">*ptr = &amp;b; <span class="comment">//*ptr 是个指针,&amp;b 的结果也是个指针,且这两个指针的类型和所指向的类型是一样的,所以用&amp;b 来给*ptr 赋值就是毫无问题的了</span></span><br><span class="line"></span><br><span class="line">**ptr = <span class="number">34</span>; <span class="comment">//*ptr 的结果是 ptr 所指向的东西,在这里是一个指针, 对这个指针再做一次*运算,结果是一个 int 类型的变量。</span></span><br></pre></td></tr></table></figure>
<h4 id="指针表达式">指针表达式</h4><p>一个表达式的结果是指针，即指针表达式</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *pa;</span><br><span class="line">pa = &amp;a;				<span class="comment">//&amp;a</span></span><br><span class="line"><span class="keyword">int</span> **ptr = &amp;pa;    <span class="comment">//&amp;pa</span></span><br><span class="line">*ptr = &amp;b;          <span class="comment">//*ptr 和 &amp;b </span></span><br><span class="line">pa = <span class="built_in">array</span>;</span><br><span class="line">pa++;					<span class="comment">//pa</span></span><br></pre></td></tr></table></figure>
<p>当一个指针表达式的结果指针已经明确地具有了指针自身占 据的内存的话,这个指针表达式就是一个左值,否则就不是一个左值</p>
<h4 id="指针和数组">指针和数组</h4><p>数组名可以看作一个指针</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intarray[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,value;value=<span class="built_in">array</span>[<span class="number">0</span>];		<span class="comment">//可写成： value = *array;</span>value=<span class="built_in">array</span>[<span class="number">3</span>];		<span class="comment">//可写成：	value = *(array+3);</span>value=<span class="built_in">array</span>[<span class="number">4</span>];		<span class="comment">//可写成： value = *(array+4);</span></span><br></pre></td></tr></table></figure>
<p>数组名array代表数组本身，类型是int[10]，如果把array看作指针，它指向数组的第0个单元，类型是int <em>， 所指向的类型是是数组单元的类型即int，因此\</em>array 等于 0 就一点也不 奇怪了。同理,array+3 是一个指向数组第 3 个单元的指针,所以 *(array+3)等于 3。其它依此类推</p>
<h4 id="指针和结构类型">指针和结构类型</h4><p>可以声明一个指向结构类对象的指针</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyStruct &#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct ss = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct *ptr = &amp;ss;  <span class="comment">//声明一个指向结构对象ss的指针，它的类型是MyStruct *，它指向的类型是MyStruct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pstr = (<span class="keyword">int</span> *)&amp;ss; <span class="comment">//声明一个指向结构对象ss的指针，但是pstr和它被指向的类型ptr是不同的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ptr 来访问 ss 的三个成员变量</span></span><br><span class="line">ptr-&gt;a;  <span class="comment">//指向运算符</span></span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  pstr 来访问 ss 的三个成员变量</span></span><br><span class="line">*pstr;</span><br><span class="line">*(pstr + <span class="number">1</span>);</span><br><span class="line">*(pstr + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="指针和函数">指针和函数</h4><p>可以声明一个指向函数的指针</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*pfun1)(<span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">pfun1 = fun1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = (*pfun1)(<span class="string">"abcdefg"</span>, <span class="number">7</span>);  <span class="comment">//通过函数指针调用函数</span></span><br></pre></td></tr></table></figure>
<p>指针作为函数的形参，函数调用中，用指针表达式来作为实参</p>
<h4 id="指针类型转换">指针类型转换</h4><p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> *fptr = &amp;f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想让指针 p 指向实数 f</span></span><br><span class="line">p=&amp;f; <span class="comment">//不对。因为指针 p 的类型是 int *,它指向的类型是 int</span></span><br><span class="line"></span><br><span class="line">p=(<span class="keyword">int</span>*)&amp;f; <span class="comment">// 如果有一个指针 p,我们需要把它的类型和所指向的类型改为</span>TYEP *TYPE, 那么语法格式是: (TYPE *)p;</span><br></pre></td></tr></table></figure>
<p>强制类型转换的结果是一个新指针,该新指针的类型是TYPE *,它指向的类型是 TYPE,它指向的地址就是原指针指向的地址。 <strong>而原来的指针 p 的一切属性都没有被修改。(切记)</strong></p>
<h4 id="指针的安全问题">指针的安全问题</h4><ol>
<li>指针访问数组时，不要超过数组低端和高端的界限</li>
<li>强制类型转换ptr1 = (TYPE *)ptr2中，如果sizeof(prt2的类型)大于sizeof(ptr1的类型)，那么使用指针ptr1访问ptr2所指向的存储区域是安全的</li>
</ol>
<h2 id="指针的实际应用">指针的实际应用</h2><h4 id="XX会">XX会</h4><h4 id="XX仓">XX仓</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/06/20/c_pointer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/17/c3p0/">
                            C3P0的两种用法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-17T18:15:02+08:00">
	
		    Jun 17, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="background">background</h6><blockquote>
<p>这篇文章摘抄自我的新浪博客，<a href="http://blog.sina.com.cn/s/blog_6c5f4d3c01012gtq.html" target="_blank" rel="external">详情链接</a> 因为它一度为我的新浪博客积累超过7万的人气，新浪博客已经远不如曾经，所以我想把这篇文章保留下来，以下是原文</p>
</blockquote>
<h6 id="方法一：">方法一：</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package   C3P0; </span><br><span class="line">import   java.sql.Connection; </span><br><span class="line">import   java.sql.SQLException; </span><br><span class="line">import   java.beans.PropertyVetoException; </span><br><span class="line">import   com.mchange.v2.c3p0.ComboPooledDataSource; </span><br><span class="line">public   class   DBPool&#123;       </span><br><span class="line">   private   static   DBPool   dbPool;       </span><br><span class="line">   private   ComboPooledDataSource   dataSource;     </span><br><span class="line">	</span><br><span class="line">   static   &#123;       </span><br><span class="line">           dbPool=new   DBPool();       </span><br><span class="line">   &#125;       </span><br><span class="line">   </span><br><span class="line">   public   DBPool()&#123;       </span><br><span class="line">           try   &#123;       </span><br><span class="line">                   dataSource=new   ComboPooledDataSource();       </span><br><span class="line">                   dataSource.setUser( "id ");       </span><br><span class="line">                   dataSource.setPassword( "pw ");       </span><br><span class="line">                   dataSource.setJdbcUrl( "jdbc:mysql://127.0.0.1:3306/test? </span><br><span class="line">	</span><br><span class="line">autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=GB2312 "); </span><br><span class="line">                   dataSource.setDriverClass( "com.mysql.jdbc.Driver "); </span><br><span class="line">                   dataSource.setInitialPoolSize(2); </span><br><span class="line">                   dataSource.setMinPoolSize(1); </span><br><span class="line">                   dataSource.setMaxPoolSize(10); </span><br><span class="line">                   dataSource.setMaxStatements(50); </span><br><span class="line">                   dataSource.setMaxIdleTime(60);       </span><br><span class="line">           &#125;   catch   (PropertyVetoException   e)   &#123;       </span><br><span class="line">               throw   new   RuntimeException(e);       </span><br><span class="line">           &#125;       </span><br><span class="line">   &#125;       </span><br><span class="line">	</span><br><span class="line">   public   final   static   DBPool   getInstance()&#123;       </span><br><span class="line">           return   dbPool;       </span><br><span class="line">   &#125;       </span><br><span class="line">	</span><br><span class="line">   public   final   Connection   getConnection()   &#123;       </span><br><span class="line">           try   &#123;       </span><br><span class="line">                   return   dataSource.getConnection();       </span><br><span class="line">           &#125;   catch   (SQLException   e)   &#123;       </span><br><span class="line">                   throw   new   RuntimeException( "无法从数据源获取连接 ",e);       </span><br><span class="line">           &#125;       </span><br><span class="line">   &#125;     </span><br><span class="line">   </span><br><span class="line">   public   static   void   main(String[]   args)   throws   SQLException   &#123; </span><br><span class="line">Connection   con   =   null; </span><br><span class="line">try   &#123; </span><br><span class="line">con   =   DBPool.getInstance().getConnection(); </span><br><span class="line">&#125;   catch   (Exception   e)&#123; </span><br><span class="line">&#125;   finally   &#123; </span><br><span class="line">if   (con   !=   null) </span><br><span class="line">con.close(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="方法二：">方法二：</h6><pre><code>原来不知道使用c3p0 是如此的简单，我一直使用<span class="keyword">properties</span> 文件去配置c3p0，但总是连接不上数据库，后来调试才发现ComboPooledDataSource 这个对象的属性没有被设置成功，我是先获取了<span class="keyword">properties</span>文件的内容，封装在一个 Properties对象里面，然后直接调用 ComboPooledDataSource 的 setProperties（Properties  p） 方法来配置c3p0，程序是没有报错，但连不上数据库，调试发现属性都没有设置成功，只是<span class="keyword">properties</span>这个属性被设置了而已，结果我对每个属性调用set方法后就连接上了。。。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ConnectionManager instance;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> ComboPooledDataSource ds;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> String c3p0Properties = <span class="string">"c3p0.properties"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">ConnectionManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">  p.load(<span class="keyword">this</span>.getClass().getResourceAsStream(c3p0Properties));</span><br><span class="line">  ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">  ds.setUser(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setPassword(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setJdbcUrl(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setDriverClass(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setInitialPoolSize(Integer.parseInt(p.getProperty(<span class="string">"initialPoolSize"</span>)));</span><br><span class="line">  ds.setMinPoolSize(Integer.parseInt(p.getProperty(<span class="string">"minPoolSize"</span>)));</span><br><span class="line">  ds.setMaxPoolSize(Integer.parseInt(p.getProperty(<span class="string">"maxPoolSize"</span>)));</span><br><span class="line">  ds.setMaxStatements(Integer.parseInt(p.getProperty(<span class="string">"maxStatements"</span>)));</span><br><span class="line">  ds.setMaxIdleTime(Integer.parseInt(p.getProperty(<span class="string">"maxIdleTime"</span>)));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  DataSources.destroy(ds); <span class="comment">// 关闭datasource</span></span><br><span class="line">  <span class="keyword">super</span>.finalize();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>如此就可以获取connection来做jdbc操作了：
Connection         
conn=ConnectionManager.getInstance().getConnection()<span class="comment">;</span>
记得使用完后调用close方法：
conn.close()<span class="comment">;</span>
c3p0 的某些参数的配置以及意义见另外一篇文章http://kangzye.blog.163.com/blog/static/<span class="number">3681922320104</span><span class="number">42162576</span>/
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/06/17/c3p0/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/ ">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-number">page 2 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 yolynn. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.png"/>
        
            <h4 id="about-card-name">yolynn</h4>
        
            <h5 id="about-card-bio"><p>云在青天水在瓶</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>vip.com</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/jquery.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/assets/js/tranquilpeak.js" type="text/javascript"></script>
<!--SCRIPTS END-->



</html>
