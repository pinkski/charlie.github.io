
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="yolynn">
    <title>yolynn</title>
    <meta name="author" content="yolynn">
    
    
        <link rel="icon" href="http://yolynn.com/assets/images/head.png">
    
    
    <meta name="description" content="云在青天水在瓶 - 幽灵鸟">
<meta property="og:type" content="blog">
<meta property="og:title" content="yolynn">
<meta property="og:url" content="http://yolynn.com/page/4/index.html">
<meta property="og:site_name" content="yolynn">
<meta property="og:description" content="云在青天水在瓶 - 幽灵鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yolynn">
<meta name="twitter:description" content="云在青天水在瓶 - 幽灵鸟">
    
    
        
    
    
        <meta property="og:image" content="http://yolynn.com/assets/images/head.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">yolynn</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="/#about">
        
        
            <i class="fa fa-lg fa-head.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/head.png"/>
            </a>
            <span class="sidebar-profile-name">yolynn</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/yolynn-bird" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://weibo.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-weibo"></i>
                    <span class="sidebar-button-desc">global.weibo</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://stackoverflow.com/users/2662962/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-stack-overflow"></i>
                    <span class="sidebar-button-desc">Stack Overflow</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://twitter.com/zxl20zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                    <span class="sidebar-button-desc">Twitter</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.instagram.com/yolynn.zxl" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-instagram"></i>
                    <span class="sidebar-button-desc">global.instagram</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://dribbble.com/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-dribbble"></i>
                    <span class="sidebar-button-desc">global.dribbble</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="http://yolynn.com/2010/04/22/weixin/"
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-weixin"></i>
                    <span class="sidebar-button-desc">global.weixin</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://www.zhihu.com/people/yolynn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-flickr"></i>
                    <span class="sidebar-button-desc">global.zhihu</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto://zxl20zxl@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/10/20/algorithm_01/">
                            数据结构基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-10-20T18:15:02+08:00">
	
		    Oct 20, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h4 id="学习数据结构需要会什么？">学习数据结构需要会什么？</h4><p>数据结构是以某种形式将数据组织在一起的集合，还包括数据的增删改查，你需要了解的专业术语有：</p>
<ul>
<li>树相关称呼，举个🌰：父节点、叶子节点、深度[根节点到底层]、度[子节点的个数]</li>
<li>链表相关称呼，举个🌰：首结点、尾结点、头指针、尾指针</li>
</ul>
<h4 id="数据结构是什么？">数据结构是什么？</h4><p>我把数据结构狭义的分为两大类：</p>
<h6 id="线性结构(所有结点用一根线串起来)">线性结构(所有结点用一根线串起来)</h6><ol>
<li>连续存储[数组]<ul>
<li>空间复杂度大，时间复杂度O(1)，寻址容易，增删难</li>
</ul>
</li>
<li>离散存储[链表]<ul>
<li>空间复杂度小，时间复杂度O(N)，寻址困难，增删易</li>
</ul>
</li>
<li>数组 VS 链表<br><img src="https://www.processon.com/chart_image/585ba403e4b02e6c0ab4964b.png" alt=""></li>
<li>哈希表[key-value]<ul>
<li>依赖哈希算法存储，拥有<strong>数组查询快</strong>和<strong>链表增删改快</strong>的优势</li>
<li>散列函数 -&gt; 散列地址</li>
<li>散列冲突：不同的key计算后获得了相同的散列地址<br><img src="https://www.processon.com/chart_image/585ba265e4b03a03b1957008.png" alt=""><br>“拉链法”实现哈希表：左边是数组，数组中的指针指向一个链表的头。</li>
</ul>
</li>
</ol>
<h6 id="非线性结构">非线性结构</h6><ol>
<li>树<ul>
<li>一般树</li>
<li>二叉树<ul>
<li>前中后序遍历(根节点位置)</li>
<li>满二叉树：达到<strong>节点最大值</strong> </li>
<li>完全二叉树：除了<strong>深度h层</strong>，其它层都达到<strong>节点最大值</strong></li>
<li>二叉查找(排序)树：空树 或 左子树节点小于等于根节点值，右子树节点大于等于根节点值 </li>
<li>平衡二叉树：左右子树<strong>高度差绝对值不超过1</strong></li>
</ul>
</li>
<li>森林</li>
</ul>
</li>
<li>图</li>
</ol>
<h4 id="为什么要用数据结构？">为什么要用数据结构？</h4><p><img src="https://www.processon.com/chart_image/585bae3fe4b03a03b1965777.png" alt=""></p>
<h4 id="数据结构怎么用？">数据结构怎么用？</h4><p>基于数组和链表实现的常用数据结构：</p>
<ol>
<li>栈[先进后出] </li>
<li>队列[先进先出]</li>
<li>ArrayList(数组)   LinkedList(双向链表)</li>
</ol>
<p>基于哈希表实现的常用数据结构：</p>
<ol>
<li>NSDictionary</li>
<li>HashMap HashSet</li>
<li>哈希的应用<ul>
<li>安全领域的加密算法</li>
<li>哈希表</li>
<li>海量数据处理</li>
</ul>
</li>
</ol>
<h4 id="数据结构的实际应用">数据结构的实际应用</h4><h6 id="XX会">XX会</h6><h6 id="XX蜂">XX蜂</h6>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/10/20/algorithm_01/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/09/22/mvvm_profile/">
                            从Web看Native的MVVM
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-09-22T23:14:02+08:00">
	
		    Sep 22, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="背景">背景</h2><blockquote>
<p>  随着前端技术的在开发工作中的角色越来越重要，需求量也越来越大，那么高效率的框架也应运而生，过去script方式已进化为MVC，现在我们是否应该顺应潮流推动MVC进化到MVVM呢？（MVP）</p>
</blockquote>
<h2 id="介绍">介绍</h2><ol>
<li>web与native的组成对比<ul>
<li>web : html + css + js</li>
<li>android : 四大组件(activity、service、broadcase receiver、content provider)和五大布局(LinearLayout、FrameLayout、RelativeLayout、AbsoluteLayout、TableLayout) 还有 java (data binding library)</li>
<li>iOS : xib/storyboard + oc/swift   </li>
<li>react(react.js、react canvas、react native)  </li>
</ul>
</li>
<li>web前端常用的MVVM主流框架<ul>
<li>handlebars.js、knockout.js、ember.js、avalon.js、angular.js </li>
<li>backbone.js?, react.js?</li>
</ul>
</li>
<li>angularJS的核心功能<ul>
<li>自动化双向数据绑定、模块化/组件化、依赖注入、语义化标签等</li>
</ul>
</li>
<li>angularJS的原理<ul>
<li>首先，浏览器会一直处于监听状态，一旦有事件被触发，就会被加到一个event queue中，event queue中的事件会一个一个的执行。</li>
<li>event queue中的事件如果是被$apply()包起来的话，就会进入到AngularJS的context中，假设的fn()是我们希望在AngularJS的context中执行的函数。</li>
<li>AngularJS将执行fn()函数，通常情况下，这个函数会改变应用的某些状态。</li>
<li>然后AngularJS会进入到由两个小循环组成的digest循环中，一个循环是用来处理evalAsync队列（用来schedule一些需要在渲染视图之前处理的操作，通常通过setTimeout(0)实现，速度会比较慢，可能会出现视图抖动的问题）的，一个循环是处理watch列表（是一些表达式的集合，一旦有改变发生，那么watch函数就会被调用）的。digest循环会一直迭代知道evalAsync队列为空并且$watch列表也为空的时候，即model不再有任何变化。</li>
<li>一旦AngularJS的$digest循环结束，整个执行就会离开AngularJS和Javascript的context，紧接着浏览器就会把数据改变后的视图重新渲染出来。</li>
</ul>
</li>
<li>iOS常用的MVVM框架<ul>
<li>KVO  reactiveCocoa</li>
</ul>
</li>
<li>reactiveCocoa的核心功能<ul>
<li>自动化双向数据绑定、模块化/组件化(?)、依赖注入(无)、语义化标签(?)等</li>
<li>像KVO,但它用blocks代替了重写-observeValueForKeyPath:ofObject:change:context:</li>
<li>提供了一个单一的，统一的方法去处理异步的行为,包括delegate方法,blocks回调,target-action机制,notifications和KVO.</li>
</ul>
</li>
<li>reactiveCocoa的原理<ul>
<li>RACSignal发送事件流给它的subscriber。目前总共有三种类型的事件：next、error、completed。</li>
<li>RACSignal有很多方法可以来订阅不同的事件类型。每个方法都需要至少一个block，当事件发生时就会执行block中的逻辑。</li>
<li>使用category来为很多基本UIKit控件添加signal。这样你就能给控件添加订阅了，text field的rac_textSignal就是这么来的。</li>
</ul>
</li>
<li>angularJS与reactiveCocoa的对比<ul>
<li>核心功能对比</li>
<li>实现原理对比</li>
<li>实际运用对比</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2><blockquote>
<p>MVVM是未来</p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/09/22/mvvm_profile/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/08/20/ios_thirdparty/">
                            iOS三方库源码基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-08-20T18:15:02+08:00">
	
		    Aug 20, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习iOS三方库源码需要会什么？">学习iOS三方库源码需要会什么？</h2><p>Github开源库何其多？第三方SDK何其多？要做到识别好的，吸收精华，取其思想，再结合实际形成自己的思想或方案</p>
<h2 id="iOS三方库源码是什么？">iOS三方库源码是什么？</h2><p>列一些经典三方库，并阐述其中心思想</p>
<h4 id="小工具">小工具</h4><h6 id="MLeaksFinder">MLeaksFinder</h6><ol>
<li>给UIApplication添加Category <strong>UIApplication+MemoryLeak</strong></li>
<li>hook系统函数<strong>sendAction:to:from:forEvent:</strong>使用<strong>objc_setAssociatedObject</strong>存储当前类的sender</li>
<li>给NSObject添加Category <strong>NSObject+MemoryLeak</strong></li>
<li><strong>objc_getAssociatedObject</strong>获取当前类的sender</li>
<li>如果当前类的sender不是自己，则可能是有内存泄露发生，打印堆栈信息到控制台</li>
<li><a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="external">MLeaksFinder</a> 内嵌 <a href="https://github.com/facebook/FBRetainCycleDetector/tree/master/FBRetainCycleDetector" target="_blank" rel="external">FBRetainCycleDetector</a></li>
</ol>
<h6 id="FPSLabel">FPSLabel</h6><p>CADisplayLink在屏幕刷新时调用，刷新率通常<strong>60次/秒</strong></p>
<ol>
<li>创建displayLink </li>
<li>添加到RunLoop</li>
<li>tick中用count记录<strong>每秒</strong>调用次数</li>
<li>fps = count / (link.timestamp - lastTime)</li>
<li><a href="https://github.com/yolynn-bird/YLFPSLabel" target="_blank" rel="external">YLFPSLabel</a></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];&#10;[_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<h6 id="野指针检测">野指针检测</h6><ol>
<li>使用fishhook替换系统C库的free函数</li>
<li>将free掉的内存块全部填入0x55，确保源对象被擦除</li>
<li>自行管理free掉的内存块，不立即释放，防止系统分配给其它对象，仅在内存过大时逐步释放</li>
<li>在free掉的内存块首部，填入一个自定义对象Checker，记录原对象类型，接管原对象的所有调用，一旦发现调用，则说明存在野指针</li>
<li><a href="https://github.com/yolynn-bird/YLWildPointerChecker" target="_blank" rel="external">YLWildPointerChecker</a></li>
</ol>
<h4 id="AFNetWorking">AFNetWorking</h4><h6 id="AFNetWorking如何管理线程？">AFNetWorking如何管理线程？</h6><ol>
<li>基于NSURLConnection<ul>
<li>只创建一条线程发起所有请求并阻塞以等待响应</li>
<li>网络请求继承自NSOperation，再加入NSOperationQueue</li>
</ul>
</li>
<li>基于NSURLSession<br> <img src="https://www.processon.com/chart_image/5861da7ce4b02e6c0aee8e68.png" alt=""></li>
</ol>
<h6 id="NSURLSession_VS_NSURLConnection">NSURLSession VS NSURLConnection</h6><ol>
<li>NSURLConnection<ul>
<li>没有提供接口解决多个网络请求对多个线程管理</li>
<li>不是基于HTTP/2，每个请求都要发起三次握手，四次挥手</li>
</ul>
</li>
<li>NSURLSession<ul>
<li>基于HTTP/2</li>
<li>借鉴AFNetworking内部维护两个队列：一个处理session回调，一个处理响应回调</li>
</ul>
</li>
</ol>
<h4 id="SDWebImage">SDWebImage</h4><p><img src="https://www.processon.com/chart_image/5861dce9e4b078015c9fedae.png" alt=""></p>
<h4 id="ReactiveCocoa">ReactiveCocoa</h4><h6 id="思想">思想</h6><p>利用hook(钩子)，hook是一种用于改变API执行结果的技术，每次调用API返回结果之前，先执行你自己的方法，改变结果的输出</p>
<h6 id="核心方法bind">核心方法bind</h6><p>bind属于RAC底层方法，以前的开发方式是<strong>赋值</strong>，而RAC开发方式重心在于<strong>绑定</strong></p>
<h4 id="Mantle">Mantle</h4><h6 id="原理">原理</h6><ol>
<li>runtime动态获取属性类型和名字<ul>
<li>class_copyPropertyList返回一个数组</li>
<li>property_getAttributes</li>
<li>__attribute__机制给方法、变量、类型增加额外的属性</li>
</ul>
</li>
<li>创建对应的对象实例</li>
<li>根据KVC(NSKeyValueCoding协议)来为属性设置值</li>
<li><a href="http://blog.csdn.net/Hello_Hwc/article/details/51548128" target="_blank" rel="external">更多Mantle</a></li>
</ol>
<h4 id="JSPatch">JSPatch</h4><h6 id="原理-1">原理</h6><p>JS传递字符串给OC，OC通过runtime接口调用和替换OC方法</p>
<ol>
<li>runtime通过类名/方法名反射获取相应的类和方法</li>
<li>替换某个类的方法为新的实现</li>
<li>新注册一个类，为类添加方法</li>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">更多JSPatch</a></li>
</ol>
<h4 id="Alamofire">Alamofire</h4><p>基于NSURLSession，也有场景不适用，举个🌰：下载10个文件，支持最大并发2个，NSURLSession的timeoutIntervalForRequest和timeoutIntervalForResource不能满足，需用NSOperationQueque实现</p>
<h6 id="工作流">工作流</h6><p><img src="http://cc.cocimg.com/api/uploads/20151117/1447728266491926.jpg" alt=""></p>
<p><a href="http://www.cocoachina.com/ios/20151117/14240.html" target="_blank" rel="external">更多Alamofire</a></p>
<h2 id="为什么用iOS三方库？">为什么用iOS三方库？</h2><h4 id="组件化，代码复用">组件化，代码复用</h4><h4 id="特殊复杂功能">特殊复杂功能</h4><h2 id="iOS三方库怎么用？">iOS三方库怎么用？</h2><h4 id="SDK">SDK</h4><h6 id="静态库_-a">静态库 .a</h6><h6 id="类库_-framework">类库 .framework</h6><h6 id="资源文件_-bundle">资源文件 .bundle</h6><h4 id="pod">pod</h4><h2 id="iOS三方库的实际应用">iOS三方库的实际应用</h2><h4 id="XX会">XX会</h4><h4 id="XX蜂">XX蜂</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/08/20/ios_thirdparty/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/08/10/ios_thread/">
                            iOS多线程基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-08-10T18:15:02+08:00">
	
		    Aug 10, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习iOS多线程需要会什么？">学习iOS多线程需要会什么？</h2><p>进程是系统中并发执行的基本单位，线程是进程中执行运算的最小单位。</p>
<h2 id="iOS多线程是什么？">iOS多线程是什么？</h2><h4 id="Pthreads">Pthreads</h4><p>基于C语言，移植性强</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;pthread.h&#62;&#10;pthread_t thread;&#10;pthread_create(&#38;thread, NULL, start, NULL);</span><br></pre></td></tr></table></figure>
<h4 id="NSThread">NSThread</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];&#10;[thread start];</span><br></pre></td></tr></table></figure>
<h4 id="GCD">GCD</h4><h6 id="异步">异步</h6><p>异步和同步最大的区别在于异步不会<strong>阻塞当前线程</strong>，是否等待block完成后返回</p>
<h6 id="队列">队列</h6><ol>
<li>串行队列<ul>
<li>主队列                 dispatch_get_main_queue()</li>
<li>自定义队列            dispatch_queue_create(“私有串行”, DISPATCH_QUEUE_SERIAL)</li>
</ul>
</li>
<li>并行队列<ul>
<li>全局并发队列            dispatch_get_global_queue()</li>
<li>自定义队列            dispatch_queue_create(“私有并行”, DISPATCH_QUEUE_CONCURRENT)</li>
</ul>
</li>
</ol>
<h6 id="任务">任务</h6><ol>
<li>dispatch_sync(queue, block)</li>
<li>dispatch_async(queue, block)</li>
<li>dispatch_barrier_sync(queue, block)<ul>
<li>传入的queue是自定义DISPATCH_QUEUE_CONCURRENT queue</li>
<li>阻塞queue </li>
<li>执行block前的任务后，执行block，解除阻塞</li>
</ul>
</li>
<li>dispatch_barrier_async(queue, block)<ul>
<li>传入的queue是自定义DISPATCH_QUEUE_CONCURRENT queue</li>
<li>阻塞queue </li>
<li>阻塞当前线程</li>
</ul>
</li>
</ol>
<h6 id="队列_+_任务">队列 + 任务</h6><ol>
<li>队列组<ul>
<li>dispatch_group_create()</li>
<li>dispatch_group_async(group, queue, block)</li>
<li>dispatch_group_notify(group, queue, block)</li>
</ul>
</li>
</ol>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/index.html" target="_blank" rel="external">查看更多关于GCD的坑</a></p>
<h4 id="NSOperation_&amp;_NSOperationQueue">NSOperation &amp; NSOperationQueue</h4><p>是对GCD更高一层的封装</p>
<h6 id="NSOperation">NSOperation</h6><ol>
<li>NSInvocationOperation </li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];&#10;[operation start];</span><br></pre></td></tr></table></figure>
<ol>
<li>NSBlockOperation</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;      NSLog(@&#34;%@&#34;, [NSThread currentThread]);&#10;  &#125;];&#10;  &#10;//&#28155;&#21152;&#22810;&#20010;Block&#65292;&#25903;&#25345;&#22810;&#32447;&#31243;&#10;for (NSInteger i = 0; i &#60; 5; i++) &#123;&#10;&#9;[operation addExecutionBlock:^&#123;&#10;&#9;NSLog(@&#34;&#31532;%ld&#27425;&#65306;%@&#34;, i, [NSThread currentThread]);&#10;&#9;&#125;];&#10;&#125;&#10;&#10;[operation start];</span><br></pre></td></tr></table></figure>
<h6 id="NSOperationQueue">NSOperationQueue</h6><ol>
<li>主队列<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>其它队列</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//1.&#21019;&#24314;&#19968;&#20010;&#20854;&#20182;&#38431;&#21015;    &#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];&#10;&#10;//2.&#21019;&#24314;NSBlockOperation&#23545;&#35937;&#10;NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;%@&#34;, [NSThread currentThread]);&#10;&#125;];&#10;&#10;//3.&#28155;&#21152;&#22810;&#20010;Block&#10;for (NSInteger i = 0; i &#60; 5; i++) &#123;&#10;    [operation addExecutionBlock:^&#123;&#10;        NSLog(@&#34;&#31532;%ld&#27425;&#65306;%@&#34;, i, [NSThread currentThread]);&#10;    &#125;];&#10;&#125;&#10;&#10;//4.&#38431;&#21015;&#28155;&#21152;&#20219;&#21153;&#10;[queue addOperation:operation];</span><br></pre></td></tr></table></figure>
<ol>
<li>maxConcurrentOperationCount 最大并发数</li>
<li>任务依赖</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//1.&#20219;&#21153;&#19968;&#65306;&#19979;&#36733;&#22270;&#29255;&#10;NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;&#19979;&#36733;&#22270;&#29255; - %@&#34;, [NSThread currentThread]);&#10;    [NSThread sleepForTimeInterval:1.0];&#10;&#125;];&#10;&#10;//2.&#20219;&#21153;&#20108;&#65306;&#25171;&#27700;&#21360;&#10;NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;&#25171;&#27700;&#21360;   - %@&#34;, [NSThread currentThread]);&#10;    [NSThread sleepForTimeInterval:1.0];&#10;&#125;];&#10;&#10;//3.&#20219;&#21153;&#19977;&#65306;&#19978;&#20256;&#22270;&#29255;&#10;NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123;&#10;    NSLog(@&#34;&#19978;&#20256;&#22270;&#29255; - %@&#34;, [NSThread currentThread]);&#10;    [NSThread sleepForTimeInterval:1.0];&#10;&#125;];&#10;&#10;//4.&#35774;&#32622;&#20381;&#36182;&#10;[operation2 addDependency:operation1];      //&#20219;&#21153;&#20108;&#20381;&#36182;&#20219;&#21153;&#19968;&#10;[operation3 addDependency:operation2];      //&#20219;&#21153;&#19977;&#20381;&#36182;&#20219;&#21153;&#20108;&#10;&#10;//5.&#21019;&#24314;&#38431;&#21015;&#24182;&#21152;&#20837;&#20219;&#21153;&#10;NSOperationQueue *queue = [[NSOperationQueue alloc] init];&#10;[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];</span><br></pre></td></tr></table></figure>
<h2 id="为什么要用iOS多线程？">为什么要用iOS多线程？</h2><ol>
<li>易于调度、提高并发、充分发挥硬件多核优势</li>
</ol>
<h2 id="iOS多线程怎么用？">iOS多线程怎么用？</h2><h4 id="死锁">死锁</h4><h6 id="为什么死锁">为什么死锁</h6><p>使用同步函数添加任务阻塞当前线程，则当前线程任务需等待添加的任务，被添加到队列的任务具有FIFO性质，它也在等待当前线程任务执行，进入相互等待造成死锁。</p>
<h6 id="怎么避免死锁">怎么避免死锁</h6><ol>
<li>同步转异步，释放阻塞</li>
<li>任务添加到并发队列或其它队列</li>
</ol>
<h4 id="线程安全">线程安全</h4><p>多个线程抢占同一资源进行操作，如何避免？</p>
<ol>
<li>@synchronized(self)</li>
<li>dispatch_semaphore<ul>
<li>dispatch_semaphore_create(1)<ul>
<li>dispatch_semaphore_signal </li>
<li>dispatch_semaphore_wait</li>
</ul>
</li>
</ul>
</li>
<li>NSLock</li>
<li>pthread_mutex </li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)runSemaphore &#123;&#10;    &#10;    // 2, dispatch_semaphore&#10;    dispatch_semaphore_t signal = dispatch_semaphore_create(1);&#10;    dispatch_time_t overtime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);&#10;    &#10;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;&#10;        &#10;        dispatch_semaphore_wait(signal, overtime);  //signal value - 1&#10;        NSLog(@&#34;&#25805;&#20316;1&#65292;&#24320;&#22987;&#34;);&#10;        sleep(2);&#10;        NSLog(@&#34;&#25805;&#20316;1&#65292;&#32467;&#26463;&#34;);&#10;        dispatch_semaphore_signal(signal); //signal value + 1&#10;    &#125;);&#10;    &#10;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;&#10;        &#10;        sleep(1);&#10;        dispatch_semaphore_wait(signal, overtime);  //signal value = 0  to  1&#10;        NSLog(@&#34;&#25805;&#20316;2&#65292;&#24320;&#22987;&#34;);&#10;        dispatch_semaphore_signal(signal);  //signal value = 2&#10;    &#125;);&#10;    &#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延迟执行">延迟执行</h4><h6 id="perform">perform</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(run:) withObject:@&#34;abc&#34; afterDelay:3];</span><br></pre></td></tr></table></figure>
<h6 id="GCD-1">GCD</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21019;&#24314;&#38431;&#21015;&#10;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&#10;// &#35774;&#32622;&#24310;&#26102;&#65292;&#21333;&#20301;&#31186;&#10;double delay = 3; &#10;&#10;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^&#123;&#10;    // 3&#31186;&#21518;&#38656;&#35201;&#25191;&#34892;&#30340;&#20219;&#21153;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="NSTimer">NSTimer</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@&#34;abc&#34; repeats:NO];</span><br></pre></td></tr></table></figure>
<h4 id="单例_dispatch_once">单例 dispatch_once</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Tool : NSObject &#60;NSCopying&#62;&#10;&#10;+ (instancetype)sharedTool;&#10;&#10;@end&#10;&#10;@implementation Tool&#10;&#10;static id _instance;&#10;&#10;+ (instancetype)sharedTool &#123;&#10;    static dispatch_once_t onceToken;&#10;    dispatch_once(&#38;onceToken, ^&#123;&#10;        _instance = [[Tool alloc] init];&#10;    &#125;);&#10;&#10;    return _instance;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<h4 id="其它线程回主线程">其它线程回主线程</h4><ul>
<li>NSThread</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br></pre></td></tr></table></figure>
<ul>
<li>GCD</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>NSOperation</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;&#10;&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="iOS多线程的实际应用">iOS多线程的实际应用</h2><h4 id="XX会">XX会</h4><h4 id="X蜂">X蜂</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/08/10/ios_thread/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/07/20/ios_arc_mrc/">
                            iOS内存管理基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-07-20T18:15:02+08:00">
	
		    Jul 20, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习内存管理需要会什么？">学习内存管理需要会什么？</h2><p>思考下，苹果为什么有了MRC又设计ARC？</p>
<p>iOS内存管理模型</p>
<ol>
<li>自动垃圾收集（iOS环境不支持）</li>
<li>手动引用计数和自动释放池（MRC）</li>
<li>自动引用计数（ARC）  </li>
</ol>
<h2 id="内存管理是什么？">内存管理是什么？</h2><h3 id="MRC">MRC</h3><h4 id="引用计数器">引用计数器</h4><ol>
<li>对象被引用的次数，也可说有多少人正在用这个对象</li>
<li>初始化时为1<ul>
<li>创建并持有对象：alloc new copy mutableCopy</li>
<li>持有对象：retain</li>
</ul>
</li>
<li>计数为0时，对象占用的内存被系统回收</li>
</ol>
<h4 id="引用计数器操作">引用计数器操作</h4><ol>
<li>retain +1</li>
<li>release -1</li>
<li>retainCount 显示计数</li>
</ol>
<h4 id="dealloc方法">dealloc方法</h4><ol>
<li>[super dealloc];一定在最后一行</li>
<li>不能直接调用</li>
<li>一旦对象被回收，继续使用会野指针</li>
</ol>
<h4 id="野指针_&amp;_空指针">野指针 &amp; 空指针</h4><ol>
<li>野指针即一个指针指向了“<strong>僵尸对象</strong>（不能再使用的对象）”</li>
<li>给野指针发消息报错：EXC_BAD_ACCESS</li>
<li>避免野指针发消息报错，对象释放后，将指针置为空指针<ul>
<li>空指针即没有指向任何存储空间（存的nil）</li>
<li>向空指针发送消息没有任何反应</li>
</ul>
</li>
</ol>
<h4 id="MRC_单个对象管理">MRC 单个对象管理</h4><ol>
<li>谁创建(alloc copy)，谁release</li>
<li>谁retain, 谁release</li>
</ol>
<h4 id="MRC_多个对象管理">MRC 多个对象管理</h4><p><img src="https://www.processon.com/chart_image/5864740be4b0e069269f1e34.png" alt=""></p>
<ol>
<li>setter方法</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setRoom:(Room *)room &#123;&#10;&#9;// &#21482;&#26377;&#25151;&#38388;&#19981;&#21516;&#26102;&#25165;&#38656;&#35201;release &#21644; retain&#10;&#9;if (_room != room) &#123;&#10;&#9;&#9;// &#23558;&#20197;&#21069;&#30340;&#25151;&#38388;release -1&#10;&#9;&#9;[_room release];&#10;&#9;&#9;&#10;&#9;&#9;_room = [room retain];&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MRC_@property参数">MRC @property参数</h4><ol>
<li>成员变量前加上<strong>@property</strong>，自动生成<strong>基本</strong>的setter/getter</li>
<li>property加上<strong>retain</strong>，自动生成<strong>有内存管理</strong>的setter/getter</li>
<li>property加上<strong>assign</strong>，自动生成基本的setter/getter，<strong>默认</strong>什么都不加就是assign</li>
</ol>
<h4 id="MRC_循环引用">MRC 循环引用</h4><ul>
<li>当两端互相引用时，应该一端用retain，一端用assign</li>
</ul>
<h4 id="autoreleasepool">autoreleasepool</h4><ol>
<li><strong>[p autorelease]</strong> 给p发送一条autorelease消息，将p放到autoreleasepool，在autoreleasepool释放时做一次release操作</li>
<li>autorelease方法返回对象本身，引用计数不会变化</li>
</ol>
<h6 id="autoreleasepool_好处">autoreleasepool 好处</h6><ol>
<li>不用关心释放时间</li>
<li>不用关心什么时候调用release</li>
</ol>
<h6 id="autoreleasepool_原理">autoreleasepool 原理</h6><p>autoreleasepool实际上只是把对release的调用延迟了</p>
<ol>
<li>声明__autoreleasepool时，构造函数<strong>__AtAutoreleasePool()</strong>执行，即<strong>atautoreleasepoolobj = objc_autoreleasePoolPush()</strong></li>
<li>出了当前作用域时，析构函数<strong>~__AtAutoreleasePool()</strong>执行，即<strong>objc_autoreleasePoolPop(atautoreleasepoolobj)</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;&#125;</span><br></pre></td></tr></table></figure>
<p>简化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="comment">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PUSH操作</li>
</ul>
<p>每调用一次 push 操作就会创建一个新的 autoreleasepool ，即往 AutoreleasePoolPage 中插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。</p>
<ul>
<li>Autorelease操作</li>
</ul>
<p>它跟 push 操作的实现非常相似。只不过 push 操作插入的是一个 POOL_SENTINEL ，而 autorelease 操作插入的是一个具体的 autoreleased 对象</p>
<ul>
<li>POP操作</li>
</ul>
<p>pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址，即 pool token 。当执行 pop 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release</p>
<h6 id="autoreleasepool_创建和使用">autoreleasepool 创建和使用</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#26041;&#24335;1&#10;NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];&#10;Person *p = [[[Person alloc] init] autorelease];&#10;[autoreleasePool drain];&#10;&#10;// &#26041;&#24335;2&#10;@autoreleasepool&#10;&#123; // &#21019;&#24314;&#19968;&#20010;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;        Person *p = [[Person new] autorelease];&#10;        // &#23558;&#20195;&#30721;&#20889;&#21040;&#36825;&#37324;&#23601;&#25918;&#20837;&#20102;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;&#125; // &#38144;&#27585;&#33258;&#21160;&#37322;&#25918;&#27744;(&#20250;&#32473;&#27744;&#23376;&#20013;&#25152;&#26377;&#23545;&#35937;&#21457;&#36865;&#19968;&#26465;release&#28040;&#24687;)</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_注意">autoreleasepool 注意</h6><ul>
<li>并不是放到autoreleasepool代码中,都会自动加入到自动释放池</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#10;    // &#22240;&#20026;&#27809;&#26377;&#35843;&#29992; autorelease &#26041;&#27861;,&#25152;&#20197;&#23545;&#35937;&#27809;&#26377;&#21152;&#20837;&#21040;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;    Person *p = [[Person alloc] init];&#10;    [p run];&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>autorelease是一个方法, 只有在autoreleasepool中调用才有效</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#10;&#125;&#10;// &#27809;&#26377;&#19982;&#20043;&#23545;&#24212;&#30340;&#33258;&#21160;&#37322;&#25918;&#27744;, &#21482;&#26377;&#22312;&#33258;&#21160;&#37322;&#25918;&#27744;&#20013;&#35843;&#29992;autorelease&#25165;&#20250;&#25918;&#21040;&#37322;&#25918;&#27744;&#10;Person *p = [[[Person alloc] init] autorelease];&#10;[p run];&#10;&#10;// &#27491;&#30830;&#20889;&#27861;&#10;@autoreleasepool &#123;&#10;    Person *p = [[[Person alloc] init] autorelease];&#10; &#125;&#10;&#10;// &#27491;&#30830;&#20889;&#27861;&#10;Person *p = [[Person alloc] init];&#10;@autoreleasepool &#123;&#10;    [p autorelease];&#10;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_嵌套">autoreleasepool 嵌套</h6><ol>
<li>AutoreleasePool 以 <strong>栈</strong>形式存在</li>
<li>栈只有一个入口，调用autorelease会将对象放到<strong>栈顶的自动释放池</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123; // &#26632;&#24213;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;    @autoreleasepool &#123;&#10;        @autoreleasepool &#123; // &#26632;&#39030;&#33258;&#21160;&#37322;&#25918;&#27744;&#10;            Person *p = [[[Person alloc] init] autorelease];&#10;        &#125;&#10;        Person *p = [[[Person alloc] init] autorelease];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_for循环">autoreleasepool for循环</h6><ol>
<li>尽量避免对大内存使用autorelease</li>
<li>不要把for循环放在@autoreleasepool之间，会造成内存峰值上升</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20869;&#23384;&#26292;&#28072;&#10;@autoreleasepool &#123;&#10;    for (int i = 0; i &#60; 99999; ++i) &#123;&#10;        Person *p = [[[Person alloc] init] autorelease];&#10;    &#125;&#10;&#125;&#10;&#10;// &#20869;&#23384;&#19981;&#20250;&#26292;&#28072;&#10;for (int i = 0; i &#60; 99999; ++i) &#123;&#10;    @autoreleasepool &#123;&#10;        Person *p = [[[Person alloc] init] autorelease];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="autoreleasepool_错误用法">autoreleasepool 错误用法</h6><ol>
<li>不能连续调用autorelease</li>
<li>调用autorelease后又调用release</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#10; // &#38169;&#35823;&#20889;&#27861;, &#36807;&#24230;&#37322;&#25918;&#10;    Person *p = [[[[Person alloc] init] autorelease] autorelease];&#10; &#125;&#10; &#10; @autoreleasepool &#123;&#10;    Person *p = [[[Person alloc] init] autorelease];&#10;    [p release]; // &#38169;&#35823;&#20889;&#27861;, &#36807;&#24230;&#37322;&#25918;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ARC">ARC</h3><ol>
<li>Automatic Reference Counting，自动引用计数，自iOS5 LLVM3.0引入</li>
<li>解决了广大iOS开发者所憎恨的手动内存管理的麻烦</li>
<li>通过生成正确的代码去自动释放或者保持对象，我们完全不用担心编译器会出错</li>
</ol>
<h4 id="ARC_判断是否需要释放">ARC 判断是否需要释放</h4><p>只要还有一个强指针指向对象，对象就会保存在内存中</p>
<ol>
<li>强指针  被__strong修饰</li>
<li>弱指针  被__weak修饰</li>
</ol>
<h4 id="ARC_注意">ARC 注意</h4><ol>
<li>不能调用release</li>
<li>不能调用autorelease</li>
<li>不能调用[super dealloc]</li>
</ol>
<h4 id="ARC_单个对象管理">ARC 单个对象管理</h4><ul>
<li>局部变量释放，对象随之释放</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        Person *p = [[Person alloc] init];&#10;    &#125; // &#25191;&#34892;&#21040;&#36825;&#19968;&#34892;&#23616;&#37096;&#21464;&#37327;p&#37322;&#25918;&#10;    // &#30001;&#20110;&#27809;&#26377;&#24378;&#25351;&#38024;&#25351;&#21521;&#23545;&#35937;, &#25152;&#20197;&#23545;&#35937;&#20063;&#37322;&#25918;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空指针，对象随之释放</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        Person *p = [[Person alloc] init];&#10;        p = nil; // &#25191;&#34892;&#21040;&#36825;&#19968;&#34892;, &#30001;&#20110;&#27809;&#26377;&#24378;&#25351;&#38024;&#25351;&#21521;&#23545;&#35937;, &#25152;&#20197;&#23545;&#35937;&#34987;&#37322;&#25918;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认清空所有指针都是强指针</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        // p1&#21644;p2&#37117;&#26159;&#24378;&#25351;&#38024;&#10;        Person *p1 = [[Person alloc] init];&#10;        __strong Person *p2 = [[Person alloc] init];&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>弱指针需要明确说明（<strong>千万不要使用弱指针保存新创建的对象</strong>）</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;&#10;   @autoreleasepool &#123;&#10;        // p&#26159;&#24369;&#25351;&#38024;, &#23545;&#35937;&#20250;&#34987;&#31435;&#21363;&#37322;&#25918;&#10;        __weak Person *p1 = [[Person alloc] init];&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ARC_多个对象管理">ARC 多个对象管理</h4><ul>
<li>ARC和MRC一样，想拥有某个对象需要用强指针指向，但是不需要调用dealloc中release</li>
</ul>
<h4 id="ARC_@property">ARC @property</h4><ul>
<li>strong : 用于OC对象，相当于MRC中的retain</li>
<li>weak : 用于OC对象，相当于MRC中的assign</li>
<li>assign : 用于基本数据类型，跟MRC中的assign一样</li>
</ul>
<h4 id="ARC_循环引用">ARC 循环引用</h4><ul>
<li>A拥有B，B也拥有A，那么必须一方使用弱指针</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&#10;@property (nonatomic, strong) Dog *dog;&#10;@end&#10;&#10;@interface Dog : NSObject&#10;// &#38169;&#35823;&#20889;&#27861;, &#24490;&#29615;&#24341;&#29992;&#20250;&#23548;&#33268;&#20869;&#23384;&#27844;&#38706;&#10;//@property (nonatomic, strong) Person *owner;&#10;&#10;// &#27491;&#30830;&#20889;&#27861;, &#24403;&#22914;&#26524;&#20445;&#23384;&#23545;&#35937;&#24314;&#35758;&#20351;&#29992;weak&#10;@property (nonatomic, weak) Person *owner;&#10;@end</span><br></pre></td></tr></table></figure>
<h2 id="为什么用内存管理?">为什么用内存管理?</h2><h4 id="NSThread_&amp;_NSRunLoop_&amp;_NSAutoreleasePool">NSThread &amp; NSRunLoop &amp; NSAutoreleasePool</h4><ol>
<li>每个线程（包括主线程）都拥有一个专属的NSRunLoop，并在需要时自动创建</li>
<li>主线程的NSRunLoop对象（包括系统级别的其它线程）的每个event loop开始前，自动创建一个autoreleasepool，并在event loop结束时drain</li>
<li>每个autoreleasepool对应且只对应一个线程</li>
</ol>
<h2 id="内存管理怎么用？">内存管理怎么用？</h2><p>这些情况需要手动添加autoreleasepool：</p>
<ol>
<li>编写的程序不是基于UI框架的，比如命令行工具</li>
<li>编写的循环中创建了大量的临时对象  </li>
<li>创建了一个辅助线程</li>
</ol>
<h2 id="内存管理实际应用">内存管理实际应用</h2><h4 id="项目">项目</h4><ol>
<li>YYKit ：解决循环中创建的大量临时对象</li>
<li>AFNetworking： 创建了辅助线程</li>
<li>XX会 混编时， 标注MRC文件：-fno-objc-arc</li>
</ol>
<h4 id="ARC_实例">ARC 实例</h4><ol>
<li>ARC想要主动释放，最好是提前置为nil</li>
<li>ARC下获取引用计数<ul>
<li>KVC  [obj valueForKey:@”retainCount”] </li>
<li>私有API _objc_rootRetainCount(obj)</li>
<li>CFGetRetainCount((__bridge CFTypeRef)(obj))</li>
</ul>
</li>
</ol>
<h4 id="MRC_实例">MRC 实例</h4><ol>
<li>下面这种情况会报错吗？（注意计算retainCount）</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	YLAutorelease *obj = [[YLAutorelease alloc] init];      <span class="comment">//1</span></span><br><span class="line">    _tableView = [[<span class="built_in">UITableView</span> alloc] init];                <span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj retainCount:%ld"</span>, [obj retainCount]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView retainCount:%ld"</span>, [_tableView retainCount]);</span><br><span class="line">    </span><br><span class="line">    [obj performSelector:<span class="keyword">@selector</span>(test) withObject:_tableView afterDelay:<span class="number">1</span>];   <span class="comment">//obj 2 , tableView 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj retainCount:%ld"</span>, [obj retainCount]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView retainCount:%ld"</span>, [_tableView retainCount]);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [obj release];</span></span><br><span class="line"><span class="comment">//    [_tableView release];</span></span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:obj selector:<span class="keyword">@selector</span>(test) object:_tableView];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj retainCount:%ld"</span>, [obj retainCount]);       <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView retainCount:%ld"</span>, [_tableView retainCount]);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>NSString的引用计数是随机值，NSMutableString的引用计数是正常值</p>
<ul>
<li>NSString的class是__NSCFConstantString，字符串常量</li>
<li>NSMutableString的class是__NSCFString，有引用计数</li>
</ul>
</li>
<li><p>对于字符串常量、NSNumber做常量时？</p>
<ul>
<li>retain 和 release都不会有影响，因为系统不会回收，也不会对其做引用计数</li>
</ul>
</li>
<li><p>stringWithFormat创建的string？</p>
<ul>
<li>为变量，所以会有引用计数</li>
<li>现在返回的已经是常量，见后面的例子</li>
</ul>
</li>
<li><p>stringWithString创建的string?</p>
<ul>
<li>取决于它后面的string对象，如果是常量则不做计数，如果是变量则做计数</li>
</ul>
</li>
<li><p>除了alloc new copy mutableCopy retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？</p>
<ul>
<li>容器类array、dic addObject；release时，里面的成员都会release一次，和autorelease pool一致</li>
<li>addsubview, 因为view有栈(subviews)，加入栈中retainCount+1</li>
<li>navcontroller的push, 因为nav有栈(viewcontrollers)，加入栈中retainCount+1</li>
<li>performSelector 调用时target和info都会加1，结束时减1</li>
</ul>
</li>
<li><p>苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。</p>
</li>
<li><p>几个copy, mutableCopy的例子</p>
</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">   <span class="built_in">NSMutableString</span> *str = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSMutableString</span> *str2 = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//1,1</span></span><br><span class="line">   </span><br><span class="line">   str2 = [str <span class="keyword">copy</span>];         <span class="comment">//copy返回一个不可变对象属于常量</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//1,-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]); <span class="comment">//-1,-1</span></span><br><span class="line"></span><br><span class="line">str2 = [str <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//-1,-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"abc%@"</span>, <span class="string">@"hehe"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"bbc%@"</span>, <span class="string">@"hehe"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]); <span class="comment">//-1,-1</span></span><br><span class="line"></span><br><span class="line">str2 = [str mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld, %ld"</span>, [str retainCount], [str2 retainCount]);<span class="comment">//-1,1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>block内存管理，详见后续文章</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/07/20/ios_arc_mrc/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/20/c_pointer/">
                            指针基础到进阶
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-20T18:15:02+08:00">
	
		    Jun 20, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="学习指针需要会什么？">学习指针需要会什么？</h2><p>如何完全理解一个复杂类型，记住一条原则：</p>
<ul>
<li>从<strong>变量名</strong>处起，根据<strong>运算符优先级</strong>结合，一步一步分析</li>
</ul>
<p>举几个🌰：</p>
<ol>
<li>int p;    <ul>
<li>从p开始，先与int结合，说明p是<strong>整型变量</strong></li>
</ul>
</li>
<li>int *p;    <ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>，</li>
<li>再与int结合，说明<strong>指针指向int型</strong>，</li>
<li>所以p是返回int型数据的指针</li>
</ul>
</li>
<li>int p[3];<ul>
<li>从p开始，先与[]结合，说明p是<strong>数组</strong>，</li>
<li>再与int结合，说明<strong>[]里面是int型</strong>,</li>
<li>所以p是返回int型数据的数组</li>
</ul>
</li>
<li>int *p[3];<ul>
<li>从p开始，先与[]结合，说明p是<strong>数组</strong>，</li>
<li>再与*结合，说明<strong>[]里面是指针型</strong>，</li>
<li>再与int结合，说明<strong>指针指向内容是int型</strong>，</li>
<li>所以p是由返回int型数据的指针组成的数组</li>
</ul>
</li>
<li>int (*p)[3];<ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>，</li>
<li>再与[]结合，说明<strong>指针指向[]型</strong>，</li>
<li>再与int结合，说明<strong>[]里是int型</strong>，</li>
<li>所以p是指向由int型数据组成的数组的指针</li>
</ul>
</li>
<li>int **p;<ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>，</li>
<li>再与*结合，说明<strong>指针指向指针型</strong>，</li>
<li>再与int结合，说明<strong>二级指针指向int型</strong>,</li>
<li>所以p是二级指针</li>
</ul>
</li>
<li>int p(int);<ul>
<li>从p开始，先与()结合，说明p是<strong>函数</strong>，</li>
<li>分析()里面，函数有一个<strong>int型参数</strong>,</li>
<li>再与int结合，函数<strong>返回类型是int</strong></li>
</ul>
</li>
<li>int (*p)(int);<ul>
<li>从p开始，先与*结合，说明p是<strong>指针</strong>,</li>
<li>再与()结合，说明<strong>指针指向函数</strong>，</li>
<li>分析()里面，函数有一个<strong>int型参数</strong>,</li>
<li>再与int结合，函数<strong>返回类型是int</strong>,</li>
<li>所以p是指向有一个整型参数且返回类型为整数的函数的指针</li>
</ul>
</li>
<li>int *(*p(int))[3];<ul>
<li>从p开始，先与()结合，说明p是一个<strong>函数</strong>,</li>
<li>分析()里面，函数有一个<strong>int型参数</strong>，</li>
<li>再与*结合，函数<strong>返回类型是指针</strong>，</li>
<li>再与[]结合，说明返回的<strong>指针指向[]</strong>,</li>
<li>再与*结合，说明<strong>[]里是指针</strong>，</li>
<li>再与int结合，说明指针<strong>指向的是int型</strong>，</li>
<li>所以p是一个参数为一个int型且返回一个指向整型指针变量组成的数组的指针变量的函数</li>
</ul>
</li>
</ol>
<h2 id="指针是什么？">指针是什么？</h2><p>指针是一个特殊的变量，它存储的数值被解释成内存里的一个地址</p>
<p>先声明几个指针🌰：</p>
<ol>
<li>int *ptr;</li>
<li>char *ptr;</li>
<li>int **ptr;</li>
<li>int (*ptr)[3];</li>
<li>int *(*ptr)[4] </li>
</ol>
<h4 id="指针的类型">指针的类型</h4><p>把指针名字去掉，剩下部分就是指针类型</p>
<h4 id="指向的类型">指向的类型</h4><p>把指针名和名字左边的*去掉，剩下部分就是指针指向的类型</p>
<ul>
<li>指针的类型（指针本身的类型）和指针指向的类型是<strong>两个概念</strong></li>
</ul>
<h4 id="指针的值_—_或叫指针指向的内存区">指针的值 — 或叫指针指向的内存区</h4><p>在32位操作系统里，指针都是一个32位整数，指针指向的内存区就是从指针的值代表的那个<strong>内存地址开始</strong>，长度为<strong>sizeof(指针指向的类型)</strong>的一片内存区</p>
<ul>
<li>我们说一个指针的值是XX，相当于说指针指向了以XX为首地址的一片内存区域</li>
<li>我们说一个指针指向了某块内存区域，相当于说指针的值是这块内存区域的首地址</li>
</ul>
<h4 id="指针本身占据的内存区域">指针本身占据的内存区域</h4><p><strong>sizeof(指针的类型)</strong>，32位系统里，指针占据4个字节</p>
<h2 id="为什么用指针？">为什么用指针？</h2><p>C语言的精华和唯一的难点就是指针，搞定指针等于搞定了C语言</p>
<p>指针 -&gt; C语言 -&gt; C++ -&gt; 数据结构 -&gt; 算法 -&gt; 范型编程与STL和STL源码剖析</p>
<h2 id="指针怎么用？">指针怎么用？</h2><h4 id="指针的算术运算">指针的算术运算</h4><p>指针可以加上或减去一个整数</p>
<ul>
<li>和数值的加减运算不一样，以单元为单位</li>
<li>两个指针不能进行加法运算，得到的结果不知道指向何处</li>
<li>两个指针可以进行减法运算，但是类型必须相同，一般用于数组</li>
</ul>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)a;  <span class="comment">//强制类型转换不会改变a的类型</span></span><br><span class="line">ptr++;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">指针ptr加了<span class="number">1</span>，编译器处理：ptr的值加上了<span class="keyword">sizeof</span>(<span class="keyword">int</span>)，在<span class="number">32</span>位程序里，是加了<span class="number">4</span>，因为<span class="keyword">int</span>占据<span class="number">4</span>个字节。</span><br><span class="line"></span><br><span class="line">🌰<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">	(*ptr)++;</span><br><span class="line">	ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个单元的值加1，每次循环都将指针ptr加1个单元，所以每次循环都能访问到下一个单元。</p>
<h4 id="运算符_&amp;_和_*">运算符 &amp; 和 *</h4><p>&amp;是取地址运算符，*是间接运算符</p>
<ul>
<li>&amp;a的运算结果是一个指针，指针的类型是a的类型加个*，指针指向的类型是a的类型，指针指向的地址是a的地址</li>
<li><em>p的结果五花八门，\</em>p的结果是p所指向的东西，这个东西的特点：它的类型是p指向的类型，它占用的地址是p指向的地址</li>
</ul>
<p>🌰1： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">int</span> b; <span class="keyword">int</span> *p; <span class="keyword">int</span> **ptr;</span><br><span class="line"></span><br><span class="line">p = &amp;a; <span class="comment">//&amp;a的结果是一个指针，类型是int *, 指向的类型是int, 指向的地址是a的地址</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">24</span>; <span class="comment">//*p的结果，它的类型是int，它占用的地址是p指向的地址，*p就是变量a</span></span><br><span class="line"></span><br><span class="line">ptr = &amp;p; <span class="comment">//&amp;p的结果是指针，类型是p的类型加个*，这里是int **，该指针指向的类型是p的类型，这里是int *，该指针所指向的地址就是指针 p 自己的地址</span></span><br><span class="line"></span><br><span class="line">*ptr = &amp;b; <span class="comment">//*ptr 是个指针,&amp;b 的结果也是个指针,且这两个指针的类型和所指向的类型是一样的,所以用&amp;b 来给*ptr 赋值就是毫无问题的了</span></span><br><span class="line"></span><br><span class="line">**ptr = <span class="number">34</span>; <span class="comment">//*ptr 的结果是 ptr 所指向的东西,在这里是一个指针, 对这个指针再做一次*运算,结果是一个 int 类型的变量。</span></span><br></pre></td></tr></table></figure>
<h4 id="指针表达式">指针表达式</h4><p>一个表达式的结果是指针，即指针表达式</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *pa;</span><br><span class="line">pa = &amp;a;				<span class="comment">//&amp;a</span></span><br><span class="line"><span class="keyword">int</span> **ptr = &amp;pa;    <span class="comment">//&amp;pa</span></span><br><span class="line">*ptr = &amp;b;          <span class="comment">//*ptr 和 &amp;b </span></span><br><span class="line">pa = <span class="built_in">array</span>;</span><br><span class="line">pa++;					<span class="comment">//pa</span></span><br></pre></td></tr></table></figure>
<p>当一个指针表达式的结果指针已经明确地具有了指针自身占 据的内存的话,这个指针表达式就是一个左值,否则就不是一个左值</p>
<h4 id="指针和数组">指针和数组</h4><p>数组名可以看作一个指针</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intarray[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,value;value=<span class="built_in">array</span>[<span class="number">0</span>];		<span class="comment">//可写成： value = *array;</span>value=<span class="built_in">array</span>[<span class="number">3</span>];		<span class="comment">//可写成：	value = *(array+3);</span>value=<span class="built_in">array</span>[<span class="number">4</span>];		<span class="comment">//可写成： value = *(array+4);</span></span><br></pre></td></tr></table></figure>
<p>数组名array代表数组本身，类型是int[10]，如果把array看作指针，它指向数组的第0个单元，类型是int <em>， 所指向的类型是是数组单元的类型即int，因此\</em>array 等于 0 就一点也不 奇怪了。同理,array+3 是一个指向数组第 3 个单元的指针,所以 *(array+3)等于 3。其它依此类推</p>
<h4 id="指针和结构类型">指针和结构类型</h4><p>可以声明一个指向结构类对象的指针</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyStruct &#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct ss = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct *ptr = &amp;ss;  <span class="comment">//声明一个指向结构对象ss的指针，它的类型是MyStruct *，它指向的类型是MyStruct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pstr = (<span class="keyword">int</span> *)&amp;ss; <span class="comment">//声明一个指向结构对象ss的指针，但是pstr和它被指向的类型ptr是不同的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ptr 来访问 ss 的三个成员变量</span></span><br><span class="line">ptr-&gt;a;  <span class="comment">//指向运算符</span></span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  pstr 来访问 ss 的三个成员变量</span></span><br><span class="line">*pstr;</span><br><span class="line">*(pstr + <span class="number">1</span>);</span><br><span class="line">*(pstr + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="指针和函数">指针和函数</h4><p>可以声明一个指向函数的指针</p>
<p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*pfun1)(<span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">pfun1 = fun1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = (*pfun1)(<span class="string">"abcdefg"</span>, <span class="number">7</span>);  <span class="comment">//通过函数指针调用函数</span></span><br></pre></td></tr></table></figure>
<p>指针作为函数的形参，函数调用中，用指针表达式来作为实参</p>
<h4 id="指针类型转换">指针类型转换</h4><p>🌰1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> *fptr = &amp;f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想让指针 p 指向实数 f</span></span><br><span class="line">p=&amp;f; <span class="comment">//不对。因为指针 p 的类型是 int *,它指向的类型是 int</span></span><br><span class="line"></span><br><span class="line">p=(<span class="keyword">int</span>*)&amp;f; <span class="comment">// 如果有一个指针 p,我们需要把它的类型和所指向的类型改为</span>TYEP *TYPE, 那么语法格式是: (TYPE *)p;</span><br></pre></td></tr></table></figure>
<p>强制类型转换的结果是一个新指针,该新指针的类型是TYPE *,它指向的类型是 TYPE,它指向的地址就是原指针指向的地址。 <strong>而原来的指针 p 的一切属性都没有被修改。(切记)</strong></p>
<h4 id="指针的安全问题">指针的安全问题</h4><ol>
<li>指针访问数组时，不要超过数组低端和高端的界限</li>
<li>强制类型转换ptr1 = (TYPE *)ptr2中，如果sizeof(prt2的类型)大于sizeof(ptr1的类型)，那么使用指针ptr1访问ptr2所指向的存储区域是安全的</li>
</ol>
<h2 id="指针的实际应用">指针的实际应用</h2><h4 id="XX会">XX会</h4><h4 id="XX仓">XX仓</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/06/20/c_pointer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/06/17/c3p0/">
                            C3P0的两种用法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-06-17T18:15:02+08:00">
	
		    Jun 17, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h6 id="background">background</h6><blockquote>
<p>这篇文章摘抄自我的新浪博客，<a href="http://blog.sina.com.cn/s/blog_6c5f4d3c01012gtq.html" target="_blank" rel="external">详情链接</a> 因为它一度为我的新浪博客积累超过7万的人气，新浪博客已经远不如曾经，所以我想把这篇文章保留下来，以下是原文</p>
</blockquote>
<h6 id="方法一：">方法一：</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package   C3P0; </span><br><span class="line">import   java.sql.Connection; </span><br><span class="line">import   java.sql.SQLException; </span><br><span class="line">import   java.beans.PropertyVetoException; </span><br><span class="line">import   com.mchange.v2.c3p0.ComboPooledDataSource; </span><br><span class="line">public   class   DBPool&#123;       </span><br><span class="line">   private   static   DBPool   dbPool;       </span><br><span class="line">   private   ComboPooledDataSource   dataSource;     </span><br><span class="line">	</span><br><span class="line">   static   &#123;       </span><br><span class="line">           dbPool=new   DBPool();       </span><br><span class="line">   &#125;       </span><br><span class="line">   </span><br><span class="line">   public   DBPool()&#123;       </span><br><span class="line">           try   &#123;       </span><br><span class="line">                   dataSource=new   ComboPooledDataSource();       </span><br><span class="line">                   dataSource.setUser( "id ");       </span><br><span class="line">                   dataSource.setPassword( "pw ");       </span><br><span class="line">                   dataSource.setJdbcUrl( "jdbc:mysql://127.0.0.1:3306/test? </span><br><span class="line">	</span><br><span class="line">autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=GB2312 "); </span><br><span class="line">                   dataSource.setDriverClass( "com.mysql.jdbc.Driver "); </span><br><span class="line">                   dataSource.setInitialPoolSize(2); </span><br><span class="line">                   dataSource.setMinPoolSize(1); </span><br><span class="line">                   dataSource.setMaxPoolSize(10); </span><br><span class="line">                   dataSource.setMaxStatements(50); </span><br><span class="line">                   dataSource.setMaxIdleTime(60);       </span><br><span class="line">           &#125;   catch   (PropertyVetoException   e)   &#123;       </span><br><span class="line">               throw   new   RuntimeException(e);       </span><br><span class="line">           &#125;       </span><br><span class="line">   &#125;       </span><br><span class="line">	</span><br><span class="line">   public   final   static   DBPool   getInstance()&#123;       </span><br><span class="line">           return   dbPool;       </span><br><span class="line">   &#125;       </span><br><span class="line">	</span><br><span class="line">   public   final   Connection   getConnection()   &#123;       </span><br><span class="line">           try   &#123;       </span><br><span class="line">                   return   dataSource.getConnection();       </span><br><span class="line">           &#125;   catch   (SQLException   e)   &#123;       </span><br><span class="line">                   throw   new   RuntimeException( "无法从数据源获取连接 ",e);       </span><br><span class="line">           &#125;       </span><br><span class="line">   &#125;     </span><br><span class="line">   </span><br><span class="line">   public   static   void   main(String[]   args)   throws   SQLException   &#123; </span><br><span class="line">Connection   con   =   null; </span><br><span class="line">try   &#123; </span><br><span class="line">con   =   DBPool.getInstance().getConnection(); </span><br><span class="line">&#125;   catch   (Exception   e)&#123; </span><br><span class="line">&#125;   finally   &#123; </span><br><span class="line">if   (con   !=   null) </span><br><span class="line">con.close(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="方法二：">方法二：</h6><pre><code>原来不知道使用c3p0 是如此的简单，我一直使用<span class="keyword">properties</span> 文件去配置c3p0，但总是连接不上数据库，后来调试才发现ComboPooledDataSource 这个对象的属性没有被设置成功，我是先获取了<span class="keyword">properties</span>文件的内容，封装在一个 Properties对象里面，然后直接调用 ComboPooledDataSource 的 setProperties（Properties  p） 方法来配置c3p0，程序是没有报错，但连不上数据库，调试发现属性都没有设置成功，只是<span class="keyword">properties</span>这个属性被设置了而已，结果我对每个属性调用set方法后就连接上了。。。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ConnectionManager instance;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> ComboPooledDataSource ds;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> String c3p0Properties = <span class="string">"c3p0.properties"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">ConnectionManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">  p.load(<span class="keyword">this</span>.getClass().getResourceAsStream(c3p0Properties));</span><br><span class="line">  ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">  ds.setUser(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setPassword(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setJdbcUrl(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setDriverClass(p.getProperty(<span class="string">"user"</span>));</span><br><span class="line">  ds.setInitialPoolSize(Integer.parseInt(p.getProperty(<span class="string">"initialPoolSize"</span>)));</span><br><span class="line">  ds.setMinPoolSize(Integer.parseInt(p.getProperty(<span class="string">"minPoolSize"</span>)));</span><br><span class="line">  ds.setMaxPoolSize(Integer.parseInt(p.getProperty(<span class="string">"maxPoolSize"</span>)));</span><br><span class="line">  ds.setMaxStatements(Integer.parseInt(p.getProperty(<span class="string">"maxStatements"</span>)));</span><br><span class="line">  ds.setMaxIdleTime(Integer.parseInt(p.getProperty(<span class="string">"maxIdleTime"</span>)));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  DataSources.destroy(ds); <span class="comment">// 关闭datasource</span></span><br><span class="line">  <span class="keyword">super</span>.finalize();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>如此就可以获取connection来做jdbc操作了：
Connection         
conn=ConnectionManager.getInstance().getConnection()<span class="comment">;</span>
记得使用完后调用close方法：
conn.close()<span class="comment">;</span>
c3p0 的某些参数的配置以及意义见另外一篇文章http://kangzye.blog.163.com/blog/static/<span class="number">3681922320104</span><span class="number">42162576</span>/
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/06/17/c3p0/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2014/05/17/easy_compiler/">
                            一个简单的编译器
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2014-05-17T18:15:02+08:00">
	
		    May 17, 2014
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <pre><code>简单的说 编译器 就是语言翻译器，它一般将高级语言翻译成更低级的语言，如 GCC 可将 <span class="keyword">C</span>/<span class="keyword">C</span>++ 语言翻译成可执行机器语言，Java 编译器可以将 Java 源代码翻译成 Java 虚拟机可以执行的字节码。

编译器如此神奇，那么它到底是如何工作的呢？本文将简单介绍编译器的原理，并实现一个简单的编译器，使它能编译我们自定义语法格式的源代码。（文中使用的源码都已上传至 GitHub 以方便查看）。
</code></pre><h6 id="自定义语法">自定义语法</h6><pre><code>为了简洁易懂，我们的编译器将只支持以下简单功能：
</code></pre><ul>
<li>数据类型只支持整型，这样不需要数据类型符；</li>
<li>支持 加（+），减（-），乘（*）， 除（/） 运算</li>
<li>支持函数调用</li>
<li>支持 extern（为了调用 printf 打印计算结果）</li>
</ul>
<p>以下是我们要支持的源码实例 demo.xy：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">printi</span><span class="params">(val)</span></span><br><span class="line"></span><br><span class="line"><span class="title">sum</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mult(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printi(mult(<span class="number">4</span>, <span class="number">5</span>) - sum(<span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h6 id="编译原理简介">编译原理简介</h6><pre><code>一般编译器有以下工作步骤：
</code></pre><ul>
<li>词法分析（Lexical analysis）： 此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符流进行扫描然后根据构词规则识别 单词（Token），完成这个任务的组件是 词法分析器（Lexical analyzer，简称Lexer），也叫 扫描器（Scanner）；</li>
<li>语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser）；</li>
<li>目标码生成： 此阶段编译器会遍历上一步生成的抽象语法树，然后为每个节点生成 机器 / 字节码。<br>编译器完成编译后，由 链接器（Linker） 将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。</li>
</ul>
<h6 id="工具简介">工具简介</h6><pre><code>对应编译器工作步骤我们将使用以下工具，括号里标明了所使用的版本号：
</code></pre><ul>
<li>Flex（2.6.0）: Flex 是 Lex 开源替代品，他们都是 词法分析器 制作工具，它可以根据我们定义的规则生成 词法分析器 的代码；</li>
<li>Bison（3.0.4）： Bison 是 语法分析器 的制作工具，同样它可以根据我们定义的规则生成 语法分析器 的代码；</li>
<li><p>LLVM（3.8.0）： LLVM 是构架编译器的框架系统，我们会利用他来完成从 抽象语法树 生成目标码的过程。</p>
<p>  在 ubuntu 上可以通过以下命令安装这些工具：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flex</span><br><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install llvm-<span class="number">3.8</span>*</span><br></pre></td></tr></table></figure>
<pre><code>介绍完工具，现在我们可以开始实现我们的编译器了。
</code></pre><h6 id="词法分析器">词法分析器</h6><pre><code>前面提到 词法分析器 要将源程序分解成 单词，我们的语法格式很简单，只包括：标识符，数字，数学运算符，括号和大括号等，我们将通过 <span class="attribute">Flex</span> 来生成 词法分析器 的源码，给 <span class="attribute">Flex</span> 使用的规则文件 lexical<span class="class">.l</span> 如下：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ast.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"syntactic.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SAVE_TOKEN  yylval.string = new std::string(yytext, yyleng)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TOKEN(t)    (yylval.token = t)</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%option noyywrap</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[ \t\n]                 ;</span><br><span class="line"><span class="string">"extern"</span>                <span class="keyword">return</span> TOKEN(TEXTERN);</span><br><span class="line"><span class="string">"return"</span>                <span class="keyword">return</span> TOKEN(TRETURN);</span><br><span class="line">[a-zA-Z_][a-zA-Z0-<span class="number">9</span>_]*  SAVE_TOKEN; <span class="keyword">return</span> TIDENTIFIER;</span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+                  SAVE_TOKEN; <span class="keyword">return</span> TINTEGER;</span><br><span class="line"></span><br><span class="line"><span class="string">"="</span>                     <span class="keyword">return</span> TOKEN(TEQUAL);</span><br><span class="line"><span class="string">"=="</span>                    <span class="keyword">return</span> TOKEN(TCEQ);</span><br><span class="line"><span class="string">"!="</span>                    <span class="keyword">return</span> TOKEN(TCNE);</span><br><span class="line"><span class="string">"("</span>                     <span class="keyword">return</span> TOKEN(TLPAREN);</span><br><span class="line"><span class="string">")"</span>                     <span class="keyword">return</span> TOKEN(TRPAREN);</span><br><span class="line"><span class="string">"&#123;"</span>                     <span class="keyword">return</span> TOKEN(TLBRACE);</span><br><span class="line"><span class="string">"&#125;"</span>                     <span class="keyword">return</span> TOKEN(TRBRACE);</span><br><span class="line"><span class="string">","</span>                     <span class="keyword">return</span> TOKEN(TCOMMA);</span><br><span class="line"><span class="string">"+"</span>                     <span class="keyword">return</span> TOKEN(TPLUS);</span><br><span class="line"><span class="string">"-"</span>                     <span class="keyword">return</span> TOKEN(TMINUS);</span><br><span class="line"><span class="string">"*"</span>                     <span class="keyword">return</span> TOKEN(TMUL);</span><br><span class="line"><span class="string">"/"</span>                     <span class="keyword">return</span> TOKEN(TDIV);</span><br><span class="line"></span><br><span class="line">.                       <span class="built_in">printf</span>(<span class="string">"Unknown token!\n"</span>); yyterminate();</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<pre><code>我们来解释一下，这个文件被 <span class="number">2</span> 个 %% 分成 <span class="number">3</span> 部分，第 <span class="number">1</span> 部分用 %{ 与 %} 包括的是一些 C++ 代码，会被原样复制到 Flex 生成的源码文件中，还可以在指定一些选项，如我们使用了 %option noyywrap，也可以在这定义宏供后面使用；第 <span class="number">2</span> 部分用来定义构成单词的规则，可以看到每条规都是一个 正则表达式 和 动作，很直白，就是 词法分析器 发现了匹配的 单词 后执行相应的 动作 代码，大部分只要返回 单词 给调用者就可以了；第 <span class="number">3</span> 部分可以定义一些函数，也会原样复制到生成的源码中去，这里我们留空没有使用。

现在我们可以通过调用 Flex 生成 词法分析器 的源码：

flex -o lexical.cpp lexical.l

生成的　lexical.cpp　里会有一个 yylex() 函数供　语法分析器　调用；你可能发现了，有些宏和变量并没有被定义（如TEXTERN，yylval，yytext 等），其实有些是 Flex 会自动定义的内置变量（如 yytext），有些是后面 语法分析器 生成工具里定义的变量（如 yylval），我们后面会看到。
</code></pre><h6 id="语法分析器">语法分析器</h6><pre><code>语法分析器 的作用是构建 抽象语法树，通俗的说 抽象语法树 就是将源码用树状结构来表示，每个节点都代表源码中的一种结构；对于我们要实现的语法，其语法树是很简单的，如下：



现在我们使用 <span class="keyword">Bison </span>生成 语法分析器 代码，同样 <span class="keyword">Bison </span>需要一个规则文件，我们的规则文件 syntactic.y 如下，限于篇幅，省略了某些部分，可以通过链接查看完整内容：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ast.h"</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yylex</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, s);<span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">%token &lt;token&gt; TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">program:</span><br><span class="line">  stmts &#123; programBlock = $<span class="number">1</span>; &#125;</span><br><span class="line">        ;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">func_decl:</span><br><span class="line">  ident TLPAREN func_decl_args TRPAREN block &#123; $$ = <span class="keyword">new</span> NFunctionDeclaration(*$<span class="number">1</span>, *$<span class="number">3</span>, *$<span class="number">5</span>); <span class="keyword">delete</span> $<span class="number">3</span>; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<pre><code>是不是发现和 <span class="attribute">Flex</span> 的规则文件很像呢？确实是这样，它也是分 3 个部分组成，同样，第一部分的 C++ 代码会被复制到生成的源文件中，还可以看到这里通过以下这样的语法定义前面了 <span class="attribute">Flex</span> 使用的宏：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%token &lt;token&gt; TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA</span><br></pre></td></tr></table></figure>
<pre><code>比较不同的是第 <span class="number">2</span> 部分，不像 Flex 通过 正则表达式 通过定义规则，这里使用的是 巴科斯范式（<span class="keyword">BNF: </span><span class="keyword">Backus-Naur </span>Form） 的形式定义了我们识别的语法结构。如下的语法表示函数：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func_decl:</span><br><span class="line">  ident TLPAREN func_decl_args TRPAREN block &#123; $$ = <span class="keyword">new</span> NFunctionDeclaration(*$<span class="number">1</span>, *$<span class="number">3</span>, *$<span class="number">5</span>); <span class="keyword">delete</span> $<span class="number">3</span>; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<pre><code>可以看到后面大括号中间的也是 动作 代码，上例的动作是在 抽象语法树 中生成一个函数的节点，其实这部分的其他规则也是生成相应类型的节点到语法树中。像 NFunctionDeclaration 这是一个我们自己定义的节点类，我们在 ast<span class="class">.h</span> 中定义了我们所要用到的节点，同样的，我们摘取一段代码如下：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> NFunctionDeclaration : <span class="keyword">public</span> NStatement &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">const</span> NIdentifier&amp; id;</span><br><span class="line">    VariableList arguments;</span><br><span class="line">    NBlock&amp; block;</span><br><span class="line">    NFunctionDeclaration(<span class="keyword">const</span> NIdentifier&amp; id,            </span><br><span class="line">            <span class="keyword">const</span> VariableList&amp; arguments, NBlock&amp; block) :</span><br><span class="line">        id(id), arguments(arguments), block(block) &#123; &#125;    </span><br><span class="line">    <span class="keyword">virtual</span> llvm::<span class="function">Value* <span class="title">codeGen</span><span class="params">(CodeGenContext&amp; context)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<pre><code>可以看到，它有 标识符（id），参数列表（arguments），函数体（block） 这些成员，在语法分析阶段会设置好这些成员的内容供后面的 目标码生成 阶段使用。还可以看到有一个 <span class="function"><span class="title">codeGen</span><span class="params">()</span></span> 虚函数，你可能猜到了，后面就是通过调用它来生成相应的目标代码。

我们可以通过以下命令调用 Bison 生成 语法分析器 的源码文件，这里我们使用 -d 使头文件和源文件分开，因为前面 词法分析器 的源码使用了这里定义的一些宏，所以需要使用这个头文件，这里将会生成 syntactic<span class="class">.cpp</span> 和 syntactic.hpp：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bison -d -o syntactic.cpp syntactic.y</span><br></pre></td></tr></table></figure>
<h6 id="目标码生成">目标码生成</h6><pre><code>这是最后一步了，这一步的主角是前面提到 LLVM，LLVM 是一个构建编译器的框架系统，我们使用他遍历 语法分析 阶段生成的 抽象语法树，然后为每个节点生成相应的 目标码。当然，无法避免的是我们需要使用 LLVM 提供的函数来编写生成目标码的源码，就是实现前面提到的虚函数 <span class="function"><span class="title">codeGen</span><span class="params">()</span></span>，是不是有点拗口？不过确实是这样。我们在 gen<span class="class">.cpp</span> 中编写了不同节点的生成代码，我们摘取一段看一下：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Value *NMethodCall::codeGen(CodeGenContext &amp;context) &#123;</span><br><span class="line">    Function *function = context.module-&gt;getFunction(id.name.c_str());    <span class="keyword">if</span> (function == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"no such function "</span> &lt;&lt; id.name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; args;</span><br><span class="line">    ExpressionList::const_iterator it;    </span><br><span class="line">    <span class="keyword">for</span> (it = arguments.begin(); it != arguments.end(); it++) &#123;</span><br><span class="line">        args.push_back((**it).codeGen(context));</span><br><span class="line">    &#125;</span><br><span class="line">    CallInst *call = CallInst::Create(function, makeArrayRef(args), <span class="string">""</span>, context.currentBlock());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating method call: "</span> &lt;&lt; id.name &lt;&lt; endl;   </span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<pre><code>看起来有点复杂，简单来说就是通过 LLVM 提供的接口来生成 目标码，需要了解更多的话可以去 LLVM 的官网学习一下。

至此，我们所有的工作基本都做完了。简单回顾一下：我们先通过 Flex 生成 词法分析器 源码文件 lexical.cpp，然后通过 Bison 生成 语法分析器 源码文件 syntactic<span class="class">.cpp</span> 和头文件 syntactic.hpp，我们自己编写了 抽象语法树 节点定义文件 ast<span class="class">.h</span> 和 目标码 生成文件 ast.cpp，还有一个 gen<span class="class">.h</span> 包含一点 LLVM 环境相关的代码，为了输出我们程序的结果，还在 printi<span class="class">.cpp</span> 里简单的通过调用 C 语言库函数实现了输出一个整数。

对了，我们还需要一个 main 函数作为编译器的入口函数，它在 main<span class="class">.cpp</span> 里：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    yyparse();</span><br><span class="line">    InitializeNativeTarget();</span><br><span class="line">    InitializeNativeTargetAsmPrinter();</span><br><span class="line">    InitializeNativeTargetAsmParser();</span><br><span class="line">    CodeGenContext context;</span><br><span class="line">    context.generateCode(*programBlock);</span><br><span class="line">    context.runCode();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>我们可以看到其调用了 <span class="function"><span class="title">yyparse</span><span class="params">()</span></span> 做 语法分析，（<span class="function"><span class="title">yyparse</span><span class="params">()</span></span> 内部会先调用 <span class="function"><span class="title">yylex</span><span class="params">()</span></span> 做 词法分析）；然后是一系列的 LLVM 初始化代码，context.<span class="function"><span class="title">generateCode</span><span class="params">(*programBlock)</span></span> 是开始生成 目标码；最后是 context.<span class="function"><span class="title">runCode</span><span class="params">()</span></span> 来运行代码，这里使用了 LLVM 的 JIT（Just In Time） 来直接运行代码，没有链接的过程。

现在我们可以用这些文件生成我们的编译器了，需要说明一下，因为 词法分析器 的源码使用了一些 语法分析器 头文件中的宏，所以正确的生成顺序是这样的：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bison -d -o syntactic.cpp syntactic.y</span><br><span class="line">flex -o lexical.cpp lexical.l syntactic.hpp</span><br><span class="line">g++ -c `llvm-config --cppflags` -<span class="built_in">std</span>=c++<span class="number">11</span> syntactic.cpp gen.cpp lexical.cpp printi.cpp main.cpp</span><br><span class="line">g++ -o xy-complier syntactic.o gen.o main.o lexical.o printi.o `llvm-config --libs` `llvm-config --ldflags` -lpthread -ldl -lz -lncurses -rdynamic</span><br></pre></td></tr></table></figure>
<pre><code>如果你下载了 GitHub 的源码，那么直接：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<pre><code>就可以完成以上过程了，正常会生成一个二进制文件 xy-complier，它就是我们的编译器了。
</code></pre><h6 id="编译测试">编译测试</h6><pre><code>我们使用之前提到实例 demo<span class="class">.xy</span> 来测试，将其内容传给 xy-complier 的标准输入就可以看到运行结果了：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat demo.xy | ./xy-complier</span><br></pre></td></tr></table></figure>
<pre><code>也可以直接通过

make <span class="built_in">test</span>
来测试，输出如下：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">define internal i64 @mult(i64 %a1, i64 %b2) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %a = alloca i64</span><br><span class="line">  %<span class="number">0</span> = load i64, i64* %a</span><br><span class="line">  store i64 %a1, i64* %a</span><br><span class="line">  %b = alloca i64</span><br><span class="line">  %<span class="number">1</span> = load i64, i64* %b</span><br><span class="line">  store i64 %b2, i64* %b</span><br><span class="line">  %<span class="number">2</span> = load i64, i64* %b</span><br><span class="line">  %<span class="number">3</span> = load i64, i64* %a</span><br><span class="line">  %<span class="number">4</span> = mul i64 %<span class="number">3</span>, %<span class="number">2</span></span><br><span class="line">  ret i64 %<span class="number">4</span>&#125;</span><br><span class="line">Running code:<span class="number">11</span>Exiting...</span><br></pre></td></tr></table></figure>
<pre><code>可以看到最后正确输出了期望的结果，至此我们简单的编译器就完成了。
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2014/05/17/easy_compiler/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2014/01/03/weapp/">
                            微信小程序探究
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2014-01-03T18:15:02+08:00">
	
		    Jan 03, 2014
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="Background">Background</h2><h4 id="时间轴">时间轴</h4><ol>
<li>2016年1月9日&nbsp;&nbsp;&nbsp;&nbsp;微信小程序启动日</li>
<li>2016年1月11日&nbsp;&nbsp;&nbsp;&nbsp;张小龙首次公开演讲透露正在探究新的公众号形态，即微信小程序</li>
<li>2016年11月3日夜&nbsp;&nbsp;&nbsp;&nbsp;微信小程序正式公测</li>
<li>2016年11月28日&nbsp;&nbsp;&nbsp;&nbsp;张小龙公开演讲公开微信小程序产品形态</li>
<li>2017年1月9日&nbsp;&nbsp;&nbsp;&nbsp;微信小程序正式推出时间</li>
</ol>
<h4 id="产品形态">产品形态</h4><ol>
<li>无消息推送</li>
<li>无微信入口、无应用商店<ul>
<li>扫码使用</li>
<li>LBS提示附近小程序</li>
</ul>
</li>
<li>不能分享到朋友圈<ul>
<li>能分享到聊天或群聊</li>
<li>分享的内容是<strong>活的</strong>，直接能与消息产生交互</li>
</ul>
</li>
<li>不能做游戏</li>
<li>提供有限的搜索能力<ul>
<li>用户触到才出现，不主动推荐</li>
</ul>
</li>
<li>和公众号相互独立</li>
</ol>
<h2 id="Native_or_Web?">Native or Web?</h2><p>初一看，觉得微信小程序是Native的，但到底是Native还是Web不好直接下定义，因为微信在这一块是保密的，下面将一层一层的摸索分析，并搜集证据证明自己的猜想。</p>
<h4 id="架构">架构</h4><p>首先看看大概的架构，包括了WXML、WXSS、MINA框架，前两者分别对应了HTML、CSS，而MINA作为一个MVVM框架无论是作用还是表现都跟Vue很像。<br><img src="https://www.processon.com/chart_image/586b45fae4b0dc8df7a47c9e.png" alt=""></p>
<h4 id="IDE">IDE</h4><p>微信小程序提供了用NW.js编写的IDE（微信开发者工具），从IDE着手，打开IDE，在Console中输入openVendor()，如下</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1fbdmjj8sfcj30n206gq3h.jpg" alt=""></p>
<p>打开得到以下目录</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1fbdmkr07lbj312i0aatb1.jpg" alt=""></p>
<p>注意到两个比较大的js文件：</p>
<ol>
<li>WAService.js  <ul>
<li>MINA框架代码，提供一些基础功能</li>
</ul>
</li>
<li>WAWebView.js <ul>
<li>View基于它来运行</li>
</ul>
</li>
</ol>
<p>基于对这两个文件大概的分析，是不是可以猜想它依然还是运行在Webview中的，由此得到如下一个简单的架构图</p>
<ul>
<li>微信开发者工具中运行了两个页面，一个是View对应的WXML页面，另一个是Service对应的MINA框架</li>
<li>两个页面并不互通，Service无法操作到View中的DOM和BOM，因此外部无法使用jQuery等框架</li>
<li>开发者工具中运行：基于Chrome</li>
<li>移动设备上的运行：Service应该是运行在X5内核(Android)和JavaScriptCore(iOS)独立的沙箱里；View还是基于Webview运行，但是为了增强体验，通过微信的平台提供一些原生的标签比如Map、Video等</li>
</ul>
<p><img src="https://www.processon.com/chart_image/586b67d5e4b067ce85304983.png" alt=""></p>
<h4 id="试验">试验</h4><p>为了进一步证明猜想，做一个进一步的试验，在WXML中写一些不被支持的标签，它依然能够被展示，进一步说明还是基于Webview运行的<br><img src="http://ww2.sinaimg.cn/large/006y8lVagw1fbdozoiczaj30mw068gnf.jpg" alt=""></p>
<p>设备中显示如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVagw1fbdp05rxc7j30js0ai76y.jpg" alt=""></p>
<h4 id="小结">小结</h4><p>通过以上从IDE到代码运行的分析，可以得出一些结论</p>
<ul>
<li>目前还是Webview渲染</li>
<li>对于开发者都是黑盒，具体的运行机制还没公开</li>
<li>以后可能会切换成Native渲染</li>
<li>需按照官方规定的规范开发</li>
</ul>
<h2 id="框架">框架</h2><h3 id="目录结构">目录结构</h3><ol>
<li>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page</li>
<li>app由app.js 、 app.json 、app.wxss组成，放在根目录下</li>
<li>page由js 、 wxml 、wxss 、json组成<br><img src="https://www.processon.com/chart_image/586b966fe4b0f7a9c36147c9.png" alt=""></li>
</ol>
<h3 id="Service（逻辑层）">Service（逻辑层）</h3><p>由JavaScript编写</p>
<ol>
<li>增加了程序和页面的生命周期方法</li>
<li>每个页面有独立作用域和模块化能力</li>
<li>丰富的API，调起微信特有功能，如扫一扫、支付、微信用户数据等</li>
<li>脱离DOM，数据驱动，非浏览器环境，不能BOM操作，比如document、window等 </li>
<li>代码被打包成一份JavaScript，启动时运行，结束时销毁</li>
</ol>
<h4 id="程序生命周期">程序生命周期</h4><p><img src="https://www.processon.com/chart_image/586b567fe4b067ce852dd284.png" alt=""></p>
<h4 id="页面生命周期">页面生命周期</h4><p><img src="https://www.processon.com/chart_image/586b5637e4b0f7a9c35b1095.png" alt=""></p>
<h4 id="作用域_&amp;_模块化">作用域 &amp; 模块化</h4><ul>
<li>在JavaScript文件中声明的变量和函数只在该文件中有效，不同的文件可声明相同名字的变量和函数</li>
<li>公共代码抽离为一个单独的js文件，作为一个模块，可用module.exports 或exports对外暴露</li>
</ul>
<h4 id="API">API</h4><p><img src="http://ww3.sinaimg.cn/large/006y8lVagw1fbdx0k511kj31kw1t11kx.jpg" alt=""></p>
<h3 id="View（视图层）">View（视图层）</h3><p>由WXML和WXSS编写，由Component展示</p>
<ol>
<li>Service的数据转成View，View的事件发送给Service</li>
<li>WXML描述页面结构</li>
<li>WXSS描述页面样式</li>
<li>Component是View的基本单元</li>
</ol>
<h4 id="WXML">WXML</h4><p><img src="https://www.processon.com/chart_image/586b9795e4b0f7a9c3615a90.png" alt=""></p>
<h4 id="WXSS">WXSS</h4><p>与CSS类比扩展了两个特性：</p>
<ol>
<li>尺寸单位<ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应</li>
</ul>
</li>
<li>样式导入 <ul>
<li>使用@import语句可以导入外联样式表</li>
</ul>
</li>
</ol>
<h4 id="组件">组件</h4><p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1fbdwasv58wj31kw0nl48p.jpg" alt=""></p>
<h2 id="工作流">工作流</h2><p>一个Page实例完整的工作流如下<br><img src="https://www.processon.com/chart_image/586b6558e4b0dc8df7a8ef42.png" alt=""></p>
<h2 id="小程序_VS_Weex_VS_ReactNative">小程序 VS Weex VS ReactNative</h2><p>因为Weex和ReactNative的核心理念没什么差异，而Weex解决了大部分ReactNative的痛点，并且Weex引入的Vue和小程序的MINA框架类似，性能和开发成本上都占据优势，如果想要详细了解Weex和ReactNative之间对比的可以翻看我的<a href="http://yolynn.com/2016/11/11/RN&amp;Weex/">这篇文章</a>，下面将主要为小程序和Weex之间的对比</p>
<h4 id="产品形态的异同">产品形态的异同</h4><ol>
<li>小程序旨在实现公众号的另一种形态，而Weex旨在实现Native生态的所有功能</li>
<li>小程序定位受限于微信平台，而Weex定位不受限制</li>
<li>小程序目前无法取代真正的Native应用，而Weex更有可能</li>
<li>小程序的运行依赖于微信平台，则如果给Weex提供相应的平台同样可以实现</li>
</ol>
<h4 id="技术实现的异同">技术实现的异同</h4><ol>
<li>小程序目前基于Webview渲染和部分微信平台提供的Native组件，而Weex基于JavaScriptCore解析jsbundle结合Framework生成对应的Native组件渲染</li>
<li>小程序提供了微信开发者工具，而Weex的开发不受IDE限制</li>
<li>小程序代码开发基于MINA框架受各种规范限制，而Weex基于Vue组件不受限制</li>
<li>小程序和Weex都能基于Chrome调试</li>
<li>小程序提供Native端运行的解决方案，而Weex除了Native还能在浏览器运行</li>
</ol>
<h4 id="性能对比">性能对比</h4><p> H5 &lt;= Hybrid &lt;= 微信小程序 &lt;= ReactNative &lt;= Weex &lt;= Native</p>
<h2 id="小程序_VS_Google_PWA">小程序 VS Google PWA</h2><h4 id="产品形态的异同-1">产品形态的异同</h4><ol>
<li>允许用户把觉得有用的应用保留下来，而不用去商店安装</li>
<li>零阻力、零安装、易于共享传播</li>
<li>不依赖网络，可离线使用</li>
<li>像本地应用一样交互 </li>
<li>得益于微信平台Native的支持，小程序性能更占优势</li>
<li>小程序的发布有大小限制</li>
<li>对于一个简单的应用，开发成本上小程序更占优势；而相对复杂的比如邮箱，PWA则更有优势</li>
</ol>
<h4 id="技术实现的异同-1">技术实现的异同</h4><ol>
<li>小程序在移动端的表现力基于webview和部分native标签(微信平台支持)</li>
<li>PWA离线缓存技术用到了Service Worker,它是一个更强大的AppCache</li>
<li>PWA支持H5最新推送通知的标准</li>
<li>小程序对于开发者保持黑盒，PWA对于开发者是开源，所以资源和经验更占优势</li>
</ol>
<h2 id="坑">坑</h2><h4 id="大坑">大坑</h4><p>受限于小程序的运行环境并非一个标准的浏览器环境，微信封装工作并不完善，导致以往的大量开发经验在小程序里并不适用，几个主要的问题在于</p>
<ol>
<li>无法调用NPM包<ul>
<li>原因：微信开发者工具不支持CommonJS标准</li>
</ul>
</li>
<li>无法使用Babel转码<ul>
<li>结果：无法使用ES6/7的特性，callback是件麻烦事儿</li>
</ul>
</li>
<li>无法重用组件<ul>
<li>仅支持视图模块的重用，无法抽取公共逻辑</li>
</ul>
</li>
</ol>
<p>其实，上面的坑也不是无解，通过 npm install -g labrador-cli 安装Labrador工具解决。</p>
<h4 id="小坑">小坑</h4><ol>
<li>功能存在不少的局限性，比如导航栏颜色、map组件问题</li>
<li>开发者工具不支持方向键、修改样式无只能提醒、不支持全局搜索</li>
<li>wx.request中method:”POST”模式下，后台收到请求但是data:{}数据消失，会发送一个空请求，解决方案是”Content-Type”要修改为”content-type”</li>
</ol>
<h2 id="Q_&amp;_A">Q &amp; A</h2><ol>
<li><p>小程序为什么没有应用商店？</p>
<ul>
<li>从竞争角度，苹果的APPStore作为直接竞争对手，这是一大阻力</li>
<li>从产品角度，小程序定位便是公众号的另一种形态</li>
<li>从开发角度，保留用户原始习惯的基础上，节省了大部分的开发成本</li>
</ul>
</li>
<li><p>小程序为什么要去中心化？<br><img src="https://www.processon.com/chart_image/586c6203e4b0f7a9c3672eb2.png" alt=""></p>
</li>
<li><p>小程序能带来什么变化？</p>
<ul>
<li>让公司降低开发成本，便于商业模式试错</li>
<li>让开发者更加注重服务的价值</li>
<li>让用户使用更加便捷</li>
</ul>
</li>
<li><p>小程序在微信里的展现模式？</p>
<ul>
<li>分享的消息可以互动，比如：分享到群聊的投票消息，其他用户不用打开消息，而是直接在消息上进行互动投票</li>
<li>小程序可以挂起到聊天页顶部，如下图<br><img src="http://ww3.sinaimg.cn/large/006y8lVagw1fbedqngmymj30nk0j2gn1.jpg" alt=""></li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2><p>个人认为ReactNative的思想是非常适合应用到微信小程序里的，至于微信小程序为什么选择没有使用，我想应该有两方面的原因：</p>
<ol>
<li>从技术角度考虑，和ReactNative自身的一些瓶颈有关，比如版本不稳定、listView性能问题、真机调试繁琐等</li>
<li>从产品形态定位考虑，小程序出发点就是微信公众号的另一种形态，结合微信平台提供的Native组件和越来越成熟的SPA技术就能带给用户比较好的体验</li>
</ol>
<p>由此可以预见，如果上述原因中技术问题得以解决，那么产品形态的定位便可以大大扩展，而Weex做的事情中解决了大部分ReactNative的瓶颈问题，那么使用Weex结合微信小程序的思想所得到的产品形态势必可以大大的扩展。</p>
<h2 id="Demo">Demo</h2><p><a href="https://github.com/yolynn-bird/yo-weapp-demo" target="_blank" rel="external">https://github.com/yolynn-bird/yo-weapp-demo</a></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2014/01/03/weapp/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2013/07/17/tree/">
                            数据结构之各种树是如何让你纠结的？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2013-07-17T18:15:02+08:00">
	
		    Jul 17, 2013
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <ol>
<li><p>树与树的表示</p>
<h6 id="什么是树？">什么是树？</h6><p> 客观世界中许多事物存在层次关系</p>
<ul>
<li>人类社会家谱</li>
<li>社会组织结构</li>
<li><p>图书信息管理</p>
<p>分层次组织在管理上具有更高的效率！</p>
<p>数据管理的基本操作之一：查找（根据某个给定关键字K，从集合R 中找出关键字与K 相同的记录）。一个自然的问题就是，如何实现有效率的查找？</p>
</li>
<li><p>静态查找：集合中记录是固定的，没有插入和删除操作，只有查找</p>
</li>
<li><p>动态查找：集合中记录是动态变化的，除查找，还可能发生插入和删除</p>
<p>静态查找——方法一：顺序查找（时间复杂度O(n)）</p>
</li>
</ul>
</li>
</ol>
<pre><code><span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequentialSearch</span><span class="params">(StaticTable * Tbl, ElementType K)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="comment">// 在表Tbl[1]~Tbl[n] 中查找关键字为K的数据元素   </span></span><br><span class="line">    <span class="keyword">int</span> i;   </span><br><span class="line">    Tabl-&gt;Element[<span class="number">0</span>] = K; <span class="comment">// 建立哨兵   </span></span><br><span class="line">    <span class="keyword">for</span>(i = Tbl-&gt;Length; Tbl-&gt;Element[i] != K; i--)   </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 查找成功返回所在单元下标；不成功返回0   &#125;</span></span><br></pre></td></tr></table></figure></span>



静态查找——方法二：二分查找（时间复杂度O(logn)）

二分查找的启示？

* 二分查找判定树：
* 判定树上每个结点需要的查找次数刚好为该结点所在的层数
 * 查找成功时查找次数不会超过判定树的深度
* n 个结点的判定树的深度为⌊log2n⌋+1

###### 树的定义

树（Tree）：n（n ≥ 0）个结点构成的有限集合。

* 当n = 0 时，称为空树。
* 对于任一颗非空树（n &gt; 0），它具备以下性质：
* 树中有一个称为"根（Root）"的特殊结点，用r 表示；
* 其余结点（与r 相关联的）可分为m（m  &gt; 0）个互不相交的有限集T1，T2，...，Tm，其中每个集合本身又是一颗树，称为原来树的"子树（SubTree）"。

###### 树与非树？

* 子树是不相交的
* 除了根结点外，每个结点有且仅有一个父节点
* 一颗N个结点的树有N-1条边（我认为可以用构造性的存在性证明或是数学归纳法来证明这一点）

###### 树的一些基本术语：

* 结点的度（Degree）：结点的子树个数
* 树的度：树的所有结点中最大的度数
* 叶结点（Leaf）：度为0的结点
* 父结点（Parent）：有子树的结点是其子树的根结点的父结点
* 子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点
* 兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点
* 路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，...，nk，ni是ni+1的父结点，路径所包含的边的个数为路径的长度
* 祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点
* 子孙结点（Descendant）：某一结点的子树中的所有结点都是这个结点子孙
* 结点的层次（Level）：规定根结点在1层，其它任一结点的层数时其父节点的层数加1
* 树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度

###### 树的表示

为可节省空间，最常用的表示树的方法是儿子-兄弟表示法。

### 2. 二叉树及存储结构

###### 二叉树的定义

二叉树T：一个有穷的结点集合

* 这个集合可以为空
* 若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的    

二叉树组成

* 二叉树具有五种基本形态（空、单根、根+TL、根+TR、根+TL+TR）
* 二叉树的子树有左右顺序之分

###### 特殊二叉树

斜二叉树（Skewed Binary Tree）、完美二叉树（Perfect Binary Tree）/满二叉树（Full Binary Tree）、完全二叉树（Complete Binary Tree）

这里重点介绍下CBT：有n 个结点的二叉树，对树中结点按从上至下、从左至右顺序进行编号，编号为i （1 ≤ i ≤ n）结点与满二叉树中编号为i 结点在二叉树中位置相同

###### 二叉树几个重要性质

* 一个二叉树第i 层的最大结点数为：2i-1，i ≥ 1
* 深度为k 的二叉树有最大结点总数为：2k-1，k ≥ 1
* 对任何非空二叉树T，若n0 表示叶结点的个数，n2 是度为2 的非叶结点个数，那么两者满足关系n0 = n2 + 1（证明见这里）

###### 二叉树的抽象数据类型

重要操作：

* BinTree CreateBinTree()：创建一个二叉树
* Boolean IsEmpty(BinTree BT)：判别BT 是否为空
* void Traversal(BinTree BT)：遍历，按某顺序访问每个结点

常用的遍历方法有：

* void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树
* void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树
* void PostOrderTraversal(BinTree BT)：后序——左子树、右子树、根
* void LevelOrderTraversal(BinTree BT)：层次遍历——从上到下、从左到右

###### 二叉树的存储结构

顺序存储结构

* 依完全二叉树的形式存储：按从上到下、从左到右顺序存储。
* n 个结点的完全二叉树的节点父子关系：
* 非根节点（序号i &gt; 1）的父结点序号是⌊i/2⌋
* 结点（序号为i）的左孩子结点的序号是2i（若2i ≤ n，否则没有左孩子）
* 结点（序号为i）的右孩子结点的序号是2i+1（若 2i+1 ≤ n，否则没有右孩子）

应当注意的一点是：一般二叉树也可以采用这种结构，但会造成空间浪费

链表存储

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode *BinTree;   </span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;   </span><br><span class="line"><span class="keyword">struct</span> TreeNode&#123;   </span><br><span class="line">    ElementType Data;   </span><br><span class="line">    BinTree Left;   </span><br><span class="line">    BinTree Right;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

### 3. 二叉树的遍历

###### 二叉树的递归遍历

先序遍历：访问根结点；先序遍历其左子树；先序遍历其右子树

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(BT)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, BT-&gt;data);   </span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);   </span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

中序遍历：中序遍历其左子树；访问根结点；中序遍历其右子树

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(BT)   </span><br><span class="line">    &#123;   </span><br><span class="line">        InOrderTraversal(BT-&gt;Left);   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, BT-&gt;Data);   </span><br><span class="line">        InOrderTraversal(BT-&gt;Right);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

后序遍历：后续遍历其左子树；后续遍历其右子树；访问根结点

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(BT)   </span><br><span class="line">    &#123;   </span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);   </span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, BT-&gt;Data);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

附注：先序、中序和后序遍历过程：遍历过程经过结点的路线一样，只是访问各结点的时机不同。下图在从入口到出口的曲线上用ⓧ、★和△三种符号分别标记出了先序、中序和后序访问各结点的时刻



先序：当曲线第一次经过一个结点时，就列出这个结点；中序：当曲线第一次经过一个树叶时，就列出这个树叶，当曲线第二次经过一个内点时就列出这个内点；后序：当曲线最后一次经过一个结点而返回这个结点的父亲时，就列出这个结点。

###### 二叉树的非递归遍历

非递归遍历算法实现的基本思路：使用堆栈。我们以中序遍历的非递归算法为例：

* 遇到一个结点，就把它压栈，并去遍历它的左子树
* 当左子树遍历结束后，从栈顶弹出这个结点并访问它
* 然后按其右指针再去中序遍历该结点的右子树

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    BinTree T = BT;   </span><br><span class="line">    Stack S = CreateStack(MaxSize); <span class="comment">// 创建并初始化堆栈   </span></span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">while</span>(T) <span class="comment">// 一直向左并将沿途结点压入堆栈   </span></span><br><span class="line">        &#123;   </span><br><span class="line">            Push(S, T);   </span><br><span class="line">            T = T-&gt;Left;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S)) <span class="comment">// 不是必须的，因为while入口处已经判断过了   </span></span><br><span class="line">        &#123;   </span><br><span class="line">            T = Pop(S); <span class="comment">// 结点弹出堆栈   </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%5d"</span>, T-&gt;Data); <span class="comment">// (访问)打印结点   </span></span><br><span class="line">            T = T-&gt;Right; <span class="comment">// 转向右子树   </span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

注意到先序的非递归算法只要在中序非递归算法的基础上做一下调整就好了：printf语句放到Push操作之前。而后续遍历就比较繁琐了，因为当指针T指向一个结点时，不能马上对它进行访问，而要先遍历它的左子树，因而要将此结点的地址进栈保存。当其左子树遍历完毕之后，再次搜索到该结点时（退栈），还不能对它访问，还需要遍历它的右子树，所以，再一次将此结点的地址进栈保存。为了区别同一结点的两次进栈，需要引入一个标志变量，比如flag为0表示该结点暂不访问，为1表示该结点可以访问。

###### 层序遍历

层序遍历基本过程：先根结点入队，然后：

* 从队列中取出一个元素
* 访问该元素所指结点
* 若该结点所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    Queue Q;   </span><br><span class="line">    BinTree T;   </span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="comment">// 若是空树直接返回   </span></span><br><span class="line">        <span class="keyword">return</span>;   </span><br><span class="line">    Q = CreateQueue(MaxSize); <span class="comment">// 创建并初始化队列Q   </span></span><br><span class="line">    AddQ(Q, BT);   </span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))   </span><br><span class="line">    &#123;   </span><br><span class="line">        T = Delete(Q);   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;Data); <span class="comment">// 访问取出队列的结点   </span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left)   </span><br><span class="line">            AddQ(Q, T-&gt;Left);   </span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right)   </span><br><span class="line">            AddQ(Q, T-&gt;Right);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

###### 遍历二叉树的应用

输出二叉树中的叶子结点

在二叉树的遍历算法中增加检测结点的"左右子树是否都为空"

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderPrintLeaves</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(BT)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, BT-&gt;Data);   </span><br><span class="line">        PerOrderPrintLeaves(BT-&gt;Left);   </span><br><span class="line">        PerOrderPrintLeaves(BT-&gt;Right);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

###### 求二叉树的高度

需要注意到Height = Max(HL, HR) + 1

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostOrderGetHeight</span><span class="params">(BinTree BT)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> HL, HR, MaxH;   </span><br><span class="line">    <span class="keyword">if</span>(BT)   </span><br><span class="line">    &#123;   </span><br><span class="line">        HL = PostOrderGetHeight(BT-&gt;Left); <span class="comment">// 求左子树的深度   </span></span><br><span class="line">        HR = PostOrderGetHeight(BT-&gt;Right); <span class="comment">// 求右子树的深度   </span></span><br><span class="line">        MaxH = (HL &gt; HR) ? HL : HR; <span class="comment">// 取左右子树中较大的深度   </span></span><br><span class="line">        <span class="keyword">return</span> MaxH + <span class="number">1</span>; <span class="comment">// 返回树的深度   </span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空树深度为0   &#125;</span></span><br></pre></td></tr></table></figure></span>


由先序和中序遍历序列来确定一颗二叉树

* 根据先序遍历序列第一个结点确定根结点
* 根据根结点在中序遍历序列中的位置分隔出左右两个子序列
* 对左子树和右子树分别递归使用相同的方法继续分解
* 类似地，后序和中序遍历序列也可以确定一颗二叉树

### 4. 二叉搜索树

先来回顾一下之前提到的查找问题（静态查找与动态查找），针对动态查找，数据如何组织？

###### 什么是二叉搜索树

二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树：一颗二叉树，可以为空；如果不为空，满足以下性质：

* 非空左子树的所有键值小于其根结点的键值
* 非空右子树的所有键值大于其根结点的键值
* 左、右子树都是二叉搜索树

###### 二叉搜索树操作的特别函数

* Postion Find(ElementType X, BinTree BST)：从二叉搜索树BST中查找元素X，返回其所在结点的地址
* Postion FindMin(BinTree BST)：从二叉搜索树BST中查找并返回最小元素所在结点的地址
* Position FindMax(BinTree BST)：从二叉搜索树BST中查找并返回最大元素所在结点的地址
* BinTree Insert(ElementType X, BinTree BST)
* BinTree Delete(ElementType X, BinTree BST)

###### 二叉搜索树的查找操作：Find

* 查找从根结点开始，如果树为空，返回NULL
* 若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：
    * 若X小于根结点键值，只需在左子树中继续搜索
    * 若X大于根结点的键值，在右子树中继续进行搜索
    * 若两者比较结果相等，搜索完成，返回指向此结点的指针。

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Positon <span class="title">Find</span><span class="params">(ElementType X, BinTree BST)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(!BST)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找失败   </span></span><br><span class="line">    <span class="keyword">if</span>(X &gt; BST-&gt;Data)   </span><br><span class="line">        <span class="keyword">return</span> Find(X, BST-&gt;Right); <span class="comment">// 在右子树中继续查找   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">if</span>   </span><br><span class="line">        return <span class="title">Find</span><span class="params">(X, BST-&gt;Left)</span></span>; <span class="comment">// 在左子树中继续查找   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// X == BST-&gt;Data   </span></span><br><span class="line">        <span class="keyword">return</span> BST; <span class="comment">// 查找成功，返回结点的地址   &#125;</span></span><br></pre></td></tr></table></figure></span>


上面程序中的两处递归调用都是尾递归，因此可以方便的改写为迭代函数，以便提高执行效率（注意到，查找的效率取决于树的高度）

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">IterFind</span><span class="params">(ElementType X, BinTree BST)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(BST)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)   </span><br><span class="line">            BST = BST-&gt;Right; <span class="comment">// 向右子树中移动，继续查找   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)   </span><br><span class="line">            BST = BST-&gt;Left; <span class="comment">// 向左子树中移动，继续查找   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// X == BST-&gt;Data   </span></span><br><span class="line">            <span class="keyword">return</span> BST; <span class="comment">// 查找成功，返回结点的地址   </span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找失败   &#125;</span></span><br></pre></td></tr></table></figure></span>


查找最大和最小元素

只需注意到以下事实：

* 最大元素一定在树的最右分支的端结点上
* 最小元素一定在树的最左分支的端节点上

查找最小元素的递归函数

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Postion <span class="title">FindMin</span><span class="params">(BinTree BST)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(!BST)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空的二叉搜索树，返回NULL   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)   </span><br><span class="line">        <span class="keyword">return</span> BST; <span class="comment">// 找到最左叶结点并返回   </span></span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left); <span class="comment">// 沿左分支继续查找   &#125;</span></span><br></pre></td></tr></table></figure></span>


查找最大元素的迭代函数

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(BinTree BST)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(BST)   </span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right)   </span><br><span class="line">            BST = BST-&gt;Right; <span class="comment">// 沿右分支继续查找，直到最右结点   </span></span><br><span class="line">    <span class="keyword">return</span> BST;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

二叉搜索树的插入

关键是要找到元素应该插入的位置，可以采用与Find类似的方法

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(ElementType X, BinTree BST)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(!BST)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 若原树为空，生成并返回一个结点的二叉搜索树   </span></span><br><span class="line">        BST = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));   </span><br><span class="line">        BST-&gt;Data = X;   </span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 开始找要插入元素的位置   </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST-&gt;Data)   </span><br><span class="line">            BST-&gt;Left = Insert(X, BST-&gt;Left); <span class="comment">// 递归插入左子树   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)   </span><br><span class="line">            BST-&gt;Right = Insert(X, BST-&gt;Right); <span class="comment">// 递归插入右子树   </span></span><br><span class="line">        <span class="comment">// else X已经存在，什么都不做   </span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> BST;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

关于上面的代码，多说一点，就是关于递归调用返回的时候需要赋值给左子树或右子树，这在大多数赋值的情况下显得多余（就像是说，把当前树的左子树赋值给它的左子树），但是它是必须的，因为在插入元素的时候我们需要知道它的父结点的左指针或右指针。我们也可以消除不必要的赋值，但是它是以增加逻辑判断为代价的，还不如原先的方式显得清晰、美观。

###### 二叉搜索树的删除

要考虑三种情况

* 要删除的是叶节点：直接删除，并再修改其父结点指针，置为NULL
* 要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点
* 要删除的结点有左、右两颗子树：用另一结点替代被删除结点：右子树的最小元素或者左子树的最大元素

<span class="comment"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(ElementType X, BinTree BST)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    Position Tmp;   </span><br><span class="line">    <span class="keyword">if</span>(!BST)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"要删除的元素未找到"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)   </span><br><span class="line">        BST-&gt;Left = Delete(X, BST-&gt;Left); <span class="comment">// 左子树递归删除   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)   </span><br><span class="line">        BST-&gt;Right = Delete(X, BST-&gt;Right); <span class="comment">// 右子树递归删除   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 找到要删除的结点   </span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right) <span class="comment">// 被删除结点有左右两个子结点   </span></span><br><span class="line">        &#123;   </span><br><span class="line">            Tmp = FindMin(BST-&gt;Right); <span class="comment">// 在右子树中找最小的元素填充删除结点   </span></span><br><span class="line">            BST-&gt;Data = Tmp-&gt;Data;   </span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right); <span class="comment">// 在删除结点的右子树中删除最小元素   </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 被删除结点有一个或无子结点   </span></span><br><span class="line">        &#123;   </span><br><span class="line">            Tmp = BST;   </span><br><span class="line">            <span class="keyword">if</span>(!BST-&gt;Left) <span class="comment">// 有右孩子或无子结点   </span></span><br><span class="line">                BST = BST-&gt;Right;   </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right) <span class="comment">// 有左孩子或无子结点   </span></span><br><span class="line">                BST = BST-&gt;Left;   </span><br><span class="line">            <span class="built_in">free</span>(Tmp);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> BST;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

### 5、平衡二叉树

###### 什么是平衡二叉树
搜索树结点不同插入次序，将导致不同的深度和平均查找程度，这促使二叉树"平衡"这个概念的出现。二叉树平衡与否的度量由"平衡因子"（Balance Factor，简称BF：BF(T) = HL - HR，其中HL和HR分别为T的左、右子树的高度）来决定。

平衡二叉树（Balanced Binary Tree）（AVL树）：

空树，或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T)| ≤ 1
</code></pre><p>我们之所以想要二叉树在一定程度上达到平衡，就是奔着它的效率去的，那么很自然的一个问题是：平衡二叉树的高度能达到log2n吗？</p>
<pre><code>设nh 为高度为h 的平衡二叉树的最少结点数。结点数最少时：nh = nh-1 + nh-2 + 1。

可以看到，其形式非常类似于斐波那契数列。我们结合初始条件n0 = 1，n1 = 2不难得出nh = Fh+2 - 1。于是我们可以说h = O(log2n)。通俗的说就是，给定结点数为n 的AVL树的最大高度为O(log2n)。

<span class="comment">###### 平衡二叉树的调整</span>

AVL树的调整分为四种情况，分别为左单旋、右单旋、左右双旋、右左双旋。值得注意的一点是：有时候插入元素即便不需要调整结构，也可能需要重新计算一些平衡因子。

何老师给的图很好，简洁明了的表达了需要调整的情况并且给出了具体调整的方法：




<span class="comment">### 6、堆　</span>

<span class="comment">###### 什么是堆</span>

优先队列（Priority Queue）：特殊的<span class="string">"队列"</span>，取出元素的顺序是依照元素的优先权（关键字）的大小，而不是元素进入队列的先后顺序。

问题：如何组织优先队列？

<span class="keyword">*</span> 一般的数组、链表？
<span class="keyword">*</span> 有序的数组、链表？
<span class="keyword">*</span> 二叉搜索树？AVL树？

对于堆来说，主要就是两个操作，插入和删除，而无论是一般的数组、链表，还是有序的数组、链表其中至少有一个操作是需要O(n) 的时间来完成的。可以考虑能否采用二叉树存储结构？如果采用这种存储结构的话，我们更应该关注插入还是删除操作？树结点顺序怎么安排？树结构怎样？

<span class="comment">###### 堆的两个特性：</span>

<span class="keyword">*</span> 结构性：用数组表示的完全二叉树
<span class="keyword">*</span> 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）

<span class="comment">###### 堆的抽象数据类型</span>

以最大堆为例，其主要操作有：

<span class="keyword">*</span> MaxHeap Create(int MaxSize)：创建一个空的最大堆
<span class="keyword">*</span> Boolean IsFull(MaxHeap H)：判断最大堆H是否已满
<span class="keyword">*</span> void Insert(MaxHeap H, ElementType item)：将元素item插入最大堆H
<span class="keyword">*</span> Boolean IsEmpty(MaxHeap H)：判断最大堆是否为空
<span class="keyword">*</span> ElementType DeleteMax(MaxHeap H)：返回H中最大元素（高优先级）

 最大堆的创建

注意到，把MaxData换成小于堆中所有元素的MinData，同样适用于创建最小堆。

<span class="comment">### 最大堆的插入</span>

思路：首先默认插入位置在完全二叉树的下一个位置，通过向下过滤结点的方式，从其父结点到根结点的有序序列中寻找合适的位置进行插入操作

<span class="variable"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H, ElementType item)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="comment">// 将元素item插入最大堆H，其中H-&gt;Elements[0]已经定义为哨兵   </span></span><br><span class="line">    <span class="keyword">int</span> i;   </span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"最大堆已满"</span>);   </span><br><span class="line">        <span class="keyword">return</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    i = ++H-&gt;Size; <span class="comment">// i指向插入后堆中的最后一个元素的位置   </span></span><br><span class="line">    <span class="keyword">for</span>(; H-&gt;Elements[i/<span class="number">2</span>] &lt; item; i /= <span class="number">2</span>)   </span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>]; <span class="comment">// 向下过滤结点，这种方式比交换数据来得快   </span></span><br><span class="line">    H-&gt;Elements[i] = item; <span class="comment">// 将item插入   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>


上述代码中，H-&gt;Elements[0]是哨兵元素，它不小于堆中的最大元素，控制循环结束。时间复杂度O(logN)。

最大堆的删除

思路：取出根结点（最大值），同时删除它，方法就是用堆中的最后一个元素代替之（和插入操作一样，这里的代替只是形式上方便理解的说辞，实际上我们只是用一个临时变量保存其值而已，这比真实的替代更省时），但是其位置不一定正确，因此需要从根结点开始向上过滤下层结点。



最大堆的建立

建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中

<span class="keyword">*</span> 方法一：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价为O(NlogN)
<span class="keyword">*</span> 方法二：线性时间复杂度下建立最大堆

将N个元素按输入顺序存入，先满足完全二叉树的结构特性
调整各结点位置，以满足最大堆的有序特性。

重点说下方法二，从完全二叉树的倒数第二层开始调整，因为其左、右子树只有一个结点，本身构成了一个堆，因此可以用过滤的方式以当前层为根，将根放到合适的位置。经过一轮调整，可以从倒数第三层开始（其左、右子树仍然各自构成一个堆），续行此法，直到完全二叉树的Root放置到合适的位置为止。

可以证明（由每层的结点数和该层的最多交换次数找出一般规律，利用错位相消可解出闭形式）这种方法的时间复杂度是线性的，即T(N) = O(N)。

<span class="comment">### 7、哈夫曼树与哈夫曼编码</span>

<span class="comment">###### 什么是哈夫曼树</span>

我们需要先引入一个概念——带权路径长度（WPL）：

设二叉树有n个叶子结点，每个叶子结点带有权值Wk，从根结点到每个叶子结点的长度为Lk，则每个叶子结点的带权路径长度之和就是WPL = Σ(k=1~n)WkLk

最优二叉树或哈夫曼树就是WPL最小的二叉树，因此哈夫曼树说白了就是根据结点不同的查找频率构造的最有效的搜索树。

<span class="comment">###### 哈夫曼树的构造</span>

基本思路：每次把权值最小的两颗二叉树合并，把两者的和作为当前树新的权值，再取两个权值最小的二叉树合并，续行此法，直至结点取空。

下面是时间复杂度为O(NlogN)的做法：



<span class="comment">###### 哈夫曼树的特点</span>

<span class="keyword">*</span> 没有度为1的结点
<span class="keyword">*</span> n个叶子结点的哈夫曼树共有2n-1个结点
<span class="keyword">*</span> 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树
<span class="keyword">*</span> 对同一组权值{W1，W2，...，Wn}，是否存在不同构的两颗哈夫曼树呢？
<span class="keyword">*</span> 答案是肯定的，比如对于一组权值{1，2，3，3}，不同构的两颗哈夫曼树如下：



容易算出二者的WPL值均为18，之所以出现这样的结果是因为3个权值为3的结点合并的时机不同导致的。

<span class="comment">###### 哈夫曼编码</span>

考虑这样一个问题：用位串来编码英语字母表里的字母（不区分大小写），可以用长度为5的位串来表示每个字母，这样用来编码数据的总数是5乘以文本中的字符数，有没有可能找出这些字母的编码方案，使得在编码数据时使用的位更少？若可能，那么就可以节省存储空间。

哈夫曼编码作为一种不等长的编码形式，一个需要解决的关键性问题就是如何避免二义性。为了保证无二义地解码，我们采用前缀码——任何字符的编码都不是另一个字符编码的前缀。用二叉树进行编码：左右分支0、1；字符只在叶节点上。

<span class="comment">### 8、集合及运算</span>

<span class="comment">###### 集合的表示</span>

<span class="keyword">*</span> 集合运算：交、并、补、差，判定一个元素是否属于某一集合
<span class="keyword">*</span> 并查集：集合并、查某元素属于什么集合
<span class="keyword">*</span> 并查集问题中集合存储如何实现？可以用树结构表示集合，树的每个结点代表一个集合元素，采用双亲表示法：孩子指向父结点。

更加简便的方法是采用数组存储形式，数组中有两个域：Data和Parent。其中Parent为负数表示根结点，非负数表示双亲结点的下标。数组中每个元素的类型描述如下：

<span class="variable"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;   </span><br><span class="line">    ElementType Data;   </span><br><span class="line">    <span class="keyword">int</span> Parent;   </span><br><span class="line">&#125;SetType;</span><br></pre></td></tr></table></figure></span>

<span class="comment">###### 集合运算</span>

查找某个元素所在的集合（用根结点表示）

<span class="variable"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType S[], ElementType X)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="comment">// 在数组中查找值为X的元素所属的集合   </span></span><br><span class="line">    <span class="comment">// MaxSize是全局变量，为数组S的最大长度   </span></span><br><span class="line">    <span class="keyword">int</span> i;   </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++)   </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">if</span>(i &gt;= MaxSize)   </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到X，返回-1   </span></span><br><span class="line">    <span class="keyword">for</span>(; S[i].Parent &gt;= <span class="number">0</span>; i = S[i].Parent)   </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 找到X所属集合，返回数根结点在数组S中的下标   &#125;</span></span><br></pre></td></tr></table></figure></span>


<span class="comment">###### 集合的并运算</span>

<span class="keyword">*</span> 分别找到X1和X2两个元素所在集合树的根结点
<span class="keyword">*</span> 如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标

<span class="variable"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType S[], ElementType X1, ElementType X2)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> Root1, Root2;   </span><br><span class="line">    Root1 = Find(S, X1);   </span><br><span class="line">    Root2 = Find(S, X2);   </span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)   </span><br><span class="line">        S[Root2].Parent = Root1;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>


<span class="comment">###### 效率优化</span>

注意到上面的Union操作可能导致的一个问题就是树倾斜问题严重，导致Find操作低效，因此一个自然的想法，就是把小的集合合并到大的集合中，为此可以为数据结构增加一个域代表该集合的元素个数，但是这是没有必要的，因为除了根结点外，其他的结点无需保存集合元素个数，这样一个更好的方法便是：将集合的根结点的Parent设置为当前集合元素个数的负数。这样的话，合并的时候只需要取其绝对值参与运算即可。

说完了Union的优化，我们来考虑一下Find操作是否可以优化，答案是肯定的，就是所谓的路径压缩，每次查找一个结点的时候，将其查找路径上的全部结点直接指向其父节点。后面我会写一篇PAT树部分的习题解答，关于这两个操作优化后的具体实现可以在里面找到。
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2013/07/17/tree/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/page/3/">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/page/5/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 4 of 5</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 yolynn. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/head.png"/>
        
            <h4 id="about-card-name">yolynn</h4>
        
            <h5 id="about-card-bio"><p>云在青天水在瓶 - 幽灵鸟</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>vip.com</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/jquery.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox.js" type="text/javascript"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js" type="text/javascript"></script>
<script src="/assets/js/tranquilpeak.js" type="text/javascript"></script>
<!--SCRIPTS END-->



</html>
